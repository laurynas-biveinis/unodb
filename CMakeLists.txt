# Copyright 2019-2022 Laurynas Biveinis
cmake_minimum_required(VERSION 3.12)

project(unodb VERSION 0.1
  DESCRIPTION "unodb key-value store library"
  HOMEPAGE_URL "https://github.com/laurynas-biveinis/unodb" LANGUAGES CXX)

option(FATAL_WARNINGS "Make warning diagnostics fatal")
if(FATAL_WARNINGS)
  message(STATUS "Warning diagnostics are fatal")
else()
  message(STATUS "Warning diagnostics are not fatal")
endif()

set(CLANG_CXX_WARNING_FLAGS
  # Warning groups
  "-Wall" "-Wextra" "-Wconversion" "-Wdelete-non-virtual-dtor" "-Wdeprecated"
  "-Wgnu" "-Wimplicit" "-Wloop-analysis" "-Wparentheses" "-Wpedantic"
  "-Wpragmas"
  "-Wself-assign" "-Wshadow-all"
  # Individual warnings
  "-Wabstract-vbase-init" "-Warray-bounds-pointer-arithmetic" "-Wassign-enum"
  "-Watomic-implicit-seq-cst" "-Wbad-function-cast" "-Wc++2a-compat"
  "-Wc++2a-extensions" "-Wcast-align" "-Wcast-qual" "-Wclass-varargs" "-Wcomma"
  "-Wconditional-uninitialized" "-Wcovered-switch-default" "-Wdate-time"
  "-Wdeprecated-implementations" "-Wdisabled-macro-expansion"
  "-Wdouble-promotion" "-Wduplicate-decl-specifier" "-Wduplicate-enum"
  "-Wduplicate-method-arg" "-Wduplicate-method-match" "-Wextra-semi-stmt"
  "-Wfloat-equal" "-Wformat-pedantic" "-Wformat=2" "-Wheader-hygiene"
  "-Widiomatic-parentheses" "-Wimplicit-fallthrough" "-Wmain"
  "-Wmethod-signatures" "-Wmissing-noreturn" "-Wmissing-prototypes"
  "-Wmissing-variable-declarations" "-Wnewline-eof" "-Wnon-virtual-dtor"
  "-Wnonportable-system-include-path" "-Wold-style-cast" "-Wover-aligned"
  "-Wpacked" "-Wpointer-arith" "-Wprofile-instr-missing" "-Wredundant-parens"
  "-Wshift-sign-overflow" "-Wstatic-in-inline" "-Wstrict-prototypes"
  "-Wsuper-class-method-mismatch" "-Wswitch-enum" "-Wtautological-compare"
  "-Wtautological-constant-in-range-compare" "-Wundef"
  "-Wundefined-func-template" "-Wundefined-reinterpret-cast"
  "-Wunreachable-code-aggressive" "-Wunused-exception-parameter"
  "-Wunused-macros" "-Wunused-member-function" "-Wunused-template"
  "-Wused-but-marked-unused" "-Wvector-conversion" "-Wvla"
  "-Wweak-template-vtables" "-Wweak-vtables" "-Wzero-as-null-pointer-constant")
set(CLANG_LT_13_CXX_WARNING_FLAGS "-Wreserved-id-macro")
set(CLANG_GE_13_CXX_WARNING_FLAGS "-Wreserved-identifier")

set(GCC_CXX_WARNING_FLAGS
  # Warning groups
  "-Wall" "-Wextra" "-Wpedantic" "-Wunused" "-Wparentheses" "-Wconversion"
  # Individual warnings
  "-Wabi-tag" "-Wcast-align=strict" "-Wcast-qual" "-Wcatch-value=3"
  "-Wctor-dtor-privacy" "-Wdouble-promotion" "-Wduplicated-branches"
  "-Wduplicated-cond" "-Wextra-semi" "-Wfloat-equal" "-Wformat-overflow=2"
  "-Wformat-signedness" "-Wformat-truncation=2" "-Wformat=2"
  "-Wimplicit-fallthrough=5" "-Winvalid-pch" "-Wlogical-op" "-Wmismatched-tags"
  "-Wmissing-declarations" "-Wmissing-include-dirs" "-Wnoexcept"
  "-Wnon-virtual-dtor" "-Wnull-dereference" "-Wold-style-cast"
  "-Woverloaded-virtual" "-Wpacked" "-Wplacement-new=2" "-Wredundant-decls"
  "-Wshadow=global" "-Wsign-conversion" "-Wsign-promo" "-Wstrict-null-sentinel"
  "-Wstringop-truncation" "-Wsuggest-attribute=cold" "-Wsuggest-attribute=const"
  "-Wsuggest-attribute=format" "-Wsuggest-attribute=malloc"
  "-Wsuggest-attribute=noreturn" "-Wsuggest-attribute=pure"
  "-Wsuggest-final-methods" "-Wsuggest-final-types" "-Wsuggest-override"
  "-Wswitch-enum" "-Wtrampolines" "-Wundef" "-Wuninitialized"
  "-Wunsafe-loop-optimizations" "-Wunused-const-variable=2" "-Wunused-macros"
  "-Wuseless-cast" "-Wvector-operation-performance" "-Wvla"
  "-Wzero-as-null-pointer-constant" "-Wattribute-alias=2" "-Warray-bounds=2"
  "-Wredundant-tags")
set(GCC_GE_11_CXX_WARNING_FLAGS
  "-Wctad-maybe-unsupported" "-Wdeprecated-enum-enum-conversion"
  "-Wdeprecated-enum-float-conversion" "-Wvexing-parse")

set(UNIX_CXX_FLAGS "-g")

option(AVX2 "Enable AVX2 instructions on x86_64" ON)
if(AVX2)
  message(STATUS "Using AVX2 instructions on x86_64")
else()
  message(STATUS "Using SSE4.1 instructions on x86_64")
endif()

if(MSVC)
  # Remove it once CMake minimum is bumped to 3.15 or greater
      string(REGEX REPLACE "/W3" "" CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}")
endif()

# Disable the following warnings for MSVC:
# - "C4324: '...': structure was padded due to alignment specifier"
# - "C5030: attribute '...' is not recognized"
# - "C5072, ASAN enabled without debug information emission" - triggered by
#   msvc-release-asan preset
# - "C5246: '...': the initialization of a subobject should be wrapped in
#   braces": billions of std::array false positives with 17.2.2.
# - The other disabled warnings only activate on /Wall
set(MSVC_CXX_WARNING_FLAGS "/Wall" "/wd4324" "/wd5030" "/wd5072" 
  "/wd4623" "/wd4625" "/wd4626" "/wd4582" "/wd4820" "/wd4710" "/wd4711"
  "/wd4868" "/wd5026" "/wd5027" "/wd5045" "/wd5246")

set(MSVC_CLANG_CXX_FLAGS "/arch:AVX" "/permissive-")

# clang-cl warning flags that cl does not understand
set(MSVC_CLANGS_ONLY_WARNING_FLAGS "-Wno-c++98-compat"
  "-Wno-c++98-compat-pedantic" "-Wno-exit-time-destructors"
  "-Wno-ctad-maybe-unsupported" "-Wno-global-constructors")

# cl flags that clang-cl does not understand
set(MSVC_CXX_FLAGS "/external:anglebrackets" "/external:W0")

# Disable the following warnings for MSVC static analysis. I'd like to have 
# them enabled, but their suggestions result in runtime overhead in release 
# builds.
# - "C26429: Symbol 'inode' is never tested for nullness, it can be marked as 
#   not_null (f.23)."
# - "C26446: Prefer to use gsl::at() instead of unchecked subscript operator 
#   (bounds.4)."
# - "C26482: Only index into arrays using constant expressions (bounds.2)"
# This one seems like a false positive, of course I could be wrong
# - "C26415: Smart pointer parameter '...' is used only to access contained
#   pointer. Use T* or T& instead (r.30)."
# Won't fix
# - "C26472: Don't use a static_cast for arithmetic conversions. Use brace 
#   initialization, gsl::narrow_cast or gsl::narrow (type.1)"
# - "C26494: Variable '...' is uninitialized. Always initialize an object
#   (type.5)
set(MSVC_STATIC_ANALYSIS_FLAGS "/analyze" "/analyze:external-"
  "/analyze:pluginEspXEngine.dll" "/analyze:rulesetdirectory$ENV{VSINSTALLDIR}"
  "/analyze:rulesetNativeRecommendedRules.ruleset" "/wd26429" "/wd26446"
  "/wd26482" "/wd26415" "/wd26472" "/wd26494" "/analyze:log:format:sarif"
  "/analyze:logmsvc.sarif" "/analyze:log:compilerwarnings")

option(COVERAGE "Enable code coverage reporting")
if(COVERAGE)
  if(MSVC)
    message(FATAL_ERROR "MSVC is incompatible with code code coverage reporting")
  endif()
  option(GCOV_PATH "gcov tool location to be used by lcov")
  if(GCOV_PATH)
    set(LCOV_GCOV_ARG "--gcov-tool" "${GCOV_PATH}")
    message(STATUS "Code coverage reporting enabled with gcov at ${GCOV_PATH}")
  else()
    set(LCOV_GCOV_ARG "")
    message(STATUS "Code coverage reporting enabled with default gcov path")
  endif()
else()
  message(STATUS "Code coverage reporting not enabled")
endif()

find_path(VALGRIND_H_PATH valgrind.h PATH_SUFFIXES valgrind)
if(VALGRIND_H_PATH)
  find_path(MEMCHECK_H_PATH memcheck.h PATH_SUFFIXES valgrind)
  if(MEMCHECK_H_PATH)
    message(STATUS
      "valgrind.h & memcheck.h found, enabling Valgrind client requests in debug config")
    set(VALGRIND_CLIENT ON)
  else()
    message(STATUS
      "valgrind.h found but memcheck.h not found, disabling Valgrind client requests in debug config")
    set(VALGRIND_CLIENT OFF)
  endif()
else()
  message(STATUS
    "valgrind.h not found, disabling Valgrind client requests in debug config")
  set(VALGRIND_CLIENT OFF)
endif()

if(NOT (MSVC AND "${CMAKE_CXX_COMPILER_ID}" STREQUAL "Clang"))
  include(CheckIPOSupported)
  check_ipo_supported(RESULT IPO_SUPPORTED OUTPUT IPO_SUPPORT_ERROR LANGUAGES CXX)
  if(IPO_SUPPORTED)
    message(STATUS "Enabling IPO/LTO for release config")
  else()
    message(STATUS "IPO/LTO is not supported: ${IPO_SUPPORT_ERROR}")
  endif()
else()
  message(STATUS "Not enabling IPO/LTO due to MSVC LLVM not supporting it")
endif()

set(SANITIZER_CXX_FLAGS "")
set(SANITIZER_LD_FLAGS "")

macro(ADD_TO_GNU_SANITIZER_FLAGS)
  if("${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU")
    list(APPEND SANITIZER_CXX_FLAGS ${ARGV})
    list(APPEND SANITIZER_LD_FLAGS ${ARGV})
  endif()
endmacro()

macro(SET_COMMON_SANITIZER_FLAGS)
  if(NOT MSVC)
    list(APPEND SANITIZER_CXX_FLAGS "-fno-omit-frame-pointer"
        "-fno-optimize-sibling-calls")
  endif()
endmacro()

option(SANITIZE_ADDRESS "Enable AddressSanitizer runtime checks")
if(SANITIZE_ADDRESS)
  set_common_sanitizer_flags()
  if(MSVC)
    list(APPEND SANITIZER_CXX_FLAGS "/fsanitize=address")
    # Documented to be incompatible with ASan
    string(REGEX REPLACE "/RTC1" "" CMAKE_CXX_FLAGS_DEBUG 
        "${CMAKE_CXX_FLAGS_DEBUG}")
    string(REGEX REPLACE "/INCREMENTAL" "/INCREMENTAL:NO"
        CMAKE_EXE_LINKER_FLAGS_DEBUG "${CMAKE_EXE_LINKER_FLAGS_DEBUG}")
    string(REGEX REPLACE "/INCREMENTAL" "/INCREMENTAL:NO" 
        CMAKE_MODULE_LINKER_FLAGS_DEBUG "${CMAKE_MODULE_LINKER_FLAGS_DEBUG}")
    string(REGEX REPLACE "/INCREMENTAL" "/INCREMENTAL:NO" 
        CMAKE_SHARED_LINKER_FLAGS_DEBUG "${CMAKE_SHARED_LINKER_FLAGS_DEBUG}")
    string(REGEX REPLACE "/INCREMENTAL" "/INCREMENTAL:NO" 
        CMAKE_STATIC_LINKER_FLAGS_DEBUG "${CMAKE_STATIC_LINKER_FLAGS_DEBUG}")
  else()
    list(APPEND SANITIZER_CXX_FLAGS "-fsanitize=address")
    list(APPEND SANITIZER_LD_FLAGS "-fsanitize=address")
    add_to_gnu_sanitizer_flags("-fsanitize=leak"
        "-fsanitize-address-use-after-scope" "-fsanitize=pointer-compare"
        "-fsanitize=pointer-subtract")
  endif()
  string(CONCAT ASAN_ENV "ASAN_OPTIONS="
    "check_initialization_order=true:detect_stack_use_after_return=true:"
    "alloc_dealloc_mismatch=true:strict_string_checks=true")
  if(NOT "${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU")
    # Not for GCC, up to version 11 at least, because:
    # 1) AddressSanitizer CHECK failed:
    # ../../../../src/libsanitizer/asan/asan_thread.cpp:369 "((bottom)) != (0)"
    # (0x0, 0x0)
    # https://bugs.llvm.org/show_bug.cgi?id=47626
    # 2) ERROR: AddressSanitizer: invalid-pointer-pair: 0x7fffe8404697
    # 0x000000000000
    # #0 0x55d21abf7a40 in std::__cxx11::basic_stringbuf<char,
    # std::char_traits<char>, std::allocator<char> >::str() const
    # /usr/include/c++/8/sstream:173
    string(APPEND ASAN_ENV ":detect_invalid_pointer_pairs=2")
  endif()
  if("${CMAKE_CXX_COMPILER_ID}" STREQUAL "Clang"
      OR "${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU")
    string(APPEND ASAN_ENV ":detect_leaks=1")
  endif()
  set(SANITIZER_ENV ${ASAN_ENV})
else()
  if(MSVC AND NOT "${CMAKE_CXX_COMPILER_ID}" STREQUAL "Clang")
    string(REGEX REPLACE "/Zi" "/ZI" CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG}")
  endif()
  set(ASAN_ENV "")
endif()

option(SANITIZE_THREAD "Enable ThreadSanitizer runtime checks")
if(SANITIZE_THREAD)
  if(MSVC)
    message(FATAL_ERROR "MSVC is incompatible with ThreadSanitizer")
  endif()
  set_common_sanitizer_flags()
  list(APPEND SANITIZER_CXX_FLAGS "-fsanitize=thread")
  list(APPEND SANITIZER_LD_FLAGS "-fsanitize=thread")
endif()

option(SANITIZE_UB "Enable UndefinedBehaviorSanitizer runtime checks")
if(SANITIZE_UB)
  if(MSVC)
    message(FATAL_ERROR "MSVC is incompatible with UndefinedBehaviorSanitizer")
  endif()
  set_common_sanitizer_flags()
  list(APPEND SANITIZER_CXX_FLAGS "-fsanitize=undefined")
  set(SANITIZER_LD_FLAGS "-fsanitize=undefined")
  string(CONCAT UBSAN_ENV "UBSAN_OPTIONS="
    "print_stacktrace=1:halt_on_error=1:abort_on_error=1")
  set(SANITIZER_ENV ${UBSAN_ENV})
else()
  set(UBSAN_ENV "")
endif()

option(STATIC_ANALYSIS "Enable compiler static analysis")

set(THREADS_PREFER_PTHREAD_FLAG ON)

find_package(Threads REQUIRED)

find_package(Boost REQUIRED)

string(REPLACE ";" " " CXX_FLAGS_FOR_SUBDIR_STR "${SANITIZER_CXX_FLAGS}")
if(MSVC)
  string(REPLACE ";" " " MSVC_WARNING_FLAGS_FOR_SUBDIR_STR_TMP "${MSVC_CXX_WARNING_FLAGS}")
  string(REPLACE "/Wall" "" MSVC_WARNING_FLAGS_FOR_SUBDIR_STR
    "${MSVC_WARNING_FLAGS_FOR_SUBDIR_STR_TMP}")
endif()
string(REPLACE ";" " " LD_FLAGS_FOR_SUBDIR_STR "${SANITIZER_LD_FLAGS}")

macro(ADD_CXX_FLAGS_FOR_SUBDIR)
  set(ORIG_CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS})
  set(ORIG_CMAKE_EXE_LINKER_FLAGS ${CMAKE_EXE_LINKER_FLAGS})
  set(ORIG_CMAKE_MODULE_LINKER_FLAGS ${CMAKE_MODULE_LINKER_FLAGS})
  set(ORIG_CMAKE_SHARED_LINKER_FLAGS ${CMAKE_SHARED_LINKER_FLAGS})
  string(APPEND CMAKE_CXX_FLAGS " " "${CXX_FLAGS_FOR_SUBDIR_STR}")
  if(MSVC)
    string(APPEND CMAKE_CXX_FLAGS " " "${MSVC_WARNING_FLAGS_FOR_SUBDIR_STR}")
  endif()
  string(APPEND CMAKE_EXE_LINKER_FLAGS "${LD_FLAGS_FOR_SUBDIR_STR}")
  string(APPEND CMAKE_MODULE_LINKER_FLAGS "${LD_FLAGS_FOR_SUBDIR_STR}")
  string(APPEND CMAKE_SHARED_LINKER_FLAGS "${LD_FLAGS_FOR_SUBDIR_STR}")
endmacro()

macro(RESTORE_CXX_FLAGS_FOR_SUBDIR)
  set(CMAKE_CXX_FLAGS ${ORIG_CMAKE_CXX_FLAGS})
  set(CMAKE_EXE_LINKER_FLAGS ${ORIG_CMAKE_EXE_LINKER_FLAGS})
  set(CMAKE_MODULE_LINKER_FLAGS ${ORIG_CMAKE_MODULE_LINKER_FLAGS})
  set(CMAKE_SHARED_LINKER_FLAGS ${ORIG_CMAKE_SHARED_LINKER_FLAGS})
endmacro()

# For Windows: Prevent overriding the parent project's compiler/linker settings
set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)

ADD_CXX_FLAGS_FOR_SUBDIR()
add_subdirectory(3rd_party/googletest)
RESTORE_CXX_FLAGS_FOR_SUBDIR()

set(BENCHMARK_ENABLE_TESTING OFF CACHE BOOL "Suppressing Google Benchmark tests"
  FORCE)
set(BENCHMARK_ENABLE_INSTALL OFF CACHE BOOL
  "Suppressing Google Benchmark installation" FORCE)

if(IPO_SUPPORTED)
  if(CMAKE_BUILD_TYPE STREQUAL "Debug")
    # It seems that Google Benchmark does not support multi-configuration
    # generators if LTO is enabled
    message(STATUS "Disabling LTO for Google Benchmark due to debug build")
  elseif("${CMAKE_CXX_COMPILER_ID}" STREQUAL "AppleClang")
    message(STATUS
      "Disabling LTO for Google Benchmark because Apple clang is not supported")
  else()
    set(BENCHMARK_ENABLE_LTO ON CACHE BOOL "Enabling LTO for Google Benchmark"
      FORCE)
    message(STATUS "Enabling LTO for Google Benchmark")
  endif()
endif()

ADD_CXX_FLAGS_FOR_SUBDIR()
add_subdirectory(3rd_party/benchmark)
RESTORE_CXX_FLAGS_FOR_SUBDIR()

# Do not build DeepState:
# - under Windows as it's not supported
# - on ARM
# - with GCC under macOS due to https://github.com/trailofbits/deepstate/issues/374
if(NOT ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU" AND "${CMAKE_SYSTEM_NAME}"
      STREQUAL "Darwin") AND NOT ("${CMAKE_SYSTEM_NAME}" STREQUAL "Windows")
    AND NOT ("${CMAKE_SYSTEM_PROCESSOR}" STREQUAL "aarch64"))
  # ThreadSanitizer is not compatible with libfuzzer and LLVM 11 linker crashes
  # on libfuzzer release build
  if("${CMAKE_CXX_COMPILER_ID}" STREQUAL "Clang" AND NOT("${CMAKE_BUILD_TYPE}"
        STREQUAL "Release") AND NOT(SANITIZE_THREAD))
    set(LIBFUZZER_AVAILABLE TRUE)
    set(BUILD_DEEPSTATE_LIBFUZZER "-DDEEPSTATE_LIBFUZZER=ON")
  else()
    set(LIBFUZZER_AVAILABLE FALSE)
    set(BUILD_DEEPSTATE_LIBFUZZER "-DDEEPSTATE_LIBFUZZER=OFF")
  endif()

  include(ExternalProject)
  ExternalProject_Add(3rd_party_deepstate
    SOURCE_DIR "${CMAKE_SOURCE_DIR}/3rd_party/deepstate"
    BINARY_DIR "${CMAKE_BINARY_DIR}/3rd_party/deepstate"
    CMAKE_ARGS "-DCMAKE_C_COMPILER=${CMAKE_C_COMPILER}"
    "-DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}" "-DCMAKE_C_FLAGS=-w"
    "-DCMAKE_CXX_FLAGS=-w" "${BUILD_DEEPSTATE_LIBFUZZER}"
    INSTALL_COMMAND "")
  ExternalProject_Get_property(3rd_party_deepstate SOURCE_DIR)
  ExternalProject_Get_property(3rd_party_deepstate BINARY_DIR)

  add_library(deepstate STATIC IMPORTED)
  add_dependencies(deepstate 3rd_party_deepstate)
  target_include_directories(deepstate INTERFACE "${SOURCE_DIR}/src/include/")
  set_target_properties(deepstate PROPERTIES IMPORTED_LOCATION
    "${BINARY_DIR}/${CMAKE_STATIC_LIBRARY_PREFIX}deepstate${CMAKE_STATIC_LIBRARY_SUFFIX}")

  if(LIBFUZZER_AVAILABLE)
    add_library(deepstate_lf STATIC IMPORTED)
    add_dependencies(deepstate_lf 3rd_party_deepstate)
    target_include_directories(deepstate_lf INTERFACE
      "${SOURCE_DIR}/src/include/")
    set_target_properties(deepstate_lf PROPERTIES IMPORTED_LOCATION
      "${BINARY_DIR}/libdeepstate_LF.a")
  endif()
endif()

target_compile_definitions(benchmark PUBLIC
  "$<$<AND:$<CXX_COMPILER_ID:GNU>,$<CONFIG:Debug>>:_GLIBCXX_DEBUG -D_GLIBCXX_DEBUG_PEDANTIC>")

# Add benchmark_include_dirs by target_include_directories(... SYSTEM ...)
# before target_link_libraries so that benchmark headers are included through
# -isystem not -I, resulting in build-breaking diagnostics.
get_target_property(benchmark_include_dirs benchmark::benchmark
  INTERFACE_INCLUDE_DIRECTORIES)

if(NOT "${CMAKE_CXX_COMPILER_ID}" STREQUAL "Clang"
    AND NOT "${CMAKE_CXX_COMPILER_ID}" STREQUAL "AppleClang")
  message(STATUS "Not using clang-tidy due to non-clang compiler being used")
  set(DO_CLANG_TIDY "")
elseif(MSVC)
  message(STATUS "Not using clang-tidy due to broken (?) MSVC support")
else()
  find_program(CLANG_TIDY_EXE NAMES "clang-tidy"
    DOC "Path to clang-tidy executable")
  if(NOT CLANG_TIDY_EXE)
    message(STATUS "clang-tidy not found")
    set(DO_CLANG_TIDY "")
  else()
    message(STATUS "clang-tidy found: ${CLANG_TIDY_EXE}")
    set(DO_CLANG_TIDY "${CLANG_TIDY_EXE}" "-p=${CMAKE_BINARY_DIR}")
  endif()
endif()

set(CPPCHECK_ARGS
  # False positive on Google Test TEST macro and compilers are much better
  # for syntax checking anyway
  "--suppress=syntaxError"
  # False positives on structured bindings with 2.5
  "--suppress=unassignedVariable"
  "--suppress=unusedVariable")

option(CPPCHECK_AGGRESSIVE "Enable inconclusive cppcheck checks")
if(CPPCHECK_AGGRESSIVE)
  list(APPEND CPPCHECK_ARGS "--inconclusive")
endif()
if(FATAL_WARNINGS)
  list(APPEND CPPCHECK_ARGS "--error-exitcode=2")
else()
  list(APPEND CPPCHECK_ARGS "--error-exitcode=0")
endif()

find_program(CPPCHECK_EXE NAMES "cppcheck" DOC "Path to cppcheck executable")
if(NOT CPPCHECK_EXE)
  message(STATUS "cppcheck not found")
else()
  execute_process(COMMAND "${CPPCHECK_EXE}" "--version" OUTPUT_VARIABLE
    CPPCHECK_VERSION_OUTPUT)
  message(STATUS
    "cppcheck found: ${CPPCHECK_EXE}, --version: ${CPPCHECK_VERSION_OUTPUT}")
  set(DO_CPPCHECK "${CPPCHECK_EXE}"
    "--enable=warning,style,performance,portability" "-D__x86_64" "-D__GLIBCXX__"
    "--inline-suppr")
  list(APPEND DO_CPPCHECK "${CPPCHECK_ARGS}")
endif()

find_program(CPPLINT_EXE NAMES "cpplint" DOC "Path to cpplint executable")
if(NOT CPPLINT_EXE)
  message(STATUS "cpplint not found")
else()
  message(STATUS "cpplint found: ${CPPLINT_EXE}")
endif()

option(IWYU "Enable include-what-you-use checking")
if(IWYU)
  if(NOT "${CMAKE_CXX_COMPILER_ID}" STREQUAL "Clang"
      AND NOT "${CMAKE_CXX_COMPILER_ID}" STREQUAL "AppleClang")
    message(STATUS "Not using include-what-you-use due to non-clang compiler being used")
  else()
    find_program(IWYU_EXE NAMES "include-what-you-use"
      DOC "Path to include-what-you-use executable")
    if(NOT IWYU_EXE)
      message(STATUS "include-what-you-use not found")
    else()
      execute_process(COMMAND "${IWYU_EXE}" "--version" OUTPUT_VARIABLE
        IWYU_VERSION_OUTPUT)
      message(STATUS
        "include-what-you-use found: ${IWYU_EXE}, --version: ${IWYU_VERSION_OUTPUT}")
      set(DO_IWYU "${IWYU_EXE}")
    endif()
  endif()
endif()

set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
set(GSL_INCLUDES "3rd_party/GSL/include")

function(COMMON_TARGET_PROPERTIES TARGET)
  cmake_parse_arguments(PARSE_ARGV 1 CTP "SKIP_CHECKS" "" "")
  target_compile_definitions(${TARGET} PRIVATE
    "$<$<AND:$<CONFIG:Debug>,$<BOOL:${VALGRIND_CLIENT}>>:VALGRIND_CLIENT_REQUESTS>")
  target_compile_options(${TARGET} PRIVATE
    "$<$<CXX_COMPILER_ID:MSVC>:${MSVC_CXX_FLAGS}>"
    # Many conditions below are incorrect due to clang-cl having clang compiler
    # ID but taking MSVC flags. Change to CMAKE_CXX_COMPILER_FRONTEND_VARIANT
    # on 3.14.
    "$<$<OR:$<CXX_COMPILER_ID:MSVC>,$<AND:$<PLATFORM_ID:Windows>,$<CXX_COMPILER_ID:Clang>>>:${MSVC_CLANG_CXX_FLAGS}>"
    "$<$<AND:$<OR:$<CXX_COMPILER_ID:MSVC>,$<AND:$<PLATFORM_ID:Windows>,$<CXX_COMPILER_ID:Clang>>>,$<STREQUAL:${CMAKE_SYSTEM_PROCESSOR},x86_64>>:$<IF:$<BOOL:${AVX2}>,/arch:AVX2,/arch:AVX>>"
    "$<$<NOT:$<PLATFORM_ID:Windows>>:${UNIX_CXX_FLAGS}>"
    "$<$<AND:$<NOT:$<PLATFORM_ID:Windows>>,$<STREQUAL:${CMAKE_SYSTEM_PROCESSOR},x86_64>>:$<IF:$<BOOL:${AVX2}>,-mavx2,-msse4.1 -mcx16>>"
    "$<$<BOOL:${FATAL_WARNINGS}>:$<IF:$<OR:$<CXX_COMPILER_ID:MSVC>,$<AND:$<PLATFORM_ID:Windows>,$<CXX_COMPILER_ID:Clang>>>,/WX,-Werror>>"
    "$<$<OR:$<CXX_COMPILER_ID:MSVC>,$<AND:$<PLATFORM_ID:Windows>,$<CXX_COMPILER_ID:Clang>>>:${MSVC_CXX_WARNING_FLAGS}>"
    "$<$<AND:$<PLATFORM_ID:Windows>,$<CXX_COMPILER_ID:Clang>>:${MSVC_CLANGS_ONLY_WARNING_FLAGS}>"
    "$<$<AND:$<CXX_COMPILER_ID:AppleClang,Clang>,$<NOT:$<PLATFORM_ID:Windows>>>:${CLANG_CXX_WARNING_FLAGS}>"
    "$<$<AND:$<CXX_COMPILER_ID:Clang>,$<VERSION_LESS:$<CXX_COMPILER_VERSION>,13.0>,$<NOT:$<PLATFORM_ID:Windows>>>:${CLANG_LT_13_CXX_WARNING_FLAGS}>"
    "$<$<AND:$<CXX_COMPILER_ID:Clang>,$<VERSION_GREATER_EQUAL:$<CXX_COMPILER_VERSION>,13.0>,$<NOT:$<PLATFORM_ID:Windows>>>:${CLANG_GE_13_CXX_WARNING_FLAGS}>"
    "$<$<CXX_COMPILER_ID:GNU>:${GCC_CXX_WARNING_FLAGS}>"
    "$<$<AND:$<CXX_COMPILER_ID:GNU>,$<VERSION_GREATER_EQUAL:$<CXX_COMPILER_VERSION>,11.0>>:${GCC_GE_11_CXX_WARNING_FLAGS}>"
    "$<$<CONFIG:Debug>:$<IF:$<PLATFORM_ID:Windows>,/Od,-O0>>"
    "$<$<AND:$<CONFIG:Release>,$<NOT:$<PLATFORM_ID:Windows>>>:$<IF:$<BOOL:${COVERAGE}>,-O0,-O3>>"
    "$<$<BOOL:${COVERAGE}>:--coverage>")
  target_compile_options(${TARGET} PRIVATE "${CXX_FLAGS}")
  target_compile_options(${TARGET} PRIVATE "${SANITIZER_CXX_FLAGS}")
  target_compile_features(${TARGET} PUBLIC cxx_std_17)
  set_target_properties(${TARGET} PROPERTIES CXX_EXTENSIONS OFF)
  # Change to target_link_options on 3.13 minimum CMake version
  target_link_libraries(${TARGET} PRIVATE "${SANITIZER_LD_FLAGS}")
  target_link_libraries(${TARGET} INTERFACE "$<$<BOOL:${COVERAGE}>:--coverage>")
  target_link_libraries(${TARGET} PRIVATE "$<$<PLATFORM_ID:Linux>:${CMAKE_DL_LIBS}>")
  target_link_libraries(${TARGET} PRIVATE
    "$<$<AND:$<PLATFORM_ID:Linux>,$<CXX_COMPILER_ID:GNU>>:backtrace>")
  if(IPO_SUPPORTED)
    set_target_properties(${TARGET} PROPERTIES
      INTERPROCEDURAL_OPTIMIZATION_RELEASE TRUE)
  endif()
  if(NOT CTP_SKIP_CHECKS)
    if(CPPCHECK_EXE)
      set_target_properties(${TARGET} PROPERTIES CXX_CPPCHECK "${DO_CPPCHECK}")
    endif()
    if(CPPLINT_EXE)
      set_target_properties(${TARGET} PROPERTIES CXX_CPPLINT "${CPPLINT_EXE}")
    endif()
    if(IWYU_EXE)
      set_target_properties(${TARGET} PROPERTIES CXX_INCLUDE_WHAT_YOU_USE "${DO_IWYU}")
    endif()
    if(STATIC_ANALYSIS)
      # The condition below is incorrect due to clang-cl having clang compiler
      # ID but taking MSVC flags. Change to CMAKE_CXX_COMPILER_FRONTEND_VARIANT
      # on 3.14.
      target_compile_options(${TARGET} PRIVATE "$<IF:$<CXX_COMPILER_ID:MSVC>,${MSVC_STATIC_ANALYSIS_FLAGS},-fanalyzer>")
      # GCC 11 -fanalyzer not fully ready for C++ yet
      target_compile_options(${TARGET} PRIVATE
        "$<$<AND:$<CXX_COMPILER_ID:GNU>,$<VERSION_GREATER_EQUAL:$<CXX_COMPILER_VERSION>,11.0>>:-Wno-analyzer-possible-null-dereference>")
      target_compile_options(${TARGET} PRIVATE
        "$<$<AND:$<CXX_COMPILER_ID:GNU>,$<VERSION_GREATER_EQUAL:$<CXX_COMPILER_VERSION>,11.0>>:-Wno-analyzer-possible-null-argument>")
    endif()
  endif()
endfunction()

function(SET_CLANG_TIDY_OPTIONS TARGET COMMAND)
  if(DO_CLANG_TIDY)
    set_target_properties(${TARGET} PROPERTIES CXX_CLANG_TIDY "${COMMAND}")
  endif()
endfunction()

function(ADD_UNODB_LIBRARY LIB)
  add_library(${LIB} ${ARGN})
  common_target_properties(${LIB})
  target_include_directories(${LIB} SYSTEM PUBLIC "${GSL_INCLUDES}")
  set_clang_tidy_options(${LIB} "${DO_CLANG_TIDY}")

  if(LIBFUZZER_AVAILABLE)
    set(LIB_LF "${LIB}_lf")
    add_library(${LIB_LF} ${ARGN})
    common_target_properties(${LIB_LF} SKIP_CHECKS)
    target_include_directories(${LIB_LF} SYSTEM PUBLIC "${GSL_INCLUDES}")
    target_compile_options(${LIB_LF} PRIVATE "-fsanitize=fuzzer-no-link")
  endif()
endfunction()

add_unodb_library(unodb_util global.hpp assert.hpp portability_builtins.hpp
  thread_sync.hpp heap.hpp heap.cpp portability_arch.hpp)
target_include_directories(unodb_util INTERFACE ".")
target_include_directories(unodb_util SYSTEM PUBLIC "${Boost_INCLUDE_DIRS}")
target_link_libraries(unodb_util PRIVATE "${Boost_LIBRARIES}")
if(LIBFUZZER_AVAILABLE)
  target_include_directories(unodb_util_lf INTERFACE ".")
  target_include_directories(unodb_util_lf SYSTEM PUBLIC "${Boost_INCLUDE_DIRS}")
  target_link_libraries(unodb_util_lf PRIVATE "${Boost_LIBRARIES}")
endif()

add_unodb_library(unodb_qsbr qsbr.cpp qsbr.hpp qsbr_ptr.cpp qsbr_ptr.hpp)
target_include_directories(unodb_qsbr SYSTEM PUBLIC "${Boost_INCLUDE_DIRS}")
target_link_libraries(unodb_qsbr PRIVATE "${Boost_LIBRARIES}")
target_link_libraries(unodb_qsbr PUBLIC unodb_util Threads::Threads)
if(LIBFUZZER_AVAILABLE)
  target_include_directories(unodb_qsbr_lf SYSTEM PUBLIC "${Boost_INCLUDE_DIRS}")
  target_link_libraries(unodb_qsbr_lf PRIVATE "${Boost_LIBRARIES}")
  target_link_libraries(unodb_qsbr_lf PUBLIC unodb_util_lf Threads::Threads)
endif()

add_unodb_library(unodb art.cpp art.hpp art_common.cpp art_common.hpp
  mutex_art.hpp optimistic_lock.hpp art_internal_impl.hpp olc_art.hpp
  olc_art.cpp art_internal.cpp art_internal.hpp node_type.hpp)
target_link_libraries(unodb PUBLIC unodb_util unodb_qsbr)
if(LIBFUZZER_AVAILABLE)
  target_link_libraries(unodb_lf PUBLIC unodb_util_lf unodb_qsbr_lf)
endif()

set(VALGRIND_COMMAND "valgrind" "--error-exitcode=1" "--leak-check=full"
  "--trace-children=yes" "-v")

add_custom_target(valgrind DEPENDS valgrind_tests valgrind_benchmarks)

enable_testing()

add_subdirectory(benchmark)
if(TARGET deepstate)
  add_subdirectory(fuzz_deepstate)
  add_dependencies(valgrind valgrind_deepstate)
endif()
add_subdirectory(test)

set(BIN_DIR_CDB "${CMAKE_BINARY_DIR}/compile_commands.json")
set(SRC_DIR_CDB "${CMAKE_SOURCE_DIR}/compile_commands.json")

# cmake -E create_symlink has Windows implementation, but additional permissions
# are required.
if(NOT CMAKE_HOST_SYSTEM_NAME STREQUAL "Windows")
  execute_process(COMMAND ${CMAKE_COMMAND} -E create_symlink
    ${BIN_DIR_CDB} ${SRC_DIR_CDB})
endif()
