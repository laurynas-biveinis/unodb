<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UnoDB: unodb::db&lt; Key, Value &gt;::iterator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">UnoDB
   </div>
   <div id="projectbrief">Adaptive Radix Tree in C++, optionally with Optimistic Lock Coupling</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classunodb_1_1db_1_1iterator.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classunodb_1_1db_1_1iterator-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">unodb::db&lt; Key, Value &gt;::iterator Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>iterator (the iterator is an internal API, the public API is <a class="el" href="classunodb_1_1db.html#a27a69c736ca0405bc8eaed20cf875a09" title="Scan the tree, applying the caller&#39;s lambda to each visited leaf.">scan()</a>).  
 <a href="classunodb_1_1db_1_1iterator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="art_8hpp_source.html">art.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa528130c72932f5e1cb4f3b442d202da" id="r_aa528130c72932f5e1cb4f3b442d202da"><td class="memItemLeft" align="right" valign="top"><a id="aa528130c72932f5e1cb4f3b442d202da" name="aa528130c72932f5e1cb4f3b442d202da"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b> = Key</td></tr>
<tr class="separator:aa528130c72932f5e1cb4f3b442d202da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4839e9e424e83bb670e2bef82c71255a" id="r_a4839e9e424e83bb670e2bef82c71255a"><td class="memItemLeft" align="right" valign="top"><a id="a4839e9e424e83bb670e2bef82c71255a" name="a4839e9e424e83bb670e2bef82c71255a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = Value</td></tr>
<tr class="separator:a4839e9e424e83bb670e2bef82c71255a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae7140da77bdaddcb5412a67ac4dbb28d" id="r_ae7140da77bdaddcb5412a67ac4dbb28d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunodb_1_1db_1_1iterator.html">iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1db_1_1iterator.html#ae7140da77bdaddcb5412a67ac4dbb28d">first</a> ()</td></tr>
<tr class="memdesc:ae7140da77bdaddcb5412a67ac4dbb28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position the iterator on the first entry in the index.  <br /></td></tr>
<tr class="separator:ae7140da77bdaddcb5412a67ac4dbb28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d2feb5a3634d7b28153017adb46eb0" id="r_af7d2feb5a3634d7b28153017adb46eb0"><td class="memItemLeft" align="right" valign="top"><a id="af7d2feb5a3634d7b28153017adb46eb0" name="af7d2feb5a3634d7b28153017adb46eb0"></a>
<a class="el" href="classunodb_1_1db_1_1iterator.html">iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>next</b> ()</td></tr>
<tr class="memdesc:af7d2feb5a3634d7b28153017adb46eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the iterator to next entry in the index. <br /></td></tr>
<tr class="separator:af7d2feb5a3634d7b28153017adb46eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c3f611163534ea29ca3fb3958c97e3" id="r_a73c3f611163534ea29ca3fb3958c97e3"><td class="memItemLeft" align="right" valign="top"><a id="a73c3f611163534ea29ca3fb3958c97e3" name="a73c3f611163534ea29ca3fb3958c97e3"></a>
<a class="el" href="classunodb_1_1db_1_1iterator.html">iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>last</b> ()</td></tr>
<tr class="memdesc:a73c3f611163534ea29ca3fb3958c97e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position the iterator on the last entry in the index, which can be used to initiate a reverse traversal. <br /></td></tr>
<tr class="separator:a73c3f611163534ea29ca3fb3958c97e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7185f8a53c2a16d45bf4ddd7ca18e668" id="r_a7185f8a53c2a16d45bf4ddd7ca18e668"><td class="memItemLeft" align="right" valign="top"><a id="a7185f8a53c2a16d45bf4ddd7ca18e668" name="a7185f8a53c2a16d45bf4ddd7ca18e668"></a>
<a class="el" href="classunodb_1_1db_1_1iterator.html">iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>prior</b> ()</td></tr>
<tr class="memdesc:a7185f8a53c2a16d45bf4ddd7ca18e668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position the iterator on the previous entry in the index. <br /></td></tr>
<tr class="separator:a7185f8a53c2a16d45bf4ddd7ca18e668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e51dd50dad8e7c8657f59dfa275ea38" id="r_a9e51dd50dad8e7c8657f59dfa275ea38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunodb_1_1db_1_1iterator.html">iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1db_1_1iterator.html#a9e51dd50dad8e7c8657f59dfa275ea38">seek</a> (<a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">art_key_type</a> search_key, bool &amp;match, bool fwd=true)</td></tr>
<tr class="memdesc:a9e51dd50dad8e7c8657f59dfa275ea38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position the iterator on, before, or after the caller's key.  <br /></td></tr>
<tr class="separator:a9e51dd50dad8e7c8657f59dfa275ea38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad681e296075884e877d1b12b4ff773d5" id="r_ad681e296075884e877d1b12b4ff773d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">key_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1db_1_1iterator.html#ad681e296075884e877d1b12b4ff773d5">get_key</a> ()</td></tr>
<tr class="memdesc:ad681e296075884e877d1b12b4ff773d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the key_view associated with the current position of the iterator.  <br /></td></tr>
<tr class="separator:ad681e296075884e877d1b12b4ff773d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6068facd1a62c646d5cefa3b22c134a" id="r_ab6068facd1a62c646d5cefa3b22c134a"><td class="memItemLeft" align="right" valign="top">const value_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1db_1_1iterator.html#ab6068facd1a62c646d5cefa3b22c134a">get_val</a> () const</td></tr>
<tr class="memdesc:ab6068facd1a62c646d5cefa3b22c134a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value_view associated with the current position of the iterator.  <br /></td></tr>
<tr class="separator:ab6068facd1a62c646d5cefa3b22c134a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd3e85bcd9052fc406b0632e4b46fea" id="r_adcd3e85bcd9052fc406b0632e4b46fea"><td class="memItemLeft" align="right" valign="top"><a id="adcd3e85bcd9052fc406b0632e4b46fea" name="adcd3e85bcd9052fc406b0632e4b46fea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump</b> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:adcd3e85bcd9052fc406b0632e4b46fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging. <br /></td></tr>
<tr class="separator:adcd3e85bcd9052fc406b0632e4b46fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a6776f254ab54fc4ef405abd1eadf9" id="r_aa6a6776f254ab54fc4ef405abd1eadf9"><td class="memItemLeft" align="right" valign="top"><a id="aa6a6776f254ab54fc4ef405abd1eadf9" name="aa6a6776f254ab54fc4ef405abd1eadf9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump</b> () const</td></tr>
<tr class="memdesc:aa6a6776f254ab54fc4ef405abd1eadf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging. <br /></td></tr>
<tr class="separator:aa6a6776f254ab54fc4ef405abd1eadf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876da7b357eb5fd35372db9089a3ec20" id="r_a876da7b357eb5fd35372db9089a3ec20"><td class="memItemLeft" align="right" valign="top"><a id="a876da7b357eb5fd35372db9089a3ec20" name="a876da7b357eb5fd35372db9089a3ec20"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>valid</b> () const</td></tr>
<tr class="memdesc:a876da7b357eb5fd35372db9089a3ec20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true unless the stack is empty (exposed to tests). <br /></td></tr>
<tr class="separator:a876da7b357eb5fd35372db9089a3ec20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a698f87a59c0d26514fe953c27145f0fb" id="r_a698f87a59c0d26514fe953c27145f0fb"><td class="memItemLeft" align="right" valign="top"><a id="a698f87a59c0d26514fe953c27145f0fb" name="a698f87a59c0d26514fe953c27145f0fb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> (<a class="el" href="classunodb_1_1db.html">db</a> &amp;tree)</td></tr>
<tr class="memdesc:a698f87a59c0d26514fe953c27145f0fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty iterator (one that is logically not positioned on anything and which will report !valid()). <br /></td></tr>
<tr class="separator:a698f87a59c0d26514fe953c27145f0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8a7300df10e9957750ed2bfe029ef0" id="r_a3b8a7300df10e9957750ed2bfe029ef0"><td class="memItemLeft" align="right" valign="top"><a id="a3b8a7300df10e9957750ed2bfe029ef0" name="a3b8a7300df10e9957750ed2bfe029ef0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> (const <a class="el" href="classunodb_1_1db_1_1iterator.html">iterator</a> &amp;)=delete</td></tr>
<tr class="separator:a3b8a7300df10e9957750ed2bfe029ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183fbec499bd2aee9b4f67275fcf4099" id="r_a183fbec499bd2aee9b4f67275fcf4099"><td class="memItemLeft" align="right" valign="top"><a id="a183fbec499bd2aee9b4f67275fcf4099" name="a183fbec499bd2aee9b4f67275fcf4099"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> (<a class="el" href="classunodb_1_1db_1_1iterator.html">iterator</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a183fbec499bd2aee9b4f67275fcf4099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf21f0d5aec971ad0e186e95b05471e" id="r_afdf21f0d5aec971ad0e186e95b05471e"><td class="memItemLeft" align="right" valign="top"><a id="afdf21f0d5aec971ad0e186e95b05471e" name="afdf21f0d5aec971ad0e186e95b05471e"></a>
<a class="el" href="classunodb_1_1db_1_1iterator.html">iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classunodb_1_1db_1_1iterator.html">iterator</a> &amp;)=delete</td></tr>
<tr class="separator:afdf21f0d5aec971ad0e186e95b05471e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab321c79625f90d6363aaaa752bf92add" id="r_ab321c79625f90d6363aaaa752bf92add"><td class="memItemLeft" align="right" valign="top"><a id="ab321c79625f90d6363aaaa752bf92add" name="ab321c79625f90d6363aaaa752bf92add"></a>
<a class="el" href="classunodb_1_1db_1_1iterator.html">iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>left_most_traversal</b> (<a class="el" href="classunodb_1_1detail_1_1basic__node__ptr.html">detail::node_ptr</a> node)</td></tr>
<tr class="memdesc:ab321c79625f90d6363aaaa752bf92add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push the given node onto the stack and traverse from the caller's node to the left-most leaf under that node, pushing nodes onto the stack as they are visited. <br /></td></tr>
<tr class="separator:ab321c79625f90d6363aaaa752bf92add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89770f43fc20103dc5458fa4d9cbc39" id="r_ad89770f43fc20103dc5458fa4d9cbc39"><td class="memItemLeft" align="right" valign="top"><a id="ad89770f43fc20103dc5458fa4d9cbc39" name="ad89770f43fc20103dc5458fa4d9cbc39"></a>
<a class="el" href="classunodb_1_1db_1_1iterator.html">iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>right_most_traversal</b> (<a class="el" href="classunodb_1_1detail_1_1basic__node__ptr.html">detail::node_ptr</a> node)</td></tr>
<tr class="memdesc:ad89770f43fc20103dc5458fa4d9cbc39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Descend from the current state of the stack to the right most child leaf, updating the state of the iterator during the descent. <br /></td></tr>
<tr class="separator:ad89770f43fc20103dc5458fa4d9cbc39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903454fbe79c72dc31186ac516c63517" id="r_a903454fbe79c72dc31186ac516c63517"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1db_1_1iterator.html#a903454fbe79c72dc31186ac516c63517">cmp</a> (<a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">art_key_type</a> akey) const</td></tr>
<tr class="memdesc:a903454fbe79c72dc31186ac516c63517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the given key (e.g., the to_key) to the current key in the internal buffer.  <br /></td></tr>
<tr class="separator:a903454fbe79c72dc31186ac516c63517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefd2f96310b9a3a274a8df9fe70dbd6" id="r_adefd2f96310b9a3a274a8df9fe70dbd6"><td class="memItemLeft" align="right" valign="top"><a id="adefd2f96310b9a3a274a8df9fe70dbd6" name="adefd2f96310b9a3a274a8df9fe70dbd6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const</td></tr>
<tr class="memdesc:adefd2f96310b9a3a274a8df9fe70dbd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true iff the stack is empty. <br /></td></tr>
<tr class="separator:adefd2f96310b9a3a274a8df9fe70dbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25149b069bf9338b8d04117fa8f9d0cd" id="r_a25149b069bf9338b8d04117fa8f9d0cd"><td class="memItemLeft" align="right" valign="top"><a id="a25149b069bf9338b8d04117fa8f9d0cd" name="a25149b069bf9338b8d04117fa8f9d0cd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push</b> (<a class="el" href="classunodb_1_1detail_1_1basic__node__ptr.html">detail::node_ptr</a> node, std::byte key_byte, std::uint8_t child_index, <a class="el" href="unionunodb_1_1detail_1_1key__prefix__snapshot.html">detail::key_prefix_snapshot</a> prefix)</td></tr>
<tr class="memdesc:a25149b069bf9338b8d04117fa8f9d0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a non-leaf entry onto the stack. <br /></td></tr>
<tr class="separator:a25149b069bf9338b8d04117fa8f9d0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1199f5eb7bca7ebd78dbcea6a32596a8" id="r_a1199f5eb7bca7ebd78dbcea6a32596a8"><td class="memItemLeft" align="right" valign="top"><a id="a1199f5eb7bca7ebd78dbcea6a32596a8" name="a1199f5eb7bca7ebd78dbcea6a32596a8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_leaf</b> (<a class="el" href="classunodb_1_1detail_1_1basic__node__ptr.html">detail::node_ptr</a> aleaf)</td></tr>
<tr class="memdesc:a1199f5eb7bca7ebd78dbcea6a32596a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a leaf onto the stack. <br /></td></tr>
<tr class="separator:a1199f5eb7bca7ebd78dbcea6a32596a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a782379325463af95a227e5f58cfea" id="r_a52a782379325463af95a227e5f58cfea"><td class="memItemLeft" align="right" valign="top"><a id="a52a782379325463af95a227e5f58cfea" name="a52a782379325463af95a227e5f58cfea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push</b> (const typename <a class="el" href="structunodb_1_1detail_1_1iter__result.html">inode_base::iter_result</a> &amp;e)</td></tr>
<tr class="memdesc:a52a782379325463af95a227e5f58cfea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push an entry onto the stack. <br /></td></tr>
<tr class="separator:a52a782379325463af95a227e5f58cfea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301bcacc7e5dae049aeac2bffead3b7b" id="r_a301bcacc7e5dae049aeac2bffead3b7b"><td class="memItemLeft" align="right" valign="top"><a id="a301bcacc7e5dae049aeac2bffead3b7b" name="a301bcacc7e5dae049aeac2bffead3b7b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pop</b> ()</td></tr>
<tr class="memdesc:a301bcacc7e5dae049aeac2bffead3b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an entry from the stack and truncate the key buffer. <br /></td></tr>
<tr class="separator:a301bcacc7e5dae049aeac2bffead3b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7479b7fc30823ec548c991c21de25d25" id="r_a7479b7fc30823ec548c991c21de25d25"><td class="memItemLeft" align="right" valign="top"><a id="a7479b7fc30823ec548c991c21de25d25" name="a7479b7fc30823ec548c991c21de25d25"></a>
<a class="el" href="classunodb_1_1db_1_1iterator.html#a9166f2a1d9fcc47bc1c9f09da8806919">stack_entry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>top</b> ()</td></tr>
<tr class="memdesc:a7479b7fc30823ec548c991c21de25d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the entry (if any) on the top of the stack. <br /></td></tr>
<tr class="separator:a7479b7fc30823ec548c991c21de25d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d761d932c9fb7c82d52de8c8b575c8a" id="r_a2d761d932c9fb7c82d52de8c8b575c8a"><td class="memItemLeft" align="right" valign="top"><a id="a2d761d932c9fb7c82d52de8c8b575c8a" name="a2d761d932c9fb7c82d52de8c8b575c8a"></a>
<a class="el" href="classunodb_1_1detail_1_1basic__node__ptr.html">detail::node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>current_node</b> ()</td></tr>
<tr class="memdesc:a2d761d932c9fb7c82d52de8c8b575c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the node on the top of the stack and nullptr if the stack is empty (similar to <a class="el" href="classunodb_1_1db_1_1iterator.html#a7479b7fc30823ec548c991c21de25d25" title="Return the entry (if any) on the top of the stack.">top()</a>, but handles an empty stack). <br /></td></tr>
<tr class="separator:a2d761d932c9fb7c82d52de8c8b575c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a9166f2a1d9fcc47bc1c9f09da8806919" id="r_a9166f2a1d9fcc47bc1c9f09da8806919"><td class="memItemLeft" align="right" valign="top"><a id="a9166f2a1d9fcc47bc1c9f09da8806919" name="a9166f2a1d9fcc47bc1c9f09da8806919"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>stack_entry</b> = typename <a class="el" href="structunodb_1_1detail_1_1iter__result.html">inode_base::iter_result</a></td></tr>
<tr class="memdesc:a9166f2a1d9fcc47bc1c9f09da8806919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias used for the elements of the stack. <br /></td></tr>
<tr class="separator:a9166f2a1d9fcc47bc1c9f09da8806919"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a4601f7006d444f173f3f615d228b0605" id="r_a4601f7006d444f173f3f615d228b0605"><td class="memItemLeft" align="right" valign="top"><a id="a4601f7006d444f173f3f615d228b0605" name="a4601f7006d444f173f3f615d228b0605"></a>
<a class="el" href="classunodb_1_1db_1_1iterator.html">iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>invalidate</b> ()</td></tr>
<tr class="memdesc:a4601f7006d444f173f3f615d228b0605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate the iterator (pops everything off of the stack). <br /></td></tr>
<tr class="separator:a4601f7006d444f173f3f615d228b0605"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aa094c5e39d773de49bd5466645c7f50a" id="r_aa094c5e39d773de49bd5466645c7f50a"><td class="memItemLeft" align="right" valign="top"><a id="aa094c5e39d773de49bd5466645c7f50a" name="aa094c5e39d773de49bd5466645c7f50a"></a>
<a class="el" href="classunodb_1_1db.html">db</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>db_</b></td></tr>
<tr class="memdesc:aa094c5e39d773de49bd5466645c7f50a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The outer db instance. <br /></td></tr>
<tr class="separator:aa094c5e39d773de49bd5466645c7f50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6653e19363aa0aaa8747510bfd1c6e30" id="r_a6653e19363aa0aaa8747510bfd1c6e30"><td class="memItemLeft" align="right" valign="top">std::stack&lt; <a class="el" href="classunodb_1_1db_1_1iterator.html#a9166f2a1d9fcc47bc1c9f09da8806919">stack_entry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1db_1_1iterator.html#a6653e19363aa0aaa8747510bfd1c6e30">stack_</a> {}</td></tr>
<tr class="memdesc:a6653e19363aa0aaa8747510bfd1c6e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stack reflecting the parent path from the root of the tree to the current leaf.  <br /></td></tr>
<tr class="separator:a6653e19363aa0aaa8747510bfd1c6e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6396d761c7e6abb971fe1508bb4e3e38" id="r_a6396d761c7e6abb971fe1508bb4e3e38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunodb_1_1detail_1_1key__buffer.html">detail::key_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1db_1_1iterator.html#a6396d761c7e6abb971fe1508bb4e3e38">keybuf_</a> {}</td></tr>
<tr class="memdesc:a6396d761c7e6abb971fe1508bb4e3e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">A buffer into which visited encoded (binary comparable) keys are materialized by during the iterator traversal.  <br /></td></tr>
<tr class="separator:a6396d761c7e6abb971fe1508bb4e3e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:afaa85f6d069fcff5be399f829fe8f1d5" id="r_afaa85f6d069fcff5be399f829fe8f1d5"><td class="memItemLeft" align="right" valign="top"><a id="afaa85f6d069fcff5be399f829fe8f1d5" name="afaa85f6d069fcff5be399f829fe8f1d5"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>db</b></td></tr>
<tr class="separator:afaa85f6d069fcff5be399f829fe8f1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69425d2551186ea0330b08fc394bd0f9" id="r_a69425d2551186ea0330b08fc394bd0f9"><td class="memTemplParams" colspan="2"><a id="a69425d2551186ea0330b08fc394bd0f9" name="a69425d2551186ea0330b08fc394bd0f9"></a>
template&lt;class &gt; </td></tr>
<tr class="memitem:a69425d2551186ea0330b08fc394bd0f9"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>visitor</b></td></tr>
<tr class="separator:a69425d2551186ea0330b08fc394bd0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Key, typename Value&gt;<br />
class unodb::db&lt; Key, Value &gt;::iterator</div><p>iterator (the iterator is an internal API, the public API is <a class="el" href="classunodb_1_1db.html#a27a69c736ca0405bc8eaed20cf875a09" title="Scan the tree, applying the caller&#39;s lambda to each visited leaf.">scan()</a>). </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a903454fbe79c72dc31186ac516c63517" name="a903454fbe79c72dc31186ac516c63517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903454fbe79c72dc31186ac516c63517">&#9670;&#160;</a></span>cmp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::iterator::cmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">art_key_type</a>&#160;</td>
          <td class="paramname"><em>akey</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the given key (e.g., the to_key) to the current key in the internal buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>-1, 0, or 1 if this key is LT, EQ, or GT the other key. </dd></dl>

</div>
</div>
<a id="ae7140da77bdaddcb5412a67ac4dbb28d" name="ae7140da77bdaddcb5412a67ac4dbb28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7140da77bdaddcb5412a67ac4dbb28d">&#9670;&#160;</a></span>first()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunodb_1_1db.html">db</a>&lt; Key, Value &gt;<a class="el" href="classunodb_1_1db_1_1iterator.html#a698f87a59c0d26514fe953c27145f0fb">::iterator</a> &amp; <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::iterator::first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position the iterator on the first entry in the index. </p>
<p>ART Iterator Implementation. </p>

</div>
</div>
<a id="ad681e296075884e877d1b12b4ff773d5" name="ad681e296075884e877d1b12b4ff773d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad681e296075884e877d1b12b4ff773d5">&#9670;&#160;</a></span>get_key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">key_view</a> <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::iterator::get_key </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the key_view associated with the current position of the iterator. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The iterator MUST be <a class="el" href="classunodb_1_1db_1_1iterator.html#a876da7b357eb5fd35372db9089a3ec20" title="Return true unless the stack is empty (exposed to tests).">valid()</a>. </dd></dl>

</div>
</div>
<a id="ab6068facd1a62c646d5cefa3b22c134a" name="ab6068facd1a62c646d5cefa3b22c134a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6068facd1a62c646d5cefa3b22c134a">&#9670;&#160;</a></span>get_val()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const value_view <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::iterator::get_val </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value_view associated with the current position of the iterator. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The iterator MUST be <a class="el" href="classunodb_1_1db_1_1iterator.html#a876da7b357eb5fd35372db9089a3ec20" title="Return true unless the stack is empty (exposed to tests).">valid()</a>. </dd></dl>

</div>
</div>
<a id="a9e51dd50dad8e7c8657f59dfa275ea38" name="a9e51dd50dad8e7c8657f59dfa275ea38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e51dd50dad8e7c8657f59dfa275ea38">&#9670;&#160;</a></span>seek()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunodb_1_1db.html">db</a>&lt; Key, Value &gt;<a class="el" href="classunodb_1_1db_1_1iterator.html#a698f87a59c0d26514fe953c27145f0fb">::iterator</a> &amp; <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::iterator::seek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">art_key_type</a>&#160;</td>
          <td class="paramname"><em>search_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position the iterator on, before, or after the caller's key. </p>
<p>If the iterator can not be positioned, it will be invalidated. For example, if <code>fwd:=true</code> and the <em>search_key</em> is GT any key in the index then the iterator will be invalidated since there is no index entry greater than the search key. Likewise, if <code>fwd:=false</code> and the <em>search_key</em> is LT any key in the index, then the iterator will be invalidated since there is no index entry LT the <em>search_key</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">search_key</td><td>The internal key used to position the iterator.</td></tr>
    <tr><td class="paramname">match</td><td>Will be set to true iff the search key is an exact match in the index data. Otherwise, the match is not exact and the iterator is positioned either before or after the search_key.</td></tr>
    <tr><td class="paramname">fwd</td><td>When true, the iterator will be positioned first entry which orders GTE the search_key and invalidated if there is no such entry. Otherwise, the iterator will be positioned on the last key which orders LTE the search_key and invalidated if there is no such entry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6396d761c7e6abb971fe1508bb4e3e38" name="a6396d761c7e6abb971fe1508bb4e3e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6396d761c7e6abb971fe1508bb4e3e38">&#9670;&#160;</a></span>keybuf_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunodb_1_1detail_1_1key__buffer.html">detail::key_buffer</a> <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::iterator::keybuf_ {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A buffer into which visited encoded (binary comparable) keys are materialized by during the iterator traversal. </p>
<p>Bytes are pushed onto this buffer when we push something onto the iterator stack and popped off of this buffer when we pop something off of the iterator stack. </p>

</div>
</div>
<a id="a6653e19363aa0aaa8747510bfd1c6e30" name="a6653e19363aa0aaa8747510bfd1c6e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6653e19363aa0aaa8747510bfd1c6e30">&#9670;&#160;</a></span>stack_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stack&lt;<a class="el" href="classunodb_1_1db_1_1iterator.html#a9166f2a1d9fcc47bc1c9f09da8806919">stack_entry</a>&gt; <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::iterator::stack_ {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A stack reflecting the parent path from the root of the tree to the current leaf. </p>
<p>An empty stack corresponds to a logically empty iterator and the iterator will report !valid(). The iterator for an empty tree is an empty stack. The stack is made up of (node_ptr, key, child_index) entries. The [node_ptr] is never [nullptr] and points to the internal node or leaf for that step in the path from the root to some leaf. For the bottom of the stack, [node_ptr] is the root. For the top of the stack, [node_ptr] is the current leaf. In the degenerate case where the tree is a single root leaf, then the stack contains just that leaf. The [key] is the [std::byte] along which the path descends from that [node_ptr]. The [key] has no meaning for a leaf. The key byte may be used to reconstruct the full key (along with any prefix bytes in the nodes along the path). The key byte is tracked to avoid having to search the keys of some node types (N48) when the [child_index] does not directly imply the key byte. The [child_index] is the [std::uint8_t] index position in the parent at which the [child_ptr] was found. The [child_index] has no meaning for a leaf. In the special case of N48, the [child_index] is the index into the [child_indexes[]]. For all other internal node types, the [child_index] is a direct index into the [children[]]. When finding the successor (or predecessor) the [child_index] needs to be interpreted according to the node type. For N4 and N16, you just look at the next slot in the children[] to find the successor. For N256, you look at the next non-null slot in the children[]. N48 is the oddest of the node types. For N48, you have to look at the child_indexes[], find the next mapped key value greater than the current one, and then look at its entry in the children[]. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="art_8hpp_source.html">art.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceunodb.html">unodb</a></li><li class="navelem"><a class="el" href="classunodb_1_1db.html">db</a></li><li class="navelem"><a class="el" href="classunodb_1_1db_1_1iterator.html">iterator</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
