<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UnoDB: unodb::key_encoder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">UnoDB
   </div>
   <div id="projectbrief">Adaptive Radix Tree in C++, optionally with Optimistic Lock Coupling</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classunodb_1_1key__encoder.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classunodb_1_1key__encoder-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">unodb::key_encoder Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A utility class to generate binary comparable keys from a sequence of key components.  
 <a href="classunodb_1_1key__encoder.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="art__common_8hpp_source.html">art_common.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a09a289c46cce6e9fa710bcad5aba9c0f" id="r_a09a289c46cce6e9fa710bcad5aba9c0f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1key__encoder.html#a09a289c46cce6e9fa710bcad5aba9c0f">size_type</a> = std::uint16_t</td></tr>
<tr class="memdesc:a09a289c46cce6e9fa710bcad5aba9c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This indirectly determines the <a class="el" href="classunodb_1_1key__encoder.html#ae0d432f6de285a4384378a8bc7c0fba2" title="The maximum length of a text component of the key.">unodb::key_encoder::maxlen</a> and is used as the byte width for the run-length encoding of the padding.  <br /></td></tr>
<tr class="separator:a09a289c46cce6e9fa710bcad5aba9c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a591fe4f824b2a55fea59154ef0b285b7" id="r_a591fe4f824b2a55fea59154ef0b285b7"><td class="memItemLeft" align="right" valign="top"><a id="a591fe4f824b2a55fea59154ef0b285b7" name="a591fe4f824b2a55fea59154ef0b285b7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>key_encoder</b> () noexcept=default</td></tr>
<tr class="memdesc:a591fe4f824b2a55fea59154ef0b285b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">setup a new key encoder. <br /></td></tr>
<tr class="separator:a591fe4f824b2a55fea59154ef0b285b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073ecee2db9797158b058ce56b2c8a3b" id="r_a073ecee2db9797158b058ce56b2c8a3b"><td class="memItemLeft" align="right" valign="top"><a id="a073ecee2db9797158b058ce56b2c8a3b" name="a073ecee2db9797158b058ce56b2c8a3b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_bytes</b> () const noexcept</td></tr>
<tr class="memdesc:a073ecee2db9797158b058ce56b2c8a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bytes of data in the internal buffer. <br /></td></tr>
<tr class="separator:a073ecee2db9797158b058ce56b2c8a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa36f66f0d72ece8b4064825e946f61" id="r_a8aa36f66f0d72ece8b4064825e946f61"><td class="memItemLeft" align="right" valign="top"><a id="a8aa36f66f0d72ece8b4064825e946f61" name="a8aa36f66f0d72ece8b4064825e946f61"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>capacity</b> () const noexcept</td></tr>
<tr class="memdesc:a8aa36f66f0d72ece8b4064825e946f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current capacity of the buffer. <br /></td></tr>
<tr class="separator:a8aa36f66f0d72ece8b4064825e946f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4f36b165be259d85666d7f61c1853b" id="r_acb4f36b165be259d85666d7f61c1853b"><td class="memItemLeft" align="right" valign="top"><a id="acb4f36b165be259d85666d7f61c1853b" name="acb4f36b165be259d85666d7f61c1853b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ensure_available</b> (size_t req)</td></tr>
<tr class="memdesc:acb4f36b165be259d85666d7f61c1853b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that the buffer can hold at least <em>req</em> additional bytes. <br /></td></tr>
<tr class="separator:acb4f36b165be259d85666d7f61c1853b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69575657d1b3dd1a4b6044ee90a65f97" id="r_a69575657d1b3dd1a4b6044ee90a65f97"><td class="memItemLeft" align="right" valign="top"><a id="a69575657d1b3dd1a4b6044ee90a65f97" name="a69575657d1b3dd1a4b6044ee90a65f97"></a>
<a class="el" href="classunodb_1_1key__encoder.html">key_encoder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> () noexcept</td></tr>
<tr class="memdesc:a69575657d1b3dd1a4b6044ee90a65f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the encoder to encode another key. <br /></td></tr>
<tr class="separator:a69575657d1b3dd1a4b6044ee90a65f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a7f5f082cfe3fc5c8f8534b7d8e00f" id="r_ad5a7f5f082cfe3fc5c8f8534b7d8e00f"><td class="memItemLeft" align="right" valign="top"><a id="ad5a7f5f082cfe3fc5c8f8534b7d8e00f" name="ad5a7f5f082cfe3fc5c8f8534b7d8e00f"></a>
<a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">key_view</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_key_view</b> () const noexcept</td></tr>
<tr class="memdesc:ad5a7f5f082cfe3fc5c8f8534b7d8e00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only view of the internal buffer showing only those bytes that were encoded since the last <a class="el" href="classunodb_1_1key__encoder.html#a69575657d1b3dd1a4b6044ee90a65f97" title="Reset the encoder to encode another key.">unodb::key_encoder::reset</a> call. <br /></td></tr>
<tr class="separator:ad5a7f5f082cfe3fc5c8f8534b7d8e00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e191f8c0617c9300ac59015dc668f8" id="r_a95e191f8c0617c9300ac59015dc668f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunodb_1_1key__encoder.html">key_encoder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1key__encoder.html#a95e191f8c0617c9300ac59015dc668f8">append_bytes</a> (std::span&lt; const std::byte &gt; data)</td></tr>
<tr class="memdesc:a95e191f8c0617c9300ac59015dc668f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a sequence of bytes to the key.  <br /></td></tr>
<tr class="separator:a95e191f8c0617c9300ac59015dc668f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1728563647df52fba61d0c506d4a6ef9" id="r_a1728563647df52fba61d0c506d4a6ef9"><td class="memItemLeft" align="right" valign="top"><a id="a1728563647df52fba61d0c506d4a6ef9" name="a1728563647df52fba61d0c506d4a6ef9"></a>
<a class="el" href="classunodb_1_1key__encoder.html">key_encoder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>encode</b> (std::int8_t v)</td></tr>
<tr class="separator:a1728563647df52fba61d0c506d4a6ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b7d2c8d7e923cd9e30fb5837e094f1" id="r_a41b7d2c8d7e923cd9e30fb5837e094f1"><td class="memItemLeft" align="right" valign="top"><a id="a41b7d2c8d7e923cd9e30fb5837e094f1" name="a41b7d2c8d7e923cd9e30fb5837e094f1"></a>
<a class="el" href="classunodb_1_1key__encoder.html">key_encoder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>encode</b> (std::int16_t v)</td></tr>
<tr class="separator:a41b7d2c8d7e923cd9e30fb5837e094f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6500e5d0063cc25edfeb0983ee3c24f" id="r_ae6500e5d0063cc25edfeb0983ee3c24f"><td class="memItemLeft" align="right" valign="top"><a id="ae6500e5d0063cc25edfeb0983ee3c24f" name="ae6500e5d0063cc25edfeb0983ee3c24f"></a>
<a class="el" href="classunodb_1_1key__encoder.html">key_encoder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>encode</b> (std::int32_t v)</td></tr>
<tr class="separator:ae6500e5d0063cc25edfeb0983ee3c24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d480dcfff5ccfbb3c06a25b5d5ea96" id="r_ae7d480dcfff5ccfbb3c06a25b5d5ea96"><td class="memItemLeft" align="right" valign="top"><a id="ae7d480dcfff5ccfbb3c06a25b5d5ea96" name="ae7d480dcfff5ccfbb3c06a25b5d5ea96"></a>
<a class="el" href="classunodb_1_1key__encoder.html">key_encoder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>encode</b> (std::int64_t v)</td></tr>
<tr class="separator:ae7d480dcfff5ccfbb3c06a25b5d5ea96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16645f3e2c7d79b43765b8779ad8fa30" id="r_a16645f3e2c7d79b43765b8779ad8fa30"><td class="memItemLeft" align="right" valign="top"><a id="a16645f3e2c7d79b43765b8779ad8fa30" name="a16645f3e2c7d79b43765b8779ad8fa30"></a>
<a class="el" href="classunodb_1_1key__encoder.html">key_encoder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>encode</b> (std::uint8_t v)</td></tr>
<tr class="separator:a16645f3e2c7d79b43765b8779ad8fa30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0044e756b0f3c628ddf20dcb638d60c6" id="r_a0044e756b0f3c628ddf20dcb638d60c6"><td class="memItemLeft" align="right" valign="top"><a id="a0044e756b0f3c628ddf20dcb638d60c6" name="a0044e756b0f3c628ddf20dcb638d60c6"></a>
<a class="el" href="classunodb_1_1key__encoder.html">key_encoder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>encode</b> (std::uint16_t v)</td></tr>
<tr class="separator:a0044e756b0f3c628ddf20dcb638d60c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255c2ad351167e9f3b9d4aa8c0b338d6" id="r_a255c2ad351167e9f3b9d4aa8c0b338d6"><td class="memItemLeft" align="right" valign="top"><a id="a255c2ad351167e9f3b9d4aa8c0b338d6" name="a255c2ad351167e9f3b9d4aa8c0b338d6"></a>
<a class="el" href="classunodb_1_1key__encoder.html">key_encoder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>encode</b> (std::uint32_t v)</td></tr>
<tr class="separator:a255c2ad351167e9f3b9d4aa8c0b338d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8134d1ded622cb34aaa74f3f37107a7b" id="r_a8134d1ded622cb34aaa74f3f37107a7b"><td class="memItemLeft" align="right" valign="top"><a id="a8134d1ded622cb34aaa74f3f37107a7b" name="a8134d1ded622cb34aaa74f3f37107a7b"></a>
<a class="el" href="classunodb_1_1key__encoder.html">key_encoder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>encode</b> (std::uint64_t v)</td></tr>
<tr class="separator:a8134d1ded622cb34aaa74f3f37107a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade062bb3c2a32b3b22490ac2f9084136" id="r_ade062bb3c2a32b3b22490ac2f9084136"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunodb_1_1key__encoder.html">key_encoder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1key__encoder.html#ade062bb3c2a32b3b22490ac2f9084136">encode</a> (float v)</td></tr>
<tr class="memdesc:ade062bb3c2a32b3b22490ac2f9084136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode the floating-point value.  <br /></td></tr>
<tr class="separator:ade062bb3c2a32b3b22490ac2f9084136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92457eac73c0de7cdf1730aef9c930c6" id="r_a92457eac73c0de7cdf1730aef9c930c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunodb_1_1key__encoder.html">key_encoder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1key__encoder.html#a92457eac73c0de7cdf1730aef9c930c6">encode</a> (double v)</td></tr>
<tr class="memdesc:a92457eac73c0de7cdf1730aef9c930c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode the double precision value.  <br /></td></tr>
<tr class="separator:a92457eac73c0de7cdf1730aef9c930c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df01fec40725b7eb9804459bf1c47c0" id="r_a5df01fec40725b7eb9804459bf1c47c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunodb_1_1key__encoder.html">key_encoder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1key__encoder.html#a5df01fec40725b7eb9804459bf1c47c0">encode_text</a> (std::span&lt; const std::byte &gt; text)</td></tr>
<tr class="memdesc:a5df01fec40725b7eb9804459bf1c47c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This encodes ASCII text or Unicode sort keys.  <br /></td></tr>
<tr class="separator:a5df01fec40725b7eb9804459bf1c47c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1734d130fedc16906c09e1f9e6a1a90" id="r_ad1734d130fedc16906c09e1f9e6a1a90"><td class="memItemLeft" align="right" valign="top"><a id="ad1734d130fedc16906c09e1f9e6a1a90" name="ad1734d130fedc16906c09e1f9e6a1a90"></a>
<a class="el" href="classunodb_1_1key__encoder.html">key_encoder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>encode_text</b> (std::string_view sv)</td></tr>
<tr class="memdesc:ad1734d130fedc16906c09e1f9e6a1a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience alias. <br /></td></tr>
<tr class="separator:ad1734d130fedc16906c09e1f9e6a1a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6b0e10a0c2358f40cab56f8afdcabb" id="r_a1e6b0e10a0c2358f40cab56f8afdcabb"><td class="memItemLeft" align="right" valign="top"><a id="a1e6b0e10a0c2358f40cab56f8afdcabb" name="a1e6b0e10a0c2358f40cab56f8afdcabb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>key_encoder</b> (const <a class="el" href="classunodb_1_1key__encoder.html">key_encoder</a> &amp;)=delete</td></tr>
<tr class="separator:a1e6b0e10a0c2358f40cab56f8afdcabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9e3a7c87c95bc9ed8984fca4262ac8" id="r_a1e9e3a7c87c95bc9ed8984fca4262ac8"><td class="memItemLeft" align="right" valign="top"><a id="a1e9e3a7c87c95bc9ed8984fca4262ac8" name="a1e9e3a7c87c95bc9ed8984fca4262ac8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>key_encoder</b> (<a class="el" href="classunodb_1_1key__encoder.html">key_encoder</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a1e9e3a7c87c95bc9ed8984fca4262ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffe17f28b558e45d05a2bfcfd53589c" id="r_acffe17f28b558e45d05a2bfcfd53589c"><td class="memItemLeft" align="right" valign="top"><a id="acffe17f28b558e45d05a2bfcfd53589c" name="acffe17f28b558e45d05a2bfcfd53589c"></a>
<a class="el" href="classunodb_1_1key__encoder.html">key_encoder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classunodb_1_1key__encoder.html">key_encoder</a> &amp;)=delete</td></tr>
<tr class="separator:acffe17f28b558e45d05a2bfcfd53589c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca10811f5eedac3564a33b8ef81c0931" id="r_aca10811f5eedac3564a33b8ef81c0931"><td class="memItemLeft" align="right" valign="top"><a id="aca10811f5eedac3564a33b8ef81c0931" name="aca10811f5eedac3564a33b8ef81c0931"></a>
<a class="el" href="classunodb_1_1key__encoder.html">key_encoder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classunodb_1_1key__encoder.html">key_encoder</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:aca10811f5eedac3564a33b8ef81c0931"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a52f15092ae61b2c24c23af0dc4831cc5" id="r_a52f15092ae61b2c24c23af0dc4831cc5"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1key__encoder.html#a52f15092ae61b2c24c23af0dc4831cc5">pad</a> {static_cast&lt;std::byte&gt;(0x00)}</td></tr>
<tr class="memdesc:a52f15092ae61b2c24c23af0dc4831cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pad byte used when encoding variable length text into a key to logically extend the text field to <a class="el" href="classunodb_1_1key__encoder.html#ae0d432f6de285a4384378a8bc7c0fba2" title="The maximum length of a text component of the key.">unodb::key_encoder::maxlen</a> bytes.  <br /></td></tr>
<tr class="separator:a52f15092ae61b2c24c23af0dc4831cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d432f6de285a4384378a8bc7c0fba2" id="r_ae0d432f6de285a4384378a8bc7c0fba2"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1key__encoder.html#ae0d432f6de285a4384378a8bc7c0fba2">maxlen</a></td></tr>
<tr class="memdesc:ae0d432f6de285a4384378a8bc7c0fba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum length of a text component of the key.  <br /></td></tr>
<tr class="separator:ae0d432f6de285a4384378a8bc7c0fba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a38cb81c43056442a3c98755280ac8ad0" id="r_a38cb81c43056442a3c98755280ac8ad0"><td class="memItemLeft" align="right" valign="top"><a id="a38cb81c43056442a3c98755280ac8ad0" name="a38cb81c43056442a3c98755280ac8ad0"></a>
static constexpr std::uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>msb8</b> = 1U &lt;&lt; 7</td></tr>
<tr class="separator:a38cb81c43056442a3c98755280ac8ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc674f94f24dd67301ba6f03773973b" id="r_abfc674f94f24dd67301ba6f03773973b"><td class="memItemLeft" align="right" valign="top"><a id="abfc674f94f24dd67301ba6f03773973b" name="abfc674f94f24dd67301ba6f03773973b"></a>
static constexpr std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>msb16</b> = 1U &lt;&lt; 15</td></tr>
<tr class="separator:abfc674f94f24dd67301ba6f03773973b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4421b780422e13353b52d1bd2a83324" id="r_ae4421b780422e13353b52d1bd2a83324"><td class="memItemLeft" align="right" valign="top"><a id="ae4421b780422e13353b52d1bd2a83324" name="ae4421b780422e13353b52d1bd2a83324"></a>
static constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>msb32</b> = 1U &lt;&lt; 31</td></tr>
<tr class="separator:ae4421b780422e13353b52d1bd2a83324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1f0e51db840fcf0249035ff4f3aa2f" id="r_adb1f0e51db840fcf0249035ff4f3aa2f"><td class="memItemLeft" align="right" valign="top"><a id="adb1f0e51db840fcf0249035ff4f3aa2f" name="adb1f0e51db840fcf0249035ff4f3aa2f"></a>
static constexpr std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>msb64</b> = 1ULL &lt;&lt; 63</td></tr>
<tr class="separator:adb1f0e51db840fcf0249035ff4f3aa2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aa75a0d285ed84818d9cd31d79db814b0" id="r_aa75a0d285ed84818d9cd31d79db814b0"><td class="memItemLeft" align="right" valign="top"><a id="aa75a0d285ed84818d9cd31d79db814b0" name="aa75a0d285ed84818d9cd31d79db814b0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ensure_capacity</b> (size_t min_capacity)</td></tr>
<tr class="memdesc:aa75a0d285ed84818d9cd31d79db814b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that we have at least the specified capacity in the buffer. <br /></td></tr>
<tr class="separator:aa75a0d285ed84818d9cd31d79db814b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a0ce9f63be6a58b88b97202ca0a8705f1" id="r_a0ce9f63be6a58b88b97202ca0a8705f1"><td class="memItemLeft" align="right" valign="top"><a id="a0ce9f63be6a58b88b97202ca0a8705f1" name="a0ce9f63be6a58b88b97202ca0a8705f1"></a>
std::byte&#160;</td><td class="memItemRight" valign="bottom"><b>ibuf</b> [<a class="el" href="namespaceunodb_1_1detail.html#aba258d6d1df5e71714ec57d8b041b129">detail::INITIAL_BUFFER_CAPACITY</a>]</td></tr>
<tr class="memdesc:a0ce9f63be6a58b88b97202ca0a8705f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for the initial buffer. <br /></td></tr>
<tr class="separator:a0ce9f63be6a58b88b97202ca0a8705f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ee1fa410f52af5353bf5baff2173a7" id="r_a54ee1fa410f52af5353bf5baff2173a7"><td class="memItemLeft" align="right" valign="top">std::byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1key__encoder.html#a54ee1fa410f52af5353bf5baff2173a7">buf</a> {&amp;<a class="el" href="classunodb_1_1key__encoder.html#a0ce9f63be6a58b88b97202ca0a8705f1">ibuf</a>[0]}</td></tr>
<tr class="memdesc:a54ee1fa410f52af5353bf5baff2173a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer to accmulate the encoded key.  <br /></td></tr>
<tr class="separator:a54ee1fa410f52af5353bf5baff2173a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1478bff6b7044ef89d7fde75061011d" id="r_ae1478bff6b7044ef89d7fde75061011d"><td class="memItemLeft" align="right" valign="top"><a id="ae1478bff6b7044ef89d7fde75061011d" name="ae1478bff6b7044ef89d7fde75061011d"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>cap</b> {sizeof(<a class="el" href="classunodb_1_1key__encoder.html#a0ce9f63be6a58b88b97202ca0a8705f1">ibuf</a>)}</td></tr>
<tr class="memdesc:ae1478bff6b7044ef89d7fde75061011d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current buffer capacity. <br /></td></tr>
<tr class="separator:ae1478bff6b7044ef89d7fde75061011d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18f5a324c9f8866cc233f1872b56857" id="r_aa18f5a324c9f8866cc233f1872b56857"><td class="memItemLeft" align="right" valign="top"><a id="aa18f5a324c9f8866cc233f1872b56857" name="aa18f5a324c9f8866cc233f1872b56857"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>off</b> {0}</td></tr>
<tr class="memdesc:aa18f5a324c9f8866cc233f1872b56857"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bytes in the buffer having encoded data. <br /></td></tr>
<tr class="separator:aa18f5a324c9f8866cc233f1872b56857"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A utility class to generate binary comparable keys from a sequence of key components. </p>
<p>This class supports the various kinds of primitive data types and provides support for the caller to pass through Unicode sort keys.</p>
<dl class="section note"><dt>Note</dt><dd>This class is NOT final so people can extend or override the <a class="el" href="classunodb_1_1key__encoder.html" title="A utility class to generate binary comparable keys from a sequence of key components.">unodb::key_encoder</a> (and <a class="el" href="classunodb_1_1key__decoder.html" title="A utility class that can decode binary comparable keys as long as those keys (except for Unicode sort...">unodb::key_decoder</a>) for language specific handling of order within floating point values, handling of database <code>NULLs</code>, etc. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a09a289c46cce6e9fa710bcad5aba9c0f" name="a09a289c46cce6e9fa710bcad5aba9c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a289c46cce6e9fa710bcad5aba9c0f">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classunodb_1_1key__encoder.html#a09a289c46cce6e9fa710bcad5aba9c0f">unodb::key_encoder::size_type</a> =  std::uint16_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This indirectly determines the <a class="el" href="classunodb_1_1key__encoder.html#ae0d432f6de285a4384378a8bc7c0fba2" title="The maximum length of a text component of the key.">unodb::key_encoder::maxlen</a> and is used as the byte width for the run-length encoding of the padding. </p>
<dl class="section note"><dt>Note</dt><dd>The choice of <code>std::uint16</code> here has implications for both the maximum allowed key length and the overhead for each encoded text field (since we must use the same stride to encode the pad run length). If this is change to <code>std::uint32</code>, then you can encode longer text fields, but the padding overhead will be <code>5</code> bytes (vs <code>3</code> bytes today). </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a95e191f8c0617c9300ac59015dc668f8" name="a95e191f8c0617c9300ac59015dc668f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e191f8c0617c9300ac59015dc668f8">&#9670;&#160;</a></span>append_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunodb_1_1key__encoder.html">key_encoder</a> &amp; unodb::key_encoder::append_bytes </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const std::byte &gt;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a sequence of bytes to the key. </p>
<p>The caller is responsible for not violating the ART contract (no key may be a prefix of another key). </p>

</div>
</div>
<a id="a92457eac73c0de7cdf1730aef9c930c6" name="a92457eac73c0de7cdf1730aef9c930c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92457eac73c0de7cdf1730aef9c930c6">&#9670;&#160;</a></span>encode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunodb_1_1key__encoder.html">key_encoder</a> &amp; unodb::key_encoder::encode </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode the double precision value. </p>
<dl class="section note"><dt>Note</dt><dd>Encoding maps all <code>NaN</code> values to a single canonical <code>NaN</code>. This means that decoding is not perfect and various kinds of <code>NaN</code> all decode as a single canonical <code>NaN</code>. </dd></dl>

</div>
</div>
<a id="ade062bb3c2a32b3b22490ac2f9084136" name="ade062bb3c2a32b3b22490ac2f9084136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade062bb3c2a32b3b22490ac2f9084136">&#9670;&#160;</a></span>encode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunodb_1_1key__encoder.html">key_encoder</a> &amp; unodb::key_encoder::encode </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode the floating-point value. </p>
<dl class="section note"><dt>Note</dt><dd>Encoding maps all <code>NaN</code> values to a single canonical <code>NaN</code>. This means that decoding is not perfect and various kinds of <code>NaN</code> all decode as a single canonical <code>NaN</code>. </dd></dl>

</div>
</div>
<a id="a5df01fec40725b7eb9804459bf1c47c0" name="a5df01fec40725b7eb9804459bf1c47c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df01fec40725b7eb9804459bf1c47c0">&#9670;&#160;</a></span>encode_text()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunodb_1_1key__encoder.html">key_encoder</a> &amp; unodb::key_encoder::encode_text </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const std::byte &gt;&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This encodes ASCII text or Unicode sort keys. </p>
<p>Keys are logically padded out to <a class="el" href="classunodb_1_1key__encoder.html#ae0d432f6de285a4384378a8bc7c0fba2" title="The maximum length of a text component of the key.">unodb::key_encoder::maxlen</a> bytes and will be truncated if they would exceed unodb::ley_encoder::maxlen bytesq.</p>
<dl class="section note"><dt>Note</dt><dd>The ART index disallows keys which are prefixes of other keys. The logical padding addresses this and other issues while preserving lexicographic ordering.</dd></dl>
<p>When handling Unicode, the caller is responsible for using a quality library (e.g., ICU) to (a) normalize their Unicode data; and (b) generate a Unicode sort key from their Unicode data. The sort key will impose specific collation ordering semantics as configured by the application (locale, collation strength, decomposition mode).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>A view onto some sequence of bytes. The view will be truncated to at most <a class="el" href="classunodb_1_1key__encoder.html#ae0d432f6de285a4384378a8bc7c0fba2" title="The maximum length of a text component of the key.">unodb::key_encoder::maxlen</a> bytes. A <a class="el" href="classunodb_1_1key__encoder.html#a52f15092ae61b2c24c23af0dc4831cc5" title="The pad byte used when encoding variable length text into a key to logically extend the text field to...">unodb::key_encoder::pad</a> byte and a run count are added to make all text fields logically <a class="el" href="classunodb_1_1key__encoder.html#ae0d432f6de285a4384378a8bc7c0fba2" title="The maximum length of a text component of the key.">unodb::key_encoder::maxlen</a> bytes long. The truncation and padding (a) ensures that no key is a prefix of another key; and (b) keeps multi-field keys with embedded variable length text fields aligned such that the field following a variable length text field does not bleed into the lexiographic ordering of the variable length text field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a54ee1fa410f52af5353bf5baff2173a7" name="a54ee1fa410f52af5353bf5baff2173a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ee1fa410f52af5353bf5baff2173a7">&#9670;&#160;</a></span>buf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::byte* unodb::key_encoder::buf {&amp;<a class="el" href="classunodb_1_1key__encoder.html#a0ce9f63be6a58b88b97202ca0a8705f1">ibuf</a>[0]}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The buffer to accmulate the encoded key. </p>
<p>Originally this is the internal buffer. If that overflows, then something will be allocated. </p>

</div>
</div>
<a id="ae0d432f6de285a4384378a8bc7c0fba2" name="ae0d432f6de285a4384378a8bc7c0fba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d432f6de285a4384378a8bc7c0fba2">&#9670;&#160;</a></span>maxlen</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto unodb::key_encoder::maxlen</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">static_cast&lt;</span><a class="code hl_typedef" href="classunodb_1_1key__encoder.html#a09a289c46cce6e9fa710bcad5aba9c0f">size_type</a><span class="keyword">&gt;</span>(</div>
<div class="line">      std::numeric_limits&lt;size_type&gt;::max() - <span class="keyword">sizeof</span>(<a class="code hl_variable" href="classunodb_1_1key__encoder.html#a52f15092ae61b2c24c23af0dc4831cc5">pad</a>) - <span class="keyword">sizeof</span>(<a class="code hl_typedef" href="classunodb_1_1key__encoder.html#a09a289c46cce6e9fa710bcad5aba9c0f">size_type</a>))}</div>
<div class="ttc" id="aclassunodb_1_1key__encoder_html_a09a289c46cce6e9fa710bcad5aba9c0f"><div class="ttname"><a href="classunodb_1_1key__encoder.html#a09a289c46cce6e9fa710bcad5aba9c0f">unodb::key_encoder::size_type</a></div><div class="ttdeci">std::uint16_t size_type</div><div class="ttdoc">This indirectly determines the unodb::key_encoder::maxlen and is used as the byte width for the run-l...</div><div class="ttdef"><b>Definition</b> art_common.hpp:251</div></div>
<div class="ttc" id="aclassunodb_1_1key__encoder_html_a52f15092ae61b2c24c23af0dc4831cc5"><div class="ttname"><a href="classunodb_1_1key__encoder.html#a52f15092ae61b2c24c23af0dc4831cc5">unodb::key_encoder::pad</a></div><div class="ttdeci">static constexpr auto pad</div><div class="ttdoc">The pad byte used when encoding variable length text into a key to logically extend the text field to...</div><div class="ttdef"><b>Definition</b> art_common.hpp:259</div></div>
</div><!-- fragment -->
<p>The maximum length of a text component of the key. </p>
<p>Keys are truncated to at most this many bytes and then logically extended using the <code>pad</code> byte and a trailing run length until the field is logically <code>maxlen</code> bytes wide. This field is computed such that the total byte width of the encoded text can be indexed by <code>sizeof(size_type)</code>. </p>

</div>
</div>
<a id="a52f15092ae61b2c24c23af0dc4831cc5" name="a52f15092ae61b2c24c23af0dc4831cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f15092ae61b2c24c23af0dc4831cc5">&#9670;&#160;</a></span>pad</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto unodb::key_encoder::pad {static_cast&lt;std::byte&gt;(0x00)}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pad byte used when encoding variable length text into a key to logically extend the text field to <a class="el" href="classunodb_1_1key__encoder.html#ae0d432f6de285a4384378a8bc7c0fba2" title="The maximum length of a text component of the key.">unodb::key_encoder::maxlen</a> bytes. </p>
<p>The pad byte (which is added to the buffer as an unsigned value) is followed by a run length count such that the key is logically padded out to the maximum length of a text field, which is <a class="el" href="classunodb_1_1key__encoder.html#ae0d432f6de285a4384378a8bc7c0fba2" title="The maximum length of a text component of the key.">unodb::key_encoder::maxlen</a>. The run length count is expressed in the <a class="el" href="classunodb_1_1key__encoder.html#a09a289c46cce6e9fa710bcad5aba9c0f" title="This indirectly determines the unodb::key_encoder::maxlen and is used as the byte width for the run-l...">unodb::key_encoder::size_type</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="art__common_8hpp_source.html">art_common.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceunodb.html">unodb</a></li><li class="navelem"><a class="el" href="classunodb_1_1key__encoder.html">key_encoder</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
