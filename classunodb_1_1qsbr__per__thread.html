<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UnoDB: unodb::qsbr_per_thread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">UnoDB
   </div>
   <div id="projectbrief">Adaptive Radix Tree in C++, optionally with Optimistic Lock Coupling</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classunodb_1_1qsbr__per__thread.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classunodb_1_1qsbr__per__thread-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">unodb::qsbr_per_thread Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Thread-local QSBR data structure.  
 <a href="classunodb_1_1qsbr__per__thread.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="qsbr_8hpp_source.html">qsbr.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae1e3f96bb8539c79193ea55c0bacee1d" id="r_ae1e3f96bb8539c79193ea55c0bacee1d"><td class="memItemLeft" align="right" valign="top"><a id="ae1e3f96bb8539c79193ea55c0bacee1d" name="ae1e3f96bb8539c79193ea55c0bacee1d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>qsbr_per_thread</b> ()</td></tr>
<tr class="memdesc:ae1e3f96bb8539c79193ea55c0bacee1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new thread-local QSBR structure and register with global QSBR. <br /></td></tr>
<tr class="separator:ae1e3f96bb8539c79193ea55c0bacee1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310ad917b38a86a0967b1d7998f2c274" id="r_a310ad917b38a86a0967b1d7998f2c274"><td class="memItemLeft" align="right" valign="top"><a id="a310ad917b38a86a0967b1d7998f2c274" name="a310ad917b38a86a0967b1d7998f2c274"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~qsbr_per_thread</b> () noexcept</td></tr>
<tr class="memdesc:a310ad917b38a86a0967b1d7998f2c274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister the current thread from global QSBR on thread exist. <br /></td></tr>
<tr class="separator:a310ad917b38a86a0967b1d7998f2c274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e9830fbe4868759b676fc091cabf0f" id="r_a88e9830fbe4868759b676fc091cabf0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1qsbr__per__thread.html#a88e9830fbe4868759b676fc091cabf0f">on_next_epoch_deallocate</a> (void *pointer, std::size_t size, <a class="el" href="structunodb_1_1detail_1_1deallocation__request.html#a091c0981dcaefa926b631259f83f190c">detail::deallocation_request::debug_callback</a> dealloc_callback)</td></tr>
<tr class="memdesc:a88e9830fbe4868759b676fc091cabf0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request deallocation of <em>pointer</em> when it is safe to do so.  <br /></td></tr>
<tr class="separator:a88e9830fbe4868759b676fc091cabf0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26eeb41f72fcf9f6753ec95d8f1cb99" id="r_ac26eeb41f72fcf9f6753ec95d8f1cb99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1qsbr__per__thread.html#ac26eeb41f72fcf9f6753ec95d8f1cb99">quiescent</a> ()</td></tr>
<tr class="memdesc:ac26eeb41f72fcf9f6753ec95d8f1cb99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal that this thread is quiescent.  <br /></td></tr>
<tr class="separator:ac26eeb41f72fcf9f6753ec95d8f1cb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19cd835a80932eac2270d84fbd3cf98b" id="r_a19cd835a80932eac2270d84fbd3cf98b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1qsbr__per__thread.html#a19cd835a80932eac2270d84fbd3cf98b">qsbr_pause</a> ()</td></tr>
<tr class="memdesc:a19cd835a80932eac2270d84fbd3cf98b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause QSBR for this thread, unregistering from global QSBR.  <br /></td></tr>
<tr class="separator:a19cd835a80932eac2270d84fbd3cf98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d30dde1b08b22f8a2bc5f1677cf024" id="r_aa3d30dde1b08b22f8a2bc5f1677cf024"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1qsbr__per__thread.html#aa3d30dde1b08b22f8a2bc5f1677cf024">qsbr_resume</a> ()</td></tr>
<tr class="memdesc:aa3d30dde1b08b22f8a2bc5f1677cf024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume QSBR for this thread, registering with global QSBR.  <br /></td></tr>
<tr class="separator:aa3d30dde1b08b22f8a2bc5f1677cf024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e663e72fcf713584184f8a0a2e4d11" id="r_ac2e663e72fcf713584184f8a0a2e4d11"><td class="memItemLeft" align="right" valign="top"><a id="ac2e663e72fcf713584184f8a0a2e4d11" name="ac2e663e72fcf713584184f8a0a2e4d11"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_qsbr_paused</b> () const noexcept</td></tr>
<tr class="memdesc:ac2e663e72fcf713584184f8a0a2e4d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if QSBR is paused for this thread. <br /></td></tr>
<tr class="separator:ac2e663e72fcf713584184f8a0a2e4d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e208117edcaa92cbb31aa9a3e5a34e" id="r_ac0e208117edcaa92cbb31aa9a3e5a34e"><td class="memItemLeft" align="right" valign="top"><a id="ac0e208117edcaa92cbb31aa9a3e5a34e" name="ac0e208117edcaa92cbb31aa9a3e5a34e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>previous_interval_requests_empty</b> () const noexcept</td></tr>
<tr class="memdesc:ac0e208117edcaa92cbb31aa9a3e5a34e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there are no deallocation requests for the previous epoch. <br /></td></tr>
<tr class="separator:ac0e208117edcaa92cbb31aa9a3e5a34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab7b36cb099cf5a58d031301742ecb5" id="r_a0ab7b36cb099cf5a58d031301742ecb5"><td class="memItemLeft" align="right" valign="top"><a id="a0ab7b36cb099cf5a58d031301742ecb5" name="a0ab7b36cb099cf5a58d031301742ecb5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>current_interval_requests_empty</b> () const noexcept</td></tr>
<tr class="memdesc:a0ab7b36cb099cf5a58d031301742ecb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there are no deallocation requests for the current epoch. <br /></td></tr>
<tr class="separator:a0ab7b36cb099cf5a58d031301742ecb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01458452f2f594358c13598ab051170" id="r_ab01458452f2f594358c13598ab051170"><td class="memItemLeft" align="right" valign="top"><a id="ab01458452f2f594358c13598ab051170" name="ab01458452f2f594358c13598ab051170"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_current_interval_total_dealloc_size</b> () const noexcept</td></tr>
<tr class="memdesc:ab01458452f2f594358c13598ab051170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total size of memory submitted for deallocation in the current epoch. <br /></td></tr>
<tr class="separator:ab01458452f2f594358c13598ab051170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1e6444ac3bdcb2d29867e15a8d5557" id="r_a2a1e6444ac3bdcb2d29867e15a8d5557"><td class="memItemLeft" align="right" valign="top"><a id="a2a1e6444ac3bdcb2d29867e15a8d5557" name="a2a1e6444ac3bdcb2d29867e15a8d5557"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>qsbr_per_thread</b> (const <a class="el" href="classunodb_1_1qsbr__per__thread.html">qsbr_per_thread</a> &amp;)=delete</td></tr>
<tr class="memdesc:a2a1e6444ac3bdcb2d29867e15a8d5557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy construction is disabled for a per-thread singleton. <br /></td></tr>
<tr class="separator:a2a1e6444ac3bdcb2d29867e15a8d5557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b1ec4bd42e642d72e7c2f6890ccd69" id="r_a80b1ec4bd42e642d72e7c2f6890ccd69"><td class="memItemLeft" align="right" valign="top"><a id="a80b1ec4bd42e642d72e7c2f6890ccd69" name="a80b1ec4bd42e642d72e7c2f6890ccd69"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>qsbr_per_thread</b> (<a class="el" href="classunodb_1_1qsbr__per__thread.html">qsbr_per_thread</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a80b1ec4bd42e642d72e7c2f6890ccd69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move construction is disabled for a per-thread singleton. <br /></td></tr>
<tr class="separator:a80b1ec4bd42e642d72e7c2f6890ccd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9922cb9ca9d68383a81de4c9309fcd" id="r_a6f9922cb9ca9d68383a81de4c9309fcd"><td class="memItemLeft" align="right" valign="top"><a id="a6f9922cb9ca9d68383a81de4c9309fcd" name="a6f9922cb9ca9d68383a81de4c9309fcd"></a>
<a class="el" href="classunodb_1_1qsbr__per__thread.html">qsbr_per_thread</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classunodb_1_1qsbr__per__thread.html">qsbr_per_thread</a> &amp;)=delete</td></tr>
<tr class="memdesc:a6f9922cb9ca9d68383a81de4c9309fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment is disabled for a per-thread singleton. <br /></td></tr>
<tr class="separator:a6f9922cb9ca9d68383a81de4c9309fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9c7ff812f0d133f937a0f53a1b4def" id="r_a0d9c7ff812f0d133f937a0f53a1b4def"><td class="memItemLeft" align="right" valign="top"><a id="a0d9c7ff812f0d133f937a0f53a1b4def" name="a0d9c7ff812f0d133f937a0f53a1b4def"></a>
<a class="el" href="classunodb_1_1qsbr__per__thread.html">qsbr_per_thread</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classunodb_1_1qsbr__per__thread.html">qsbr_per_thread</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a0d9c7ff812f0d133f937a0f53a1b4def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment is disabled for a per-thread singleton. <br /></td></tr>
<tr class="separator:a0d9c7ff812f0d133f937a0f53a1b4def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39c9b13610c71dce1e166a874a4b194" id="r_ae39c9b13610c71dce1e166a874a4b194"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1qsbr__per__thread.html#ae39c9b13610c71dce1e166a874a4b194">register_active_ptr</a> (const void *ptr)</td></tr>
<tr class="memdesc:ae39c9b13610c71dce1e166a874a4b194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an active pointer <em>ptr</em> to QSBR-managed data in this thread.  <br /></td></tr>
<tr class="separator:ae39c9b13610c71dce1e166a874a4b194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5983279bf3dbf1c42a4d86cab81869f2" id="r_a5983279bf3dbf1c42a4d86cab81869f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1qsbr__per__thread.html#a5983279bf3dbf1c42a4d86cab81869f2">unregister_active_ptr</a> (const void *ptr)</td></tr>
<tr class="memdesc:a5983279bf3dbf1c42a4d86cab81869f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister an active pointer <em>ptr</em> to QSBR-managed data in this thread.  <br /></td></tr>
<tr class="separator:a5983279bf3dbf1c42a4d86cab81869f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ae8ed6c0ce29e48f1fc70a5e3e94cd25f" id="r_ae8ed6c0ce29e48f1fc70a5e3e94cd25f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1qsbr__per__thread.html#ae8ed6c0ce29e48f1fc70a5e3e94cd25f">advance_last_seen_epoch</a> (bool single_thread_mode, <a class="el" href="classunodb_1_1detail_1_1qsbr__epoch.html">detail::qsbr_epoch</a> new_seen_epoch, <a class="el" href="namespaceunodb_1_1detail.html#a3c98952bb0651c3bd50ab5de879cfeff">detail::dealloc_request_vector</a> new_current_requests={})</td></tr>
<tr class="memdesc:ae8ed6c0ce29e48f1fc70a5e3e94cd25f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update this thread's view of the current epoch and execute the previous interval deallocation requests if a newer epoch is seen.  <br /></td></tr>
<tr class="separator:ae8ed6c0ce29e48f1fc70a5e3e94cd25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f84e25a40dffd8dc13c73613634053" id="r_a31f84e25a40dffd8dc13c73613634053"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1qsbr__per__thread.html#a31f84e25a40dffd8dc13c73613634053">update_requests</a> (bool single_thread_mode, <a class="el" href="classunodb_1_1detail_1_1qsbr__epoch.html">detail::qsbr_epoch</a> dealloc_epoch, <a class="el" href="namespaceunodb_1_1detail.html#a3c98952bb0651c3bd50ab5de879cfeff">detail::dealloc_request_vector</a> new_current_requests={})</td></tr>
<tr class="memdesc:a31f84e25a40dffd8dc13c73613634053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the previous interval deallocation requests and move the current interval ones to the previous interval.  <br /></td></tr>
<tr class="separator:a31f84e25a40dffd8dc13c73613634053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5546a8285617341d41aa30d0ea0fe4" id="r_aeb5546a8285617341d41aa30d0ea0fe4"><td class="memItemLeft" align="right" valign="top"><a id="aeb5546a8285617341d41aa30d0ea0fe4" name="aeb5546a8285617341d41aa30d0ea0fe4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>orphan_deferred_requests</b> () noexcept</td></tr>
<tr class="memdesc:aeb5546a8285617341d41aa30d0ea0fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move any pending deallocation requests to the global QSBR structure when the thread exits. <br /></td></tr>
<tr class="separator:aeb5546a8285617341d41aa30d0ea0fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a5b3daf071eeaa156244c57f3b848b0d2" id="r_a5b3daf071eeaa156244c57f3b848b0d2"><td class="memItemLeft" align="right" valign="top"><a id="a5b3daf071eeaa156244c57f3b848b0d2" name="a5b3daf071eeaa156244c57f3b848b0d2"></a>
static <a class="el" href="classunodb_1_1qsbr__per__thread.html">qsbr_per_thread</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_instance</b> () noexcept</td></tr>
<tr class="memdesc:a5b3daf071eeaa156244c57f3b848b0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thread-local QSBR data structure instance. <br /></td></tr>
<tr class="separator:a5b3daf071eeaa156244c57f3b848b0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e46b44064a75d5fcd1f97b11b5e3f6a" id="r_a7e46b44064a75d5fcd1f97b11b5e3f6a"><td class="memItemLeft" align="right" valign="top"><a id="a7e46b44064a75d5fcd1f97b11b5e3f6a" name="a7e46b44064a75d5fcd1f97b11b5e3f6a"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>set_instance</b> (std::unique_ptr&lt; <a class="el" href="classunodb_1_1qsbr__per__thread.html">qsbr_per_thread</a> &gt; new_instance) noexcept</td></tr>
<tr class="memdesc:a7e46b44064a75d5fcd1f97b11b5e3f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <em>new_instance</em> to be the thread-local QSBR data structure instance. <br /></td></tr>
<tr class="separator:a7e46b44064a75d5fcd1f97b11b5e3f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a888e20fad9dfd7017ee351f965fc8ec1" id="r_a888e20fad9dfd7017ee351f965fc8ec1"><td class="memItemLeft" align="right" valign="top"><a id="a888e20fad9dfd7017ee351f965fc8ec1" name="a888e20fad9dfd7017ee351f965fc8ec1"></a>
std::unique_ptr&lt; <a class="el" href="structunodb_1_1detail_1_1dealloc__vector__list__node.html">detail::dealloc_vector_list_node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>previous_interval_orphan_list_node</b></td></tr>
<tr class="memdesc:a888e20fad9dfd7017ee351f965fc8ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preallocated list node for orphaning pending previous epoch requests on thread exit. <br /></td></tr>
<tr class="separator:a888e20fad9dfd7017ee351f965fc8ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0956872b02e7c8af4f6d0078eaa909f7" id="r_a0956872b02e7c8af4f6d0078eaa909f7"><td class="memItemLeft" align="right" valign="top"><a id="a0956872b02e7c8af4f6d0078eaa909f7" name="a0956872b02e7c8af4f6d0078eaa909f7"></a>
std::unique_ptr&lt; <a class="el" href="structunodb_1_1detail_1_1dealloc__vector__list__node.html">detail::dealloc_vector_list_node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>current_interval_orphan_list_node</b></td></tr>
<tr class="memdesc:a0956872b02e7c8af4f6d0078eaa909f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preallocated list node for orphaning pending current epoch requests on thread exit. <br /></td></tr>
<tr class="separator:a0956872b02e7c8af4f6d0078eaa909f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27231a20f8d382edb8f6257b208c15c" id="r_aa27231a20f8d382edb8f6257b208c15c"><td class="memItemLeft" align="right" valign="top"><a id="aa27231a20f8d382edb8f6257b208c15c" name="aa27231a20f8d382edb8f6257b208c15c"></a>
std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>quiescent_states_since_epoch_change</b> {0}</td></tr>
<tr class="memdesc:aa27231a20f8d382edb8f6257b208c15c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of quiescent states since the last epoch change. <br /></td></tr>
<tr class="separator:aa27231a20f8d382edb8f6257b208c15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df2fb1d9f5d8c55d53140eb2e7ef864" id="r_a5df2fb1d9f5d8c55d53140eb2e7ef864"><td class="memItemLeft" align="right" valign="top"><a id="a5df2fb1d9f5d8c55d53140eb2e7ef864" name="a5df2fb1d9f5d8c55d53140eb2e7ef864"></a>
<a class="el" href="classunodb_1_1detail_1_1qsbr__epoch.html">detail::qsbr_epoch</a>&#160;</td><td class="memItemRight" valign="bottom"><b>last_seen_quiescent_state_epoch</b></td></tr>
<tr class="memdesc:a5df2fb1d9f5d8c55d53140eb2e7ef864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last seen global epoch by quiescent state for this thread. <br /></td></tr>
<tr class="separator:a5df2fb1d9f5d8c55d53140eb2e7ef864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9697778e3004e9c765c475b37f8eb4be" id="r_a9697778e3004e9c765c475b37f8eb4be"><td class="memItemLeft" align="right" valign="top"><a id="a9697778e3004e9c765c475b37f8eb4be" name="a9697778e3004e9c765c475b37f8eb4be"></a>
<a class="el" href="classunodb_1_1detail_1_1qsbr__epoch.html">detail::qsbr_epoch</a>&#160;</td><td class="memItemRight" valign="bottom"><b>last_seen_epoch</b></td></tr>
<tr class="memdesc:a9697778e3004e9c765c475b37f8eb4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last seen global epoch by any operation for this thread. <br /></td></tr>
<tr class="separator:a9697778e3004e9c765c475b37f8eb4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067c56d3356e016deec77387eb03da95" id="r_a067c56d3356e016deec77387eb03da95"><td class="memItemLeft" align="right" valign="top"><a id="a067c56d3356e016deec77387eb03da95" name="a067c56d3356e016deec77387eb03da95"></a>
<a class="el" href="namespaceunodb_1_1detail.html#a3c98952bb0651c3bd50ab5de879cfeff">detail::dealloc_request_vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>previous_interval_dealloc_requests</b></td></tr>
<tr class="memdesc:a067c56d3356e016deec77387eb03da95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pending deallocation requests for the previous epoch. <br /></td></tr>
<tr class="separator:a067c56d3356e016deec77387eb03da95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7557ea586b33893b1bd9f4aa5581d391" id="r_a7557ea586b33893b1bd9f4aa5581d391"><td class="memItemLeft" align="right" valign="top"><a id="a7557ea586b33893b1bd9f4aa5581d391" name="a7557ea586b33893b1bd9f4aa5581d391"></a>
<a class="el" href="namespaceunodb_1_1detail.html#a3c98952bb0651c3bd50ab5de879cfeff">detail::dealloc_request_vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>current_interval_dealloc_requests</b></td></tr>
<tr class="memdesc:a7557ea586b33893b1bd9f4aa5581d391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pending deallocation requests for the current epoch. <br /></td></tr>
<tr class="separator:a7557ea586b33893b1bd9f4aa5581d391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc38b62224e729fdab0988048626df7" id="r_a6fc38b62224e729fdab0988048626df7"><td class="memItemLeft" align="right" valign="top"><a id="a6fc38b62224e729fdab0988048626df7" name="a6fc38b62224e729fdab0988048626df7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>paused</b> {false}</td></tr>
<tr class="memdesc:a6fc38b62224e729fdab0988048626df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether QSBR participation is currently paused for this thread. <br /></td></tr>
<tr class="separator:a6fc38b62224e729fdab0988048626df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae651fad1c94f8ddec93282ea769d0d3f" id="r_ae651fad1c94f8ddec93282ea769d0d3f"><td class="memItemLeft" align="right" valign="top"><a id="ae651fad1c94f8ddec93282ea769d0d3f" name="ae651fad1c94f8ddec93282ea769d0d3f"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>current_interval_total_dealloc_size</b> {0}</td></tr>
<tr class="memdesc:ae651fad1c94f8ddec93282ea769d0d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total size of memory that was submitted for deallocation in the current epoch. <br /></td></tr>
<tr class="separator:ae651fad1c94f8ddec93282ea769d0d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c5dbbe490a2583f5cc647d2f999afa" id="r_a55c5dbbe490a2583f5cc647d2f999afa"><td class="memItemLeft" align="right" valign="top"><a id="a55c5dbbe490a2583f5cc647d2f999afa" name="a55c5dbbe490a2583f5cc647d2f999afa"></a>
std::unordered_multiset&lt; const void * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>active_ptrs</b></td></tr>
<tr class="memdesc:a55c5dbbe490a2583f5cc647d2f999afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of active pointers to QSBR-managed data held by this thread. <br /></td></tr>
<tr class="separator:a55c5dbbe490a2583f5cc647d2f999afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-attribs" name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a6e459784b1c15eedee7aace0729d4d4c" id="r_a6e459784b1c15eedee7aace0729d4d4c"><td class="memItemLeft" align="right" valign="top"><a id="a6e459784b1c15eedee7aace0729d4d4c" name="a6e459784b1c15eedee7aace0729d4d4c"></a>
static thread_local std::unique_ptr&lt; <a class="el" href="classunodb_1_1qsbr__per__thread.html">qsbr_per_thread</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>current_thread_instance</b></td></tr>
<tr class="memdesc:a6e459784b1c15eedee7aace0729d4d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The thread-local QSBR instance. <br /></td></tr>
<tr class="separator:a6e459784b1c15eedee7aace0729d4d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ab3ca2a8465951cd7d4da8a212db6c8d1" id="r_ab3ca2a8465951cd7d4da8a212db6c8d1"><td class="memItemLeft" align="right" valign="top"><a id="ab3ca2a8465951cd7d4da8a212db6c8d1" name="ab3ca2a8465951cd7d4da8a212db6c8d1"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>qsbr</b></td></tr>
<tr class="separator:ab3ca2a8465951cd7d4da8a212db6c8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6a820d833727fa15dfe8e33fe6c21d" id="r_abb6a820d833727fa15dfe8e33fe6c21d"><td class="memItemLeft" align="right" valign="top"><a id="abb6a820d833727fa15dfe8e33fe6c21d" name="abb6a820d833727fa15dfe8e33fe6c21d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>qsbr_thread</b></td></tr>
<tr class="separator:abb6a820d833727fa15dfe8e33fe6c21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79183a0d1fc67a6430ce1b8e7bb890e" id="r_af79183a0d1fc67a6430ce1b8e7bb890e"><td class="memItemLeft" align="right" valign="top"><a id="af79183a0d1fc67a6430ce1b8e7bb890e" name="af79183a0d1fc67a6430ce1b8e7bb890e"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>detail::set_qsbr_per_thread_in_main_thread</b></td></tr>
<tr class="separator:af79183a0d1fc67a6430ce1b8e7bb890e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0665641e11efcb2ef47493202c85f38c" id="r_a0665641e11efcb2ef47493202c85f38c"><td class="memItemLeft" align="right" valign="top"><a id="a0665641e11efcb2ef47493202c85f38c" name="a0665641e11efcb2ef47493202c85f38c"></a>
<a class="el" href="classunodb_1_1qsbr__per__thread.html">qsbr_per_thread</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>this_thread</b> () noexcept</td></tr>
<tr class="separator:a0665641e11efcb2ef47493202c85f38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Thread-local QSBR data structure. </p>
<p>Maintains pending deallocation requests for the previous and current epoch, tracks the last seen global epoch by any operation, and the last seen global epoch by a quiescent state for this thread.</p>
<p>Also owns the preallocated list nodes for orphaning pending previous and current interval deallocation requests on thread exit. Having them preallocated avoids heap allocations on thread exit code path, where handling any allocation failures is hard. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ae8ed6c0ce29e48f1fc70a5e3e94cd25f" name="ae8ed6c0ce29e48f1fc70a5e3e94cd25f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ed6c0ce29e48f1fc70a5e3e94cd25f">&#9670;&#160;</a></span>advance_last_seen_epoch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void unodb::qsbr_per_thread::advance_last_seen_epoch </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>single_thread_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunodb_1_1detail_1_1qsbr__epoch.html">detail::qsbr_epoch</a>&#160;</td>
          <td class="paramname"><em>new_seen_epoch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceunodb_1_1detail.html#a3c98952bb0651c3bd50ab5de879cfeff">detail::dealloc_request_vector</a>&#160;</td>
          <td class="paramname"><em>new_current_requests</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update this thread's view of the current epoch and execute the previous interval deallocation requests if a newer epoch is seen. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">single_thread_mode</td><td>Whether QSBR is in single-thread mode </td></tr>
    <tr><td class="paramname">new_seen_epoch</td><td>The new epoch to advance to </td></tr>
    <tr><td class="paramname">new_current_requests</td><td>Deallocation requests for the current epoch </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88e9830fbe4868759b676fc091cabf0f" name="a88e9830fbe4868759b676fc091cabf0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e9830fbe4868759b676fc091cabf0f">&#9670;&#160;</a></span>on_next_epoch_deallocate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void unodb::qsbr_per_thread::on_next_epoch_deallocate </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structunodb_1_1detail_1_1deallocation__request.html#a091c0981dcaefa926b631259f83f190c">detail::deallocation_request::debug_callback</a>&#160;</td>
          <td class="paramname"><em>dealloc_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request deallocation of <em>pointer</em> when it is safe to do so. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer</td><td>Memory to deallocate </td></tr>
    <tr><td class="paramname">size</td><td>Size of the memory, for statistics </td></tr>
    <tr><td class="paramname">dealloc_callback</td><td>Debug callback to execute during deallocation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19cd835a80932eac2270d84fbd3cf98b" name="a19cd835a80932eac2270d84fbd3cf98b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19cd835a80932eac2270d84fbd3cf98b">&#9670;&#160;</a></span>qsbr_pause()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void unodb::qsbr_per_thread::qsbr_pause </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pause QSBR for this thread, unregistering from global QSBR. </p>
<dl class="section pre"><dt>Precondition</dt><dd>No active pointers to QSBR-managed data must be held. </dd>
<dd>
QSBR must not be paused for this thread. </dd></dl>

</div>
</div>
<a id="aa3d30dde1b08b22f8a2bc5f1677cf024" name="aa3d30dde1b08b22f8a2bc5f1677cf024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d30dde1b08b22f8a2bc5f1677cf024">&#9670;&#160;</a></span>qsbr_resume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void unodb::qsbr_per_thread::qsbr_resume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resume QSBR for this thread, registering with global QSBR. </p>
<dl class="section pre"><dt>Precondition</dt><dd>QSBR must be paused for this thread. </dd></dl>

</div>
</div>
<a id="ac26eeb41f72fcf9f6753ec95d8f1cb99" name="ac26eeb41f72fcf9f6753ec95d8f1cb99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26eeb41f72fcf9f6753ec95d8f1cb99">&#9670;&#160;</a></span>quiescent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void unodb::qsbr_per_thread::quiescent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signal that this thread is quiescent. </p>
<dl class="section pre"><dt>Precondition</dt><dd>No active pointers to QSBR-managed data must be held. </dd></dl>

</div>
</div>
<a id="ae39c9b13610c71dce1e166a874a4b194" name="ae39c9b13610c71dce1e166a874a4b194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae39c9b13610c71dce1e166a874a4b194">&#9670;&#160;</a></span>register_active_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unodb::qsbr_per_thread::register_active_ptr </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an active pointer <em>ptr</em> to QSBR-managed data in this thread. </p>
<dl class="section note"><dt>Note</dt><dd>Do not call directly: use <a class="el" href="classunodb_1_1qsbr__ptr.html" title="Raw pointer-like smart pointer to QSBR-managed shared data.">unodb::qsbr_ptr</a> instead. </dd></dl>

</div>
</div>
<a id="a5983279bf3dbf1c42a4d86cab81869f2" name="a5983279bf3dbf1c42a4d86cab81869f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5983279bf3dbf1c42a4d86cab81869f2">&#9670;&#160;</a></span>unregister_active_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unodb::qsbr_per_thread::unregister_active_ptr </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister an active pointer <em>ptr</em> to QSBR-managed data in this thread. </p>
<dl class="section note"><dt>Note</dt><dd>Do not call directly: use <a class="el" href="classunodb_1_1qsbr__ptr.html" title="Raw pointer-like smart pointer to QSBR-managed shared data.">unodb::qsbr_ptr</a> instead. </dd></dl>

</div>
</div>
<a id="a31f84e25a40dffd8dc13c73613634053" name="a31f84e25a40dffd8dc13c73613634053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f84e25a40dffd8dc13c73613634053">&#9670;&#160;</a></span>update_requests()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void unodb::qsbr_per_thread::update_requests </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>single_thread_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunodb_1_1detail_1_1qsbr__epoch.html">detail::qsbr_epoch</a>&#160;</td>
          <td class="paramname"><em>dealloc_epoch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceunodb_1_1detail.html#a3c98952bb0651c3bd50ab5de879cfeff">detail::dealloc_request_vector</a>&#160;</td>
          <td class="paramname"><em>new_current_requests</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute the previous interval deallocation requests and move the current interval ones to the previous interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">single_thread_mode</td><td>Whether QSBR is in single-thread mode </td></tr>
    <tr><td class="paramname">dealloc_epoch</td><td>Deallocation epoch </td></tr>
    <tr><td class="paramname">new_current_requests</td><td>New deallocation requests for the current epoch </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="qsbr_8hpp_source.html">qsbr.hpp</a></li>
<li><b>qsbr.cpp</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceunodb.html">unodb</a></li><li class="navelem"><a class="el" href="classunodb_1_1qsbr__per__thread.html">qsbr_per_thread</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
