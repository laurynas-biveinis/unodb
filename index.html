<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UnoDB: UnoDB</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">UnoDB
   </div>
   <div id="projectbrief">Adaptive Radix Tree in C++, optionally with Optimistic Lock Coupling</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">UnoDB </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a></p>
<h1><a class="anchor" id="autotoc_md23"></a>
unodb</h1>
<p><a href="https://github.com/laurynas-biveinis/unodb/actions?query=workflow%3Abuild"><img src="https://github.com/laurynas-biveinis/unodb/workflows/build/badge.svg" alt="Github Actions Build Status" style="pointer-events: none;" class="inline"/></a> <a href="https://codecov.io/gh/laurynas-biveinis/unodb"><img src="https://codecov.io/gh/laurynas-biveinis/unodb/branch/master/graph/badge.svg" alt="codecov" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/marketplace/actions/super-linter"><img src="https://github.com/laurynas-biveinis/unodb/workflows/Super-Linter/badge.svg" alt="GitHub Super-Linter" style="pointer-events: none;" class="inline"/></a> <a href="https://sonarcloud.io/dashboard?id=laurynas-biveinis_unodb"><img src="https://sonarcloud.io/api/project_badges/measure?project=laurynas-biveinis_unodb&amp;metric=alert_status" alt="Quality Gate Status" class="inline"/></a></p>
<h2><a class="anchor" id="autotoc_md24"></a>
Introduction</h2>
<p>UnoDB is a library that implements of Adaptive Radix Tree (ART) data structure, designed for efficient indexing in main-memory databases. The ART is a trie-based data structure that dynamically adapts to the distribution of keys, ensuring good search performance and memory usage. UnoDB offers two variants of ART: a regular one and a concurrent one based on Optimistic Lock Coupling (OLC) with Quiescent State Based Reclamation (QSBR).</p>
<p>This library serves as a playground for experimenting with various C++ tools and ideas. I am describing some of the things I learned at my <a href="https://of-code.blogspot.com/search/label/art">blog</a>.</p>
<h2><a class="anchor" id="autotoc_md25"></a>
Requirements</h2>
<p>UnoDB source code is written in C++20, and relies on the following platform-specific features:</p>
<ul>
<li>On Intel platforms, it requires SSE4.1 intrinsics (Nehalem and higher), AVX for MSVC builds, and optional AVX2 support, when available. This differs from the original ART paper, which only required SSE2.</li>
<li>On ARM, it uses NEON intrinsics.</li>
</ul>
<h3><a class="anchor" id="autotoc_md26"></a>
Build dependencies</h3>
<ul>
<li>Earliest versions of supported compilers: GCC 10, LLVM 11, Xcode 16.1, MSVC 2022. Open an issue if you require support for an older version.</li>
<li>CMake, at least 3.16.</li>
<li>Boost library. If building with statistics counters, then it is a mandatory dependency for Boost.Accumulator. It is also an optional dependency for Boost.Stacktrace.</li>
</ul>
<h3><a class="anchor" id="autotoc_md27"></a>
Optional vendored dependencies, bundled as Git submodules</h3>
<ul>
<li>Google Test for tests.</li>
<li>Google Benchmark for microbenchmarks.</li>
<li><a href="https://github.com/trailofbits/deepstate" title="DeepState on GitHub">DeepState</a> for fuzzing tests.</li>
</ul>
<p>These dependencies need not be present if the build is configured to skip the corresponding part. For example, if the CMake option <code>-DTESTS=OFF</code> is given, then Google Test and DeepState submodules don't have to be populated.</p>
<h2><a class="anchor" id="autotoc_md28"></a>
Building</h2>
<p>Unless you configure your build otherwise, first you need to populate the Git submodules for test and benchmark dependencies:</p>
<div class="fragment"><div class="line"># --recursive is not strictly required at the moment, but a good habit to have</div>
<div class="line">git submodule update --init --recursive</div>
</div><!-- fragment --><p>Out-of-source builds are recommended, for example</p>
<div class="fragment"><div class="line">mkdir build</div>
<div class="line">cd build</div>
<div class="line">cmake .. &lt;other options, see below&gt;</div>
</div><!-- fragment --><p>There are some CMake options for users:</p>
<ul>
<li><code>-DSPINLOCK_LOOP=PAUSE|EMPTY</code> to choose the spinlock wait loop body implementation for the optimistic lock. <code>EMPTY</code> may benchmark better as long as there are fewer threads than available CPU cores. <code>PAUSE</code> will use that instruction on x86_64, and something similar on ARM. The default is <code>PAUSE</code>.</li>
<li><code>-DSTATS=OFF</code> if you want to compile away all the statistics counters. The result will scale better in benchmarks. The current stats implementation is global cache line-padded shared atomic counters. This option might be removed in the future if the stats are reimplemented with less overhead.</li>
<li><code>-DWITH_AVX2=OFF</code> to disable AVX2 intrinsics to use SSE4.1/AVX only.</li>
<li><code>-DTESTS=OFF</code> to skip building the tests.</li>
<li><code>-DBENCHMARKS=ON</code> to build the benchmarks.</li>
</ul>
<p>There are other CMake options that are mainly intended for UnoDB development itself and are discussed in <a class="el" href="md_CONTRIBUTING.html">CONTRIBUTING.md</a>.</p>
<h2><a class="anchor" id="autotoc_md29"></a>
Platform-Specific Notes</h2>
<h3><a class="anchor" id="autotoc_md30"></a>
Ubuntu 22.04</h3>
<div class="fragment"><div class="line"># libc6-dev-i386 is for DeepState</div>
<div class="line">sudo apt-get install -y libboost-dev libc6-dev-i386</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31"></a>
Amazon Linux 2023</h3>
<div class="fragment"><div class="line">sudo dnf install git gcc g++ cmake boost-devel</div>
<div class="line"># Optional, if you want to use Boost.Stacktrace:</div>
<div class="line">git clone https://github.com/ianlancetaylor/libbacktrace</div>
<div class="line">(cd libbacktrace &amp;&amp; ./configure &amp;&amp; make &amp;&amp; sudo make install)</div>
<div class="line"># Build as usual</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md32"></a>
Amazon Linux 2</h3>
<div class="fragment"><div class="line">sudo yum install git gcc10 gcc10-c++ cmake3 boost-devel</div>
<div class="line"># Pass -DCMAKE_C_COMPILER=gcc10-gcc -DCMAKE_CXX_COMPILER=gcc10-c++ to cmake3</div>
<div class="line">#</div>
<div class="line"># Benchmarking. For jemalloc, consider building a newer version from source.</div>
<div class="line">sudo amazon-linux-extras install -y epel</div>
<div class="line">sudo yum install jemalloc perf</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md33"></a>
Usage</h2>
<p>See <code>examples/</code> directory for simple usage examples. This directory is a top-level CMake project.</p>
<p>All the declarations live in the <code>unodb</code> namespace, which is omitted in the descriptions below.</p>
<p>The key type is a template argument for the <code><a class="el" href="classunodb_1_1db.html" title="A non-thread-safe implementation of the Adaptive Radix Tree (ART).">unodb::db</a></code> classes. In general, the library supports both integral keys (though only <code>std::uint64_t</code> is tested at this time) and variable length keys (using <code><a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90" title="Non-owning view of key bytes, copied into index upon insertion.">unodb::key_view</a></code> as the key type). Variable length keys are supported using the <code><a class="el" href="classunodb_1_1key__encoder.html" title="A utility class to generate binary comparable keys from a sequence of key components.">unodb::key_encoder</a></code> and <code><a class="el" href="classunodb_1_1key__decoder.html" title="A utility class for decoding binary comparable keys produced by unodb::key_encoder,...">unodb::key_decoder</a></code>. The <code><a class="el" href="classunodb_1_1key__encoder.html" title="A utility class to generate binary comparable keys from a sequence of key components.">unodb::key_encoder</a></code> is responsible for making encoded keys which obey lexicographic ordering and handles various signed and unsigned types, floating point, types, and text. The <code><a class="el" href="classunodb_1_1key__encoder.html" title="A utility class to generate binary comparable keys from a sequence of key components.">unodb::key_encoder</a></code> MUST be used for text data (including Unicode sort keys) and for compound keys (keys consisting of multiple components). The ART data structure has a restriction that no full length key may be a prefix of another key. This restriction is trivially satisified for any fixed width key. Also per the ART paper, the <code><a class="el" href="classunodb_1_1key__encoder.html" title="A utility class to generate binary comparable keys from a sequence of key components.">unodb::key_encoder</a></code> maintains this contract for text keys by truncating them to not more than <code><a class="el" href="classunodb_1_1key__encoder.html#ae0d432f6de285a4384378a8bc7c0fba2" title="The maximum length of a text component of the key.">unodb::key_encoder::maxlen</a></code> bytes and then logically padding them out (with a run length counter) to <code><a class="el" href="classunodb_1_1key__encoder.html#ae0d432f6de285a4384378a8bc7c0fba2" title="The maximum length of a text component of the key.">unodb::key_encoder::maxlen</a></code>. Unicode data SHOULD be converted by the caller using a quality library (e.g., ICU) to Unicode sort keys which capture the desired collation order, and those sort keys then passed to the <code><a class="el" href="classunodb_1_1key__encoder.html" title="A utility class to generate binary comparable keys from a sequence of key components.">unodb::key_encoder</a></code>. Finally, the <code><a class="el" href="classunodb_1_1key__decoder.html" title="A utility class for decoding binary comparable keys produced by unodb::key_encoder,...">unodb::key_decoder</a></code> may be used to decode signed and unsigned integral types and floating point types. Note that all NaNs are mapped to a canonical NaN during encoding, so decode of NaN always returns that canonical value. Decode of Unicode sort keys is not possible due to the transformation to generate the sort key. Decode of other text can run into the truncation and run length padding artifacts and is not supported. When ART is used as a secondary index, the caller stores the record identifier (or record pointer) as the values in the tree. The original text can then be recovered from the source record.</p>
<p>Values are treated opaquely. For <code><a class="el" href="classunodb_1_1db.html" title="A non-thread-safe implementation of the Adaptive Radix Tree (ART).">unodb::db</a></code>, they are passed as non-owning objects of <code>value_view</code> (a <code>std::span&lt;std::byte&gt;</code>), and insertion copies them internally. The same applies for <code>get</code>, which returns a non-owning <code>value_view</code>. For <code><a class="el" href="classunodb_1_1olc__db.html" title="A thread-safe Adaptive Radix Tree that is synchronized using optimistic lock coupling.">unodb::olc_db</a></code>, <code>get</code> returns a <code>qsbr_value_view</code>, a <code>span</code> guaranteed to remain valid until the current thread passes through a quiescent state.</p>
<p>All ART classes share the same API:</p>
<ul>
<li>constructor.</li>
<li><code>get(key k)</code> returns <code>get_result</code> (a <code>std::optional&lt;value_view&gt;</code>).</li>
<li><code>bool insert(key k, value_view v)</code> returns whether the insert was successful (i.e. the key was not already present).</li>
<li><code>bool remove(key k)</code> returns whether delete was successful (i.e. the key was found in the tree).</li>
<li><code>clear()</code> empties the tree. For <code>olc_db</code>, it must be called from a single-threaded context.</li>
<li><code>bool empty()</code> returns whether the tree is empty.</li>
<li><code>template &lt;FN&gt; scan(), scan_from(...), scan_range()</code> a family of scan methods, including forward and reverse scans and scans with a from_key and an exclusive upper bound to_key where fn is a lambda accepting a visitor and returning a bool indicating whether the scan should halt (bool halt). See <code>examples/examples_art.cpp</code>.</li>
<li><code>void dump(std::ostream &amp;)</code> outputs the tree representation.</li>
<li>Several getters provide tree info, such as current memory use, and internal operation counters (e.g. number of times Node4 grew to Node16, key prefix was split, etc - see the source code for details).</li>
</ul>
<p>Three ART classes available:</p>
<ul>
<li><code>db</code>: unsychronized ART tree, for single-thread contexts or with external synchronization</li>
<li><code>mutex_db</code>: ART tree with single global mutex synchronization</li>
<li><code>olc_db</code>: a concurrent ART tree, implementing Optimistic Lock Coupling as described in "The ART of Practical Synchronization" paper by Leis et al.; nodes are versioned, writers lock per-node optimistic locks, readers don't lock but check node versions and restart if they change.</li>
</ul>
<p>The full source code reference, including public API, is available at <a href="https://docs.unodb.dev">https://docs.unodb.dev</a> (work in progress).</p>
<p>Do not use macros starting with <code>UNODB_DETAIL_</code> or declarations in <code><a class="el" href="namespaceunodb_1_1detail.html" title="Namespace for the UnoDB internal implementation details.">unodb::detail</a></code> and <code>unob::test</code> namespaces as they are internal and may change at any time.</p>
<h2><a class="anchor" id="autotoc_md34"></a>
Technical Details</h2>
<h3><a class="anchor" id="autotoc_md35"></a>
Adaptive Radix Tree</h3>
<p>The implementation follows the paper description closely, with the following differences and design choices:</p>
<ul>
<li>The paper algorithms are specified in SSE2 intrinsics. This implementation has SSE4.1 as the minimal level, and AVX2 as the default one on Intel. On ARM, NEON is used.</li>
<li>Different ways to implement leaf nodes are discussed in the paper (single-value leaves, multi-value leaves, and combined pointer/value slots). Here single-value leaves are implemented.</li>
<li>The paper discusses different choices in implementing search key path compression. Here the pessimistic path compression is implemented, with up to 7 bytes of key data per internal node.</li>
</ul>
<h3><a class="anchor" id="autotoc_md36"></a>
Sequential Lock</h3>
<p>The optimistic lock concept seems to be nearly identical to that of <a href="https://en.wikipedia.org/wiki/Seqlock">sequential locks</a> as used in the Linux kernel, with the addition of "obsolete" state. The lock implementation uses the seqlock memory model implementation as described by Boehm in "Can seqlocks get along with programming language memory
models?" 2012 paper.</p>
<h3><a class="anchor" id="autotoc_md37"></a>
Quiescent State-Based Reclamation (QSBR)</h3>
<p>The OLC ART implementation necessitates a memory reclamation scheme as required by lock-free data structures (even though <code>olc_db</code> is not lock-free in the general sense, the readers do not take locks), and for that a Quiescent State Based Reclamation (QSBR) was chosen. In QSBR, each thread periodically announces that it is not using any pointers to a shared data structures. After all the threads have done so, a new epoch starts, and the memory reclamation requests from two epochs ago are executed. To participate in QSBR, a thread must an instance of <code><a class="el" href="classunodb_1_1qsbr__thread.html" title="An std::thread-like thread that participates in QSBR.">unodb::qsbr_thread</a></code>, which derives from <code>std::thread</code>. A thread may temporarily or permanently stop its participation in QSBR by calling <code><a class="el" href="namespaceunodb.html#af67bb57e59d46aae6ffb5103dcb497a1" title="Get the thread-local QSBR instance.">unodb::this_thread()</a>.qsbr_pause()</code> and resume by calling <code><a class="el" href="namespaceunodb.html#af67bb57e59d46aae6ffb5103dcb497a1" title="Get the thread-local QSBR instance.">unodb::this_thread()</a>.qsbr_resume()</code>.</p>
<p>The registered threads must periodically signal their quiescent states. They can do this by using the <code><a class="el" href="structunodb_1_1quiescent__state__on__scope__exit.html" title="RAII guard that signals quiescent state for this thread on destruction.">unodb::quiescent_state_on_scope_exit</a></code> scope guard, which automatically reports the quiescent state when the scope is exited.</p>
<h2><a class="anchor" id="autotoc_md38"></a>
Related Projects</h2>
<p><a href="https://github.com/justinasvd/art_map">art_map</a> is a C++14 template library providing <code>std::</code>-like interface over the ART data structure. It shares some code with UnoDB.</p>
<h2><a class="anchor" id="autotoc_md39"></a>
Contributing</h2>
<p>Please see <a class="el" href="md_CONTRIBUTING.html">CONTRIBUTING.md</a>.</p>
<h2><a class="anchor" id="autotoc_md40"></a>
Literature</h2>
<p><em>ART Trie</em>: V. Leis, A. Kemper and T. Neumann, "The adaptive radix tree: ARTful
indexing for main-memory databases," 2013 29th IEEE International Conference on Data Engineering (ICDE 2013)(ICDE), Brisbane, QLD, 2013, pp. 38-49. doi:10.1109/ICDE.2013.6544812</p>
<p><em>ART Sync</em>: V. Leis, F. Schneiber, A. Kemper and T. Neumann, "The ART of
Practical Synchronization," 2016 Proceedings of the 12th International Workshop on Data Management on New Hardware (DaMoN), pages 3:1&ndash;3:8, 2016.</p>
<p><em>qsbr</em>: P. E. McKenney, J. D. Slingwine, "Read-copy update: using execution
history to solve concurrency problems," Parallel and Distributed Computing and Systems, 1998, pages 509&ndash;518.</p>
<p><em>seqlock sync</em>: H-J. Boehm, "Can seqlocks get along with programming language
memory models?," Proceedings of the 2012 ACM SIGPLAN Workshop on Memory Systems Performance and Correctness, June 2012, pages 12&ndash;21, 2012. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
