<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UnoDB: unodb::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">UnoDB
   </div>
   <div id="projectbrief">Adaptive Radix Tree in C++, optionally with Optimistic Lock Coupling</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceunodb_1_1detail.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">unodb::detail Namespace Reference<div class="ingroups"><a class="el" href="group__internal.html">Internals</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Namespace for the UnoDB internal implementation details.  
<a href="namespaceunodb_1_1detail.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">basic_art_key</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal ART key in binary-comparable format.  <a href="structunodb_1_1detail_1_1basic__art__key.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">basic_art_policy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1basic__db__inode__deleter.html">basic_db_inode_deleter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1basic__db__leaf__deleter.html">basic_db_leaf_deleter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1basic__inode.html">basic_inode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The last common ancestor (both for templates and inheritance) for all inode types for both OLC and regular.  <a href="classunodb_1_1detail_1_1basic__inode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1basic__inode__16.html">basic_inode_16</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1basic__inode__256.html">basic_inode_256</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1basic__inode__4.html">basic_inode_4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An internal node with up to 4 children.  <a href="classunodb_1_1detail_1_1basic__inode__4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1basic__inode__48.html">basic_inode_48</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1basic__inode__def.html">basic_inode_def</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1basic__inode__impl.html">basic_inode_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template class extending the common header and defining some methods common to all internal node types.  <a href="classunodb_1_1detail_1_1basic__inode__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1basic__leaf.html">basic_leaf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classunodb_1_1detail_1_1basic__leaf.html" title="The basic_leaf handles most of the behavior of a leaf in the index.">basic_leaf</a> handles most of the behavior of a leaf in the index.  <a href="classunodb_1_1detail_1_1basic__leaf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1basic__node__ptr.html">basic_node_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classunodb_1_1detail_1_1basic__node__ptr.html" title="basic_node_ptr is a tagged pointer (the tag is the node type).">basic_node_ptr</a> is a tagged pointer (the tag is the node type).  <a href="classunodb_1_1detail_1_1basic__node__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1db__inode__qsbr__deleter.html">db_inode_qsbr_deleter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1db__leaf__qsbr__deleter.html">db_leaf_qsbr_deleter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1dealloc__vector__list__node.html">dealloc_vector_list_node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node in a linked list for orphaned (issued by threads that have quit since) deallocation requests.  <a href="structunodb_1_1detail_1_1dealloc__vector__list__node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1deallocation__request.html">deallocation_request</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pending deallocation request for QSBR-managed memory.  <a href="classunodb_1_1detail_1_1deallocation__request.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1deferred__requests.html">deferred_requests</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A scope guard that executes deallocation requests upon destruction.  <a href="classunodb_1_1detail_1_1deferred__requests.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1dependent__false.html">dependent_false</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1fake__inode.html">fake_inode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class used as a sentinel for <a class="el" href="classunodb_1_1detail_1_1basic__inode.html" title="The last common ancestor (both for templates and inheritance) for all inode types for both OLC and re...">unodb::detail::basic_inode</a> template args: the larger node type for the largest node type and the smaller node type for the smallest node type.  <a href="classunodb_1_1detail_1_1fake__inode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1impl__helpers.html">impl_helpers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1inode.html">inode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1inode__16.html">inode_16</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1inode__256.html">inode_256</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1inode__4.html">inode_4</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1inode__48.html">inode_48</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1iter__result.html">iter_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct that is returned by the iterator visitation pattern which represents a path in the tree for an internal node.  <a href="structunodb_1_1detail_1_1iter__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1key__buffer.html">key_buffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionunodb_1_1detail_1_1key__prefix.html">key_prefix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="unionunodb_1_1detail_1_1key__prefix.html" title="The unodb::detail::key_prefix is a sequence of zero or more bytes for a given node that are a common ...">unodb::detail::key_prefix</a> is a sequence of zero or more bytes for a given node that are a common prefix shared by all children of that node and supports prefix compression in the index.  <a href="unionunodb_1_1detail_1_1key__prefix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionunodb_1_1detail_1_1key__prefix__snapshot.html">key_prefix_snapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class used to expose a consistent snapshot of the <a class="el" href="unionunodb_1_1detail_1_1key__prefix.html" title="The unodb::detail::key_prefix is a sequence of zero or more bytes for a given node that are a common ...">unodb::detail::key_prefix</a> to the iterator for use in tracking the data on the iterator's stack.  <a href="unionunodb_1_1detail_1_1key__prefix__snapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1node__header.html">node_header</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1olc__impl__helpers.html">olc_impl_helpers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1olc__inode.html">olc_inode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1olc__inode__16.html">olc_inode_16</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1olc__inode__256.html">olc_inode_256</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1olc__inode__4.html">olc_inode_4</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1olc__inode__48.html">olc_inode_48</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1olc__node__header.html">olc_node_header</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1qsbr__epoch.html">qsbr_epoch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two-bit wrapping-around QSBR epoch counter.  <a href="classunodb_1_1detail_1_1qsbr__epoch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1qsbr__ptr__base.html">qsbr_ptr_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for QSBR pointers that provides per-thread active pointer registration functionality in debug builds.  <a href="classunodb_1_1detail_1_1qsbr__ptr__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1set__qsbr__per__thread__in__main__thread.html">set_qsbr_per_thread_in_main_thread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for registering the main thread with QSBR.  <a href="structunodb_1_1detail_1_1set__qsbr__per__thread__in__main__thread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1thread__sync.html">thread_sync</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple one-way synchronization mechanism to make one thread wait until another one signals it.  <a href="classunodb_1_1detail_1_1thread__sync.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1tree__depth.html">tree_depth</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typed class representing the number of key bytes consumed along some path in the tree.  <a href="classunodb_1_1detail_1_1tree__depth.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aaa98550b35b9c4011a17dd6d7f96f25a" id="r_aaa98550b35b9c4011a17dd6d7f96f25a"><td class="memItemLeft" align="right" valign="top"><a id="aaa98550b35b9c4011a17dd6d7f96f25a" name="aaa98550b35b9c4011a17dd6d7f96f25a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>node_ptr</b> = <a class="el" href="classunodb_1_1detail_1_1basic__node__ptr.html">basic_node_ptr</a>&lt; <a class="el" href="structunodb_1_1detail_1_1node__header.html">node_header</a> &gt;</td></tr>
<tr class="separator:aaa98550b35b9c4011a17dd6d7f96f25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0155f4cc9c31cf3cc24939b69c13d0" id="r_a6e0155f4cc9c31cf3cc24939b69c13d0"><td class="memTemplParams" colspan="2"><a id="a6e0155f4cc9c31cf3cc24939b69c13d0" name="a6e0155f4cc9c31cf3cc24939b69c13d0"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a6e0155f4cc9c31cf3cc24939b69c13d0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inode_defs</b> = <a class="el" href="structunodb_1_1detail_1_1basic__inode__def.html">basic_inode_def</a>&lt; <a class="el" href="classunodb_1_1detail_1_1inode.html">inode</a>&lt; Key, Value &gt;, <a class="el" href="classunodb_1_1detail_1_1inode__4.html">inode_4</a>&lt; Key, Value &gt;, <a class="el" href="classunodb_1_1detail_1_1inode__16.html">inode_16</a>&lt; Key, Value &gt;, <a class="el" href="classunodb_1_1detail_1_1inode__48.html">inode_48</a>&lt; Key, Value &gt;, <a class="el" href="classunodb_1_1detail_1_1inode__256.html">inode_256</a>&lt; Key, Value &gt; &gt;</td></tr>
<tr class="separator:a6e0155f4cc9c31cf3cc24939b69c13d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753ebc8c67b98f4101febd827ccb76a4" id="r_a753ebc8c67b98f4101febd827ccb76a4"><td class="memTemplParams" colspan="2"><a id="a753ebc8c67b98f4101febd827ccb76a4" name="a753ebc8c67b98f4101febd827ccb76a4"></a>
template&lt;typename Key , typename Value , class INode &gt; </td></tr>
<tr class="memitem:a753ebc8c67b98f4101febd827ccb76a4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>db_inode_deleter</b> = <a class="el" href="classunodb_1_1detail_1_1basic__db__inode__deleter.html">basic_db_inode_deleter</a>&lt; INode, <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt; &gt;</td></tr>
<tr class="separator:a753ebc8c67b98f4101febd827ccb76a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf36d7f939b56845e7334c790d07195" id="r_aedf36d7f939b56845e7334c790d07195"><td class="memTemplParams" colspan="2"><a id="aedf36d7f939b56845e7334c790d07195" name="aedf36d7f939b56845e7334c790d07195"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:aedf36d7f939b56845e7334c790d07195"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>art_policy</b> = <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">basic_art_policy</a>&lt; Key, Value, <a class="el" href="classunodb_1_1db.html">unodb::db</a>, <a class="el" href="classunodb_1_1in__fake__critical__section.html">unodb::in_fake_critical_section</a>, <a class="el" href="classunodb_1_1fake__lock.html">unodb::fake_lock</a>, <a class="el" href="classunodb_1_1fake__read__critical__section.html">unodb::fake_read_critical_section</a>, <a class="el" href="classunodb_1_1detail_1_1basic__node__ptr.html">node_ptr</a>, <a class="el" href="structunodb_1_1detail_1_1basic__inode__def.html">inode_defs</a>, <a class="el" href="classunodb_1_1detail_1_1basic__db__inode__deleter.html">db_inode_deleter</a>, <a class="el" href="classunodb_1_1detail_1_1basic__db__leaf__deleter.html">basic_db_leaf_deleter</a> &gt;</td></tr>
<tr class="separator:aedf36d7f939b56845e7334c790d07195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af486b3ba28a2f7e238e2db1946e3b8fb" id="r_af486b3ba28a2f7e238e2db1946e3b8fb"><td class="memTemplParams" colspan="2"><a id="af486b3ba28a2f7e238e2db1946e3b8fb" name="af486b3ba28a2f7e238e2db1946e3b8fb"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:af486b3ba28a2f7e238e2db1946e3b8fb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inode_base</b> = <a class="el" href="classunodb_1_1detail_1_1basic__inode__impl.html">basic_inode_impl</a>&lt; <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">art_policy</a>&lt; Key, Value &gt; &gt;</td></tr>
<tr class="separator:af486b3ba28a2f7e238e2db1946e3b8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab561be018ef4d04aa8a144bb388b721" id="r_aab561be018ef4d04aa8a144bb388b721"><td class="memTemplParams" colspan="2"><a id="aab561be018ef4d04aa8a144bb388b721" name="aab561be018ef4d04aa8a144bb388b721"></a>
template&lt;typename Key &gt; </td></tr>
<tr class="memitem:aab561be018ef4d04aa8a144bb388b721"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>leaf_type</b> = <a class="el" href="classunodb_1_1detail_1_1basic__leaf.html">basic_leaf</a>&lt; Key, <a class="el" href="structunodb_1_1detail_1_1node__header.html">node_header</a> &gt;</td></tr>
<tr class="separator:aab561be018ef4d04aa8a144bb388b721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459acb52e40ddfb61e83d1fd213c49b1" id="r_a459acb52e40ddfb61e83d1fd213c49b1"><td class="memTemplParams" colspan="2"><a id="a459acb52e40ddfb61e83d1fd213c49b1" name="a459acb52e40ddfb61e83d1fd213c49b1"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a459acb52e40ddfb61e83d1fd213c49b1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inode_4_parent</b> = <a class="el" href="classunodb_1_1detail_1_1basic__inode__4.html">basic_inode_4</a>&lt; <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">art_policy</a>&lt; Key, Value &gt; &gt;</td></tr>
<tr class="separator:a459acb52e40ddfb61e83d1fd213c49b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968066c430fa50f96fb3d07081ec4248" id="r_a968066c430fa50f96fb3d07081ec4248"><td class="memItemLeft" align="right" valign="top"><a id="a968066c430fa50f96fb3d07081ec4248" name="a968066c430fa50f96fb3d07081ec4248"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>inode_4_test_type</b> = <a class="el" href="classunodb_1_1detail_1_1inode__4.html">inode_4</a>&lt; std::uint64_t, <a class="el" href="namespaceunodb.html#ae25127f715f2aac269da8a3616284c0b">unodb::value_view</a> &gt;</td></tr>
<tr class="separator:a968066c430fa50f96fb3d07081ec4248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6444efb5500aedbc0fa283f4a4792b" id="r_a9a6444efb5500aedbc0fa283f4a4792b"><td class="memTemplParams" colspan="2"><a id="a9a6444efb5500aedbc0fa283f4a4792b" name="a9a6444efb5500aedbc0fa283f4a4792b"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a9a6444efb5500aedbc0fa283f4a4792b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inode_16_parent</b> = <a class="el" href="classunodb_1_1detail_1_1basic__inode__16.html">basic_inode_16</a>&lt; <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">art_policy</a>&lt; Key, Value &gt; &gt;</td></tr>
<tr class="separator:a9a6444efb5500aedbc0fa283f4a4792b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332b76e662f000a6ffd8e4d94c370e7d" id="r_a332b76e662f000a6ffd8e4d94c370e7d"><td class="memTemplParams" colspan="2"><a id="a332b76e662f000a6ffd8e4d94c370e7d" name="a332b76e662f000a6ffd8e4d94c370e7d"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a332b76e662f000a6ffd8e4d94c370e7d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inode_48_parent</b> = <a class="el" href="classunodb_1_1detail_1_1basic__inode__48.html">basic_inode_48</a>&lt; <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">art_policy</a>&lt; Key, Value &gt; &gt;</td></tr>
<tr class="separator:a332b76e662f000a6ffd8e4d94c370e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa12022c4d1f89180ab68508598ba7b3" id="r_aaa12022c4d1f89180ab68508598ba7b3"><td class="memItemLeft" align="right" valign="top"><a id="aaa12022c4d1f89180ab68508598ba7b3" name="aaa12022c4d1f89180ab68508598ba7b3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>inode_48_test_type</b> = <a class="el" href="classunodb_1_1detail_1_1inode__48.html">inode_48</a>&lt; std::uint64_t, <a class="el" href="namespaceunodb.html#ae25127f715f2aac269da8a3616284c0b">unodb::value_view</a> &gt;</td></tr>
<tr class="separator:aaa12022c4d1f89180ab68508598ba7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1290fecb62dd3c992776fb4ea5793e2" id="r_af1290fecb62dd3c992776fb4ea5793e2"><td class="memTemplParams" colspan="2"><a id="af1290fecb62dd3c992776fb4ea5793e2" name="af1290fecb62dd3c992776fb4ea5793e2"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:af1290fecb62dd3c992776fb4ea5793e2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inode_256_parent</b> = <a class="el" href="classunodb_1_1detail_1_1basic__inode__256.html">basic_inode_256</a>&lt; <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">art_policy</a>&lt; Key, Value &gt; &gt;</td></tr>
<tr class="separator:af1290fecb62dd3c992776fb4ea5793e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b1873633c46b13271dcf06ac743666" id="r_a85b1873633c46b13271dcf06ac743666"><td class="memTemplParams" colspan="2"><a id="a85b1873633c46b13271dcf06ac743666" name="a85b1873633c46b13271dcf06ac743666"></a>
template&lt;typename Key , typename Value , class Header , template&lt; typename, typename &gt; class Db&gt; </td></tr>
<tr class="memitem:a85b1873633c46b13271dcf06ac743666"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>basic_db_leaf_unique_ptr</b> = std::unique_ptr&lt; <a class="el" href="classunodb_1_1detail_1_1basic__leaf.html">basic_leaf</a>&lt; Key, Header &gt;, <a class="el" href="classunodb_1_1detail_1_1basic__db__leaf__deleter.html">basic_db_leaf_deleter</a>&lt; Db&lt; Key, Value &gt; &gt; &gt;</td></tr>
<tr class="separator:a85b1873633c46b13271dcf06ac743666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a48856979c828fe6f91a83b8b43e0be" id="r_a2a48856979c828fe6f91a83b8b43e0be"><td class="memItemLeft" align="right" valign="top"><a id="a2a48856979c828fe6f91a83b8b43e0be" name="a2a48856979c828fe6f91a83b8b43e0be"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_prefix_size</b> = std::uint8_t</td></tr>
<tr class="separator:a2a48856979c828fe6f91a83b8b43e0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52168a8b4ef78db5b5cdc3f60a97eb38" id="r_a52168a8b4ef78db5b5cdc3f60a97eb38"><td class="memTemplParams" colspan="2"><a id="a52168a8b4ef78db5b5cdc3f60a97eb38" name="a52168a8b4ef78db5b5cdc3f60a97eb38"></a>
template&lt;class NodeHeader &gt; </td></tr>
<tr class="memitem:a52168a8b4ef78db5b5cdc3f60a97eb38"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>iter_result_opt</b> = std::optional&lt; <a class="el" href="structunodb_1_1detail_1_1iter__result.html">iter_result</a>&lt; NodeHeader &gt; &gt;</td></tr>
<tr class="separator:a52168a8b4ef78db5b5cdc3f60a97eb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037f39940ab0ed860b951257770afe9b" id="r_a037f39940ab0ed860b951257770afe9b"><td class="memTemplParams" colspan="2"><a id="a037f39940ab0ed860b951257770afe9b" name="a037f39940ab0ed860b951257770afe9b"></a>
template&lt;class ArtPolicy &gt; </td></tr>
<tr class="memitem:a037f39940ab0ed860b951257770afe9b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>basic_inode_4_parent</b> = <a class="el" href="classunodb_1_1detail_1_1basic__inode.html">basic_inode</a>&lt; ArtPolicy, 2, 4, <a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3a3542ac61a301c83960ca9c44a79260e9">node_type::I4</a>, <a class="el" href="classunodb_1_1detail_1_1fake__inode.html">fake_inode</a>, typename ArtPolicy::inode16_type, typename ArtPolicy::inode4_type &gt;</td></tr>
<tr class="separator:a037f39940ab0ed860b951257770afe9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39f8ebe46749af5895e69f8b49ef1b0" id="r_ad39f8ebe46749af5895e69f8b49ef1b0"><td class="memTemplParams" colspan="2"><a id="ad39f8ebe46749af5895e69f8b49ef1b0" name="ad39f8ebe46749af5895e69f8b49ef1b0"></a>
template&lt;class ArtPolicy &gt; </td></tr>
<tr class="memitem:ad39f8ebe46749af5895e69f8b49ef1b0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>basic_inode_16_parent</b> = <a class="el" href="classunodb_1_1detail_1_1basic__inode.html">basic_inode</a>&lt; ArtPolicy, 5, 16, <a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3abcd774f891b5f9df7099f3ea75dadf8d">node_type::I16</a>, typename ArtPolicy::inode4_type, typename ArtPolicy::inode48_type, typename ArtPolicy::inode16_type &gt;</td></tr>
<tr class="separator:ad39f8ebe46749af5895e69f8b49ef1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf738b8ea5a62ab94eb490521f021d4" id="r_a4bf738b8ea5a62ab94eb490521f021d4"><td class="memTemplParams" colspan="2"><a id="a4bf738b8ea5a62ab94eb490521f021d4" name="a4bf738b8ea5a62ab94eb490521f021d4"></a>
template&lt;class ArtPolicy &gt; </td></tr>
<tr class="memitem:a4bf738b8ea5a62ab94eb490521f021d4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>basic_inode_48_parent</b> = <a class="el" href="classunodb_1_1detail_1_1basic__inode.html">basic_inode</a>&lt; ArtPolicy, 17, 48, <a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3a62e917add11d7e69f1356f76800cd084">node_type::I48</a>, typename ArtPolicy::inode16_type, typename ArtPolicy::inode256_type, typename ArtPolicy::inode48_type &gt;</td></tr>
<tr class="separator:a4bf738b8ea5a62ab94eb490521f021d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9ec247e08423b7456c02d0234e41ab" id="r_a7a9ec247e08423b7456c02d0234e41ab"><td class="memTemplParams" colspan="2"><a id="a7a9ec247e08423b7456c02d0234e41ab" name="a7a9ec247e08423b7456c02d0234e41ab"></a>
template&lt;class ArtPolicy &gt; </td></tr>
<tr class="memitem:a7a9ec247e08423b7456c02d0234e41ab"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>basic_inode_256_parent</b> = <a class="el" href="classunodb_1_1detail_1_1basic__inode.html">basic_inode</a>&lt; ArtPolicy, 49, 256, <a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3a4db1a4fc0ba7faa34813bde8556fccda">node_type::I256</a>, typename ArtPolicy::inode48_type, <a class="el" href="classunodb_1_1detail_1_1fake__inode.html">fake_inode</a>, typename ArtPolicy::inode256_type &gt;</td></tr>
<tr class="separator:a7a9ec247e08423b7456c02d0234e41ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af9f878124c38ae4be2fc686e0cbdec" id="r_a6af9f878124c38ae4be2fc686e0cbdec"><td class="memTemplParams" colspan="2"><a id="a6af9f878124c38ae4be2fc686e0cbdec" name="a6af9f878124c38ae4be2fc686e0cbdec"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a6af9f878124c38ae4be2fc686e0cbdec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>olc_inode_defs</b> = <a class="el" href="structunodb_1_1detail_1_1basic__inode__def.html">basic_inode_def</a>&lt; <a class="el" href="classunodb_1_1detail_1_1olc__inode.html">olc_inode</a>&lt; Key, Value &gt;, <a class="el" href="classunodb_1_1detail_1_1olc__inode__4.html">olc_inode_4</a>&lt; Key, Value &gt;, <a class="el" href="classunodb_1_1detail_1_1olc__inode__16.html">olc_inode_16</a>&lt; Key, Value &gt;, <a class="el" href="classunodb_1_1detail_1_1olc__inode__48.html">olc_inode_48</a>&lt; Key, Value &gt;, <a class="el" href="classunodb_1_1detail_1_1olc__inode__256.html">olc_inode_256</a>&lt; Key, Value &gt; &gt;</td></tr>
<tr class="separator:a6af9f878124c38ae4be2fc686e0cbdec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803cfe31d9bfd152cfff50359a30d70f" id="r_a803cfe31d9bfd152cfff50359a30d70f"><td class="memItemLeft" align="right" valign="top"><a id="a803cfe31d9bfd152cfff50359a30d70f" name="a803cfe31d9bfd152cfff50359a30d70f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>olc_node_ptr</b> = <a class="el" href="classunodb_1_1detail_1_1basic__node__ptr.html">basic_node_ptr</a>&lt; <a class="el" href="structunodb_1_1detail_1_1olc__node__header.html">olc_node_header</a> &gt;</td></tr>
<tr class="separator:a803cfe31d9bfd152cfff50359a30d70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7eaaa6ba010012faff7b7fb4b84704" id="r_afc7eaaa6ba010012faff7b7fb4b84704"><td class="memTemplParams" colspan="2"><a id="afc7eaaa6ba010012faff7b7fb4b84704" name="afc7eaaa6ba010012faff7b7fb4b84704"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:afc7eaaa6ba010012faff7b7fb4b84704"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>olc_art_policy</b> = <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">basic_art_policy</a>&lt; Key, Value, <a class="el" href="classunodb_1_1olc__db.html">unodb::olc_db</a>, <a class="el" href="classunodb_1_1in__critical__section.html">unodb::in_critical_section</a>, <a class="el" href="classunodb_1_1optimistic__lock.html">unodb::optimistic_lock</a>, <a class="el" href="classunodb_1_1optimistic__lock_1_1read__critical__section.html">unodb::optimistic_lock::read_critical_section</a>, <a class="el" href="classunodb_1_1detail_1_1basic__node__ptr.html">olc_node_ptr</a>, <a class="el" href="structunodb_1_1detail_1_1basic__inode__def.html">olc_inode_defs</a>, <a class="el" href="classunodb_1_1detail_1_1db__inode__qsbr__deleter.html">db_inode_qsbr_deleter</a>, <a class="el" href="classunodb_1_1detail_1_1db__leaf__qsbr__deleter.html">db_leaf_qsbr_deleter</a> &gt;</td></tr>
<tr class="separator:afc7eaaa6ba010012faff7b7fb4b84704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5911d77bb943df9b6f17776f1b7d1bb7" id="r_a5911d77bb943df9b6f17776f1b7d1bb7"><td class="memTemplParams" colspan="2"><a id="a5911d77bb943df9b6f17776f1b7d1bb7" name="a5911d77bb943df9b6f17776f1b7d1bb7"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a5911d77bb943df9b6f17776f1b7d1bb7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>olc_db_leaf_unique_ptr</b> = typename <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">olc_art_policy</a>&lt; Key, Value &gt;::db_leaf_unique_ptr</td></tr>
<tr class="separator:a5911d77bb943df9b6f17776f1b7d1bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a61a6808c8e6f7ad169a8f13488bc1" id="r_aa9a61a6808c8e6f7ad169a8f13488bc1"><td class="memTemplParams" colspan="2"><a id="aa9a61a6808c8e6f7ad169a8f13488bc1" name="aa9a61a6808c8e6f7ad169a8f13488bc1"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:aa9a61a6808c8e6f7ad169a8f13488bc1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>olc_inode_base</b> = <a class="el" href="classunodb_1_1detail_1_1basic__inode__impl.html">basic_inode_impl</a>&lt; <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">olc_art_policy</a>&lt; Key, Value &gt; &gt;</td></tr>
<tr class="separator:aa9a61a6808c8e6f7ad169a8f13488bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976629fcee449564c59c652e462d38a0" id="r_a976629fcee449564c59c652e462d38a0"><td class="memTemplParams" colspan="2"><a id="a976629fcee449564c59c652e462d38a0" name="a976629fcee449564c59c652e462d38a0"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a976629fcee449564c59c652e462d38a0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>olc_leaf_type</b> = typename <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">olc_art_policy</a>&lt; Key, Value &gt;::leaf_type</td></tr>
<tr class="separator:a976629fcee449564c59c652e462d38a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6accd1ac0f833ad2a37a7f63e1bb9ad3" id="r_a6accd1ac0f833ad2a37a7f63e1bb9ad3"><td class="memTemplParams" colspan="2"><a id="a6accd1ac0f833ad2a37a7f63e1bb9ad3" name="a6accd1ac0f833ad2a37a7f63e1bb9ad3"></a>
template&lt;class AtomicArray &gt; </td></tr>
<tr class="memitem:a6accd1ac0f833ad2a37a7f63e1bb9ad3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>non_atomic_array</b> = std::array&lt; typename AtomicArray::value_type::value_type, std::tuple_size&lt; AtomicArray &gt;::value &gt;</td></tr>
<tr class="separator:a6accd1ac0f833ad2a37a7f63e1bb9ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9e8892527b0164dc1b8b2b177cc28e" id="r_adc9e8892527b0164dc1b8b2b177cc28e"><td class="memTemplParams" colspan="2"><a id="adc9e8892527b0164dc1b8b2b177cc28e" name="adc9e8892527b0164dc1b8b2b177cc28e"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:adc9e8892527b0164dc1b8b2b177cc28e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>olc_leaf_unique_ptr</b> = basic_db_leaf_unique_ptr&lt; Key, Value, <a class="el" href="structunodb_1_1detail_1_1olc__node__header.html">olc_node_header</a>, <a class="el" href="classunodb_1_1olc__db.html">olc_db</a> &gt;</td></tr>
<tr class="separator:adc9e8892527b0164dc1b8b2b177cc28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a5507008263301357281c328968601" id="r_a32a5507008263301357281c328968601"><td class="memTemplParams" colspan="2"><a id="a32a5507008263301357281c328968601" name="a32a5507008263301357281c328968601"></a>
template&lt;typename Key , typename Value , class INode &gt; </td></tr>
<tr class="memitem:a32a5507008263301357281c328968601"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>db_inode_qsbr_deleter_parent</b> = <a class="el" href="classunodb_1_1detail_1_1basic__db__inode__deleter.html">unodb::detail::basic_db_inode_deleter</a>&lt; INode, <a class="el" href="classunodb_1_1olc__db.html">unodb::olc_db</a>&lt; Key, Value &gt; &gt;</td></tr>
<tr class="separator:a32a5507008263301357281c328968601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2daa87032220b0bbd414ed7e91c0a3ec" id="r_a2daa87032220b0bbd414ed7e91c0a3ec"><td class="memTemplParams" colspan="2"><a id="a2daa87032220b0bbd414ed7e91c0a3ec" name="a2daa87032220b0bbd414ed7e91c0a3ec"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a2daa87032220b0bbd414ed7e91c0a3ec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>olc_inode_4_parent</b> = <a class="el" href="classunodb_1_1detail_1_1basic__inode__4.html">basic_inode_4</a>&lt; <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">olc_art_policy</a>&lt; Key, Value &gt; &gt;</td></tr>
<tr class="separator:a2daa87032220b0bbd414ed7e91c0a3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd1f1cc605b5de4a4b662f2982bf64e" id="r_a5cd1f1cc605b5de4a4b662f2982bf64e"><td class="memItemLeft" align="right" valign="top"><a id="a5cd1f1cc605b5de4a4b662f2982bf64e" name="a5cd1f1cc605b5de4a4b662f2982bf64e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>olc_inode_4_test_type</b> = <a class="el" href="classunodb_1_1detail_1_1olc__inode__4.html">olc_inode_4</a>&lt; std::uint64_t, <a class="el" href="namespaceunodb.html#ae25127f715f2aac269da8a3616284c0b">unodb::value_view</a> &gt;</td></tr>
<tr class="separator:a5cd1f1cc605b5de4a4b662f2982bf64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3221164cddf47d6ecc6a42dfa1dcbbda" id="r_a3221164cddf47d6ecc6a42dfa1dcbbda"><td class="memTemplParams" colspan="2"><a id="a3221164cddf47d6ecc6a42dfa1dcbbda" name="a3221164cddf47d6ecc6a42dfa1dcbbda"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a3221164cddf47d6ecc6a42dfa1dcbbda"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>olc_inode_16_parent</b> = <a class="el" href="classunodb_1_1detail_1_1basic__inode__16.html">basic_inode_16</a>&lt; <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">olc_art_policy</a>&lt; Key, Value &gt; &gt;</td></tr>
<tr class="separator:a3221164cddf47d6ecc6a42dfa1dcbbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af986db1bf730fa049317b3b1ee19b6fd" id="r_af986db1bf730fa049317b3b1ee19b6fd"><td class="memItemLeft" align="right" valign="top"><a id="af986db1bf730fa049317b3b1ee19b6fd" name="af986db1bf730fa049317b3b1ee19b6fd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>olc_inode_16_test_type</b> = <a class="el" href="classunodb_1_1detail_1_1olc__inode__16.html">olc_inode_16</a>&lt; std::uint64_t, <a class="el" href="namespaceunodb.html#ae25127f715f2aac269da8a3616284c0b">unodb::value_view</a> &gt;</td></tr>
<tr class="separator:af986db1bf730fa049317b3b1ee19b6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cd0b497d4ddebc9ac2b9bbf9235ed6" id="r_a07cd0b497d4ddebc9ac2b9bbf9235ed6"><td class="memTemplParams" colspan="2"><a id="a07cd0b497d4ddebc9ac2b9bbf9235ed6" name="a07cd0b497d4ddebc9ac2b9bbf9235ed6"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a07cd0b497d4ddebc9ac2b9bbf9235ed6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>olc_inode_48_parent</b> = <a class="el" href="classunodb_1_1detail_1_1basic__inode__48.html">basic_inode_48</a>&lt; <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">olc_art_policy</a>&lt; Key, Value &gt; &gt;</td></tr>
<tr class="separator:a07cd0b497d4ddebc9ac2b9bbf9235ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46066ca6db85223001a2a12d2892b8f6" id="r_a46066ca6db85223001a2a12d2892b8f6"><td class="memItemLeft" align="right" valign="top"><a id="a46066ca6db85223001a2a12d2892b8f6" name="a46066ca6db85223001a2a12d2892b8f6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>olc_inode_48_test_type</b> = <a class="el" href="classunodb_1_1detail_1_1olc__inode__48.html">olc_inode_48</a>&lt; std::uint64_t, <a class="el" href="namespaceunodb.html#ae25127f715f2aac269da8a3616284c0b">unodb::value_view</a> &gt;</td></tr>
<tr class="separator:a46066ca6db85223001a2a12d2892b8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe36625ac20f7ced77f37054bda2a11" id="r_a3fe36625ac20f7ced77f37054bda2a11"><td class="memTemplParams" colspan="2"><a id="a3fe36625ac20f7ced77f37054bda2a11" name="a3fe36625ac20f7ced77f37054bda2a11"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a3fe36625ac20f7ced77f37054bda2a11"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>olc_inode_256_parent</b> = <a class="el" href="classunodb_1_1detail_1_1basic__inode__256.html">basic_inode_256</a>&lt; <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">olc_art_policy</a>&lt; Key, Value &gt; &gt;</td></tr>
<tr class="separator:a3fe36625ac20f7ced77f37054bda2a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef6e7104112ec675df54cac9eeece1c" id="r_a2ef6e7104112ec675df54cac9eeece1c"><td class="memItemLeft" align="right" valign="top"><a id="a2ef6e7104112ec675df54cac9eeece1c" name="a2ef6e7104112ec675df54cac9eeece1c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>olc_inode_256_test_type</b> = <a class="el" href="classunodb_1_1detail_1_1olc__inode__256.html">olc_inode_256</a>&lt; std::uint64_t, <a class="el" href="namespaceunodb.html#ae25127f715f2aac269da8a3616284c0b">unodb::value_view</a> &gt;</td></tr>
<tr class="separator:a2ef6e7104112ec675df54cac9eeece1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bbb5caf501cb09276604dab64723bf" id="r_a78bbb5caf501cb09276604dab64723bf"><td class="memItemLeft" align="right" valign="top"><a id="a78bbb5caf501cb09276604dab64723bf" name="a78bbb5caf501cb09276604dab64723bf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>qsbr_thread_count_type</b> = std::uint32_t</td></tr>
<tr class="memdesc:a78bbb5caf501cb09276604dab64723bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for counting QSBR-managed threads. <br /></td></tr>
<tr class="separator:a78bbb5caf501cb09276604dab64723bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c98952bb0651c3bd50ab5de879cfeff" id="r_a3c98952bb0651c3bd50ab5de879cfeff"><td class="memItemLeft" align="right" valign="top"><a id="a3c98952bb0651c3bd50ab5de879cfeff" name="a3c98952bb0651c3bd50ab5de879cfeff"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>dealloc_request_vector</b> = std::vector&lt; <a class="el" href="classunodb_1_1detail_1_1deallocation__request.html">deallocation_request</a> &gt;</td></tr>
<tr class="memdesc:a3c98952bb0651c3bd50ab5de879cfeff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of deallocation requests. <br /></td></tr>
<tr class="separator:a3c98952bb0651c3bd50ab5de879cfeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a315446f662ab93a69546e61c3c72a492" id="r_a315446f662ab93a69546e61c3c72a492"><td class="memItemLeft" align="right" valign="top"><a id="a315446f662ab93a69546e61c3c72a492" name="a315446f662ab93a69546e61c3c72a492"></a>
auto *&#160;</td><td class="memItemRight" valign="bottom"><b>unwrap_fake_critical_section</b> (<a class="el" href="classunodb_1_1in__fake__critical__section.html">unodb::in_fake_critical_section</a>&lt; <a class="el" href="classunodb_1_1detail_1_1basic__node__ptr.html">unodb::detail::node_ptr</a> &gt; *ptr) noexcept</td></tr>
<tr class="separator:a315446f662ab93a69546e61c3c72a492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea0a7a9ae7c67e2636bae1ca01e11fe" id="r_a0ea0a7a9ae7c67e2636bae1ca01e11fe"><td class="memItemLeft" align="right" valign="top"><a id="a0ea0a7a9ae7c67e2636bae1ca01e11fe" name="a0ea0a7a9ae7c67e2636bae1ca01e11fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump_byte</b> (std::ostream &amp;os, std::byte byte)</td></tr>
<tr class="memdesc:a0ea0a7a9ae7c67e2636bae1ca01e11fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the a byte as a hexadecimal number. <br /></td></tr>
<tr class="separator:a0ea0a7a9ae7c67e2636bae1ca01e11fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815292cf4ea423f309805739554301b5" id="r_a815292cf4ea423f309805739554301b5"><td class="memItemLeft" align="right" valign="top"><a id="a815292cf4ea423f309805739554301b5" name="a815292cf4ea423f309805739554301b5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump_val</b> (std::ostream &amp;os, <a class="el" href="namespaceunodb.html#ae25127f715f2aac269da8a3616284c0b">unodb::value_view</a> v)</td></tr>
<tr class="memdesc:a815292cf4ea423f309805739554301b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the value as a sequence of bytes. <br /></td></tr>
<tr class="separator:a815292cf4ea423f309805739554301b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0891f194e6a48dea0836ae8c85c99c58" id="r_a0891f194e6a48dea0836ae8c85c99c58"><td class="memTemplParams" colspan="2"><a id="a0891f194e6a48dea0836ae8c85c99c58" name="a0891f194e6a48dea0836ae8c85c99c58"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0891f194e6a48dea0836ae8c85c99c58"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dump_key</b> (std::ostream &amp;os, <a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">key_view</a> key)</td></tr>
<tr class="memdesc:a0891f194e6a48dea0836ae8c85c99c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a <code>std::span</code> byte-wise (works on any <a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90" title="Keys are passed as non-owning pointers to memory with associated length using a std::span.">unodb::key_view</a>). <br /></td></tr>
<tr class="separator:a0891f194e6a48dea0836ae8c85c99c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f442e3027e04156cef43a9b865a0c16" id="r_a3f442e3027e04156cef43a9b865a0c16"><td class="memTemplParams" colspan="2"><a id="a3f442e3027e04156cef43a9b865a0c16" name="a3f442e3027e04156cef43a9b865a0c16"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3f442e3027e04156cef43a9b865a0c16"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dump_key</b> (std::ostream &amp;os, T key)</td></tr>
<tr class="memdesc:a3f442e3027e04156cef43a9b865a0c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the key in lexicographic byte-wise order. <br /></td></tr>
<tr class="separator:a3f442e3027e04156cef43a9b865a0c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861c73c299176b3b3839990fce470afe" id="r_a861c73c299176b3b3839990fce470afe"><td class="memTemplParams" colspan="2"><a id="a861c73c299176b3b3839990fce470afe" name="a861c73c299176b3b3839990fce470afe"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a861c73c299176b3b3839990fce470afe"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; std::is_integral&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>shift_or_32bit_int</b> (T i)</td></tr>
<tr class="memdesc:a861c73c299176b3b3839990fce470afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">32bit int shift-or utility function that is used by <a class="el" href="namespaceunodb_1_1detail.html#accbae124e22c790ab242b390af59f80b" title="Find the next power of 2 for a 32-bit or 64-bit value.">unodb::detail::next_power_of_two</a>. <br /></td></tr>
<tr class="separator:a861c73c299176b3b3839990fce470afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbae124e22c790ab242b390af59f80b" id="r_accbae124e22c790ab242b390af59f80b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:accbae124e22c790ab242b390af59f80b"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; std::is_integral&lt; T &gt;::value &amp;&amp;sizeof(T)==4, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#accbae124e22c790ab242b390af59f80b">next_power_of_two</a> (T i) noexcept</td></tr>
<tr class="memdesc:accbae124e22c790ab242b390af59f80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the next power of <code>2</code> for a 32-bit or 64-bit value.  <br /></td></tr>
<tr class="separator:accbae124e22c790ab242b390af59f80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e43f829a0d5ccd979ba18da30b2439" id="r_a98e43f829a0d5ccd979ba18da30b2439"><td class="memTemplParams" colspan="2"><a id="a98e43f829a0d5ccd979ba18da30b2439" name="a98e43f829a0d5ccd979ba18da30b2439"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a98e43f829a0d5ccd979ba18da30b2439"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; std::is_integral&lt; T &gt;::value &amp;&amp;sizeof(T)==8, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>next_power_of_two</b> (T i) noexcept</td></tr>
<tr class="separator:a98e43f829a0d5ccd979ba18da30b2439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0944ca4972aeaf1a2ec41f0c9d74fd37" id="r_a0944ca4972aeaf1a2ec41f0c9d74fd37"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0944ca4972aeaf1a2ec41f0c9d74fd37"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#a0944ca4972aeaf1a2ec41f0c9d74fd37">lexicographic_successor</a> (T v) noexcept</td></tr>
<tr class="memdesc:a0944ca4972aeaf1a2ec41f0c9d74fd37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the lexicographically next bit permutation.  <br /></td></tr>
<tr class="separator:a0944ca4972aeaf1a2ec41f0c9d74fd37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50fbbc0bfcabb917d60da68dd6ea193" id="r_ae50fbbc0bfcabb917d60da68dd6ea193"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#ae50fbbc0bfcabb917d60da68dd6ea193">ensure_capacity</a> (std::byte *&amp;buf, size_t &amp;cap, size_t off, size_t min_capacity)</td></tr>
<tr class="memdesc:ae50fbbc0bfcabb917d60da68dd6ea193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method for power of two expansion of buffers (internal API, forward declaration).  <br /></td></tr>
<tr class="separator:ae50fbbc0bfcabb917d60da68dd6ea193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d6d8602d9590be64fd0031611bbf07" id="r_a60d6d8602d9590be64fd0031611bbf07"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#a60d6d8602d9590be64fd0031611bbf07">compare</a> (const void *a, const size_t alen, const void *b, const size_t blen) noexcept</td></tr>
<tr class="memdesc:a60d6d8602d9590be64fd0031611bbf07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographic comparison of bytes.  <br /></td></tr>
<tr class="separator:a60d6d8602d9590be64fd0031611bbf07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749463245ed07a65e2df960ac1beb847" id="r_a749463245ed07a65e2df960ac1beb847"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#a749463245ed07a65e2df960ac1beb847">compare</a> (const <a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">unodb::key_view</a> a, const <a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">unodb::key_view</a> b) noexcept</td></tr>
<tr class="memdesc:a749463245ed07a65e2df960ac1beb847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographic comparison of key_views.  <br /></td></tr>
<tr class="separator:a749463245ed07a65e2df960ac1beb847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9586a5c7fc84c4bbc05b716fd1ce03" id="r_a7d9586a5c7fc84c4bbc05b716fd1ce03"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#a7d9586a5c7fc84c4bbc05b716fd1ce03">get_u64</a> (<a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">key_view</a> key) noexcept</td></tr>
<tr class="memdesc:a7d9586a5c7fc84c4bbc05b716fd1ce03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first 64-bits of the encoded key.  <br /></td></tr>
<tr class="separator:a7d9586a5c7fc84c4bbc05b716fd1ce03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25eb4ea7710810f49fcc23353dad6c8f" id="r_a25eb4ea7710810f49fcc23353dad6c8f"><td class="memItemLeft" align="right" valign="top"><a id="a25eb4ea7710810f49fcc23353dad6c8f" name="a25eb4ea7710810f49fcc23353dad6c8f"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>_mm_cmple_epu8</b> (__m128i x, __m128i y) noexcept</td></tr>
<tr class="separator:a25eb4ea7710810f49fcc23353dad6c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af970174b47b028df839316ed29fde924" id="r_af970174b47b028df839316ed29fde924"><td class="memTemplParams" colspan="2"><a id="af970174b47b028df839316ed29fde924" name="af970174b47b028df839316ed29fde924"></a>
template&lt;typename Key , typename Value , template&lt; typename, typename &gt; class Db&gt; </td></tr>
<tr class="memitem:af970174b47b028df839316ed29fde924"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_db_leaf_ptr</b> (<a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">basic_art_key</a>&lt; Key &gt; k, <a class="el" href="namespaceunodb.html#ae25127f715f2aac269da8a3616284c0b">value_view</a> v, Db&lt; Key, Value &gt; &amp;<a class="el" href="classunodb_1_1db.html">db</a> <a class="el" href="group__internal.html#ga5e11cdd5f7dc641ab4d60165ddb5297d">UNODB_DETAIL_LIFETIMEBOUND</a>)</td></tr>
<tr class="memdesc:af970174b47b028df839316ed29fde924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a unique pointer for a new leaf initialized with the caller's key and value. <br /></td></tr>
<tr class="separator:af970174b47b028df839316ed29fde924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70778153d340954b6f2718fd7f018a2" id="r_aa70778153d340954b6f2718fd7f018a2"><td class="memItemLeft" align="right" valign="top"><a id="aa70778153d340954b6f2718fd7f018a2" name="aa70778153d340954b6f2718fd7f018a2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>msg_stacktrace_abort</b> (std::string_view msg) noexcept</td></tr>
<tr class="memdesc:aa70778153d340954b6f2718fd7f018a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a message and a stacktrace to std::cerr, then abort. <br /></td></tr>
<tr class="separator:aa70778153d340954b6f2718fd7f018a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84376061f77319109e51399dd10a3135" id="r_a84376061f77319109e51399dd10a3135"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#a84376061f77319109e51399dd10a3135">cannot_happen</a> (const char *file, int line, const char *func) noexcept</td></tr>
<tr class="memdesc:a84376061f77319109e51399dd10a3135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for marking a source code location as unreachable.  <br /></td></tr>
<tr class="separator:a84376061f77319109e51399dd10a3135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5f331d83917453230a096af3197dc2" id="r_aae5f331d83917453230a096af3197dc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#aae5f331d83917453230a096af3197dc2">crash</a> (const char *file, int line, const char *func) noexcept</td></tr>
<tr class="memdesc:aae5f331d83917453230a096af3197dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intentionally crash from a given source location.  <br /></td></tr>
<tr class="separator:aae5f331d83917453230a096af3197dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ccae20a7fde29e0381b903bbf0c58a" id="r_a73ccae20a7fde29e0381b903bbf0c58a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#a73ccae20a7fde29e0381b903bbf0c58a">assert_failure</a> (const char *file, int line, const char *func, const char *condition) noexcept</td></tr>
<tr class="memdesc:a73ccae20a7fde29e0381b903bbf0c58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert failure implementation for standalone debug build.  <br /></td></tr>
<tr class="separator:a73ccae20a7fde29e0381b903bbf0c58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11dfd956f06126308971d516d631d85" id="r_aa11dfd956f06126308971d516d631d85"><td class="memTemplParams" colspan="2"><a id="aa11dfd956f06126308971d516d631d85" name="aa11dfd956f06126308971d516d631d85"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa11dfd956f06126308971d516d631d85"><td class="memTemplItemLeft" align="right" valign="top">consteval T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>msb</b> () noexcept</td></tr>
<tr class="memdesc:aa11dfd956f06126308971d516d631d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return value with most significant bit set for the indicated type <em>T</em>. <br /></td></tr>
<tr class="separator:aa11dfd956f06126308971d516d631d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a84ca13cdff9a7f70720ddb0041d0d1" id="r_a1a84ca13cdff9a7f70720ddb0041d0d1"><td class="memTemplParams" colspan="2">template&lt;typename U , typename F &gt; </td></tr>
<tr class="memitem:a1a84ca13cdff9a7f70720ddb0041d0d1"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#a1a84ca13cdff9a7f70720ddb0041d0d1">encode_floating_point</a> (F x) noexcept</td></tr>
<tr class="memdesc:a1a84ca13cdff9a7f70720ddb0041d0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode floating-point value to lexicographic sort key.  <br /></td></tr>
<tr class="separator:a1a84ca13cdff9a7f70720ddb0041d0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f7fa26a657bd2a5640cf369c639d17" id="r_a75f7fa26a657bd2a5640cf369c639d17"><td class="memTemplParams" colspan="2">template&lt;typename F , typename U &gt; </td></tr>
<tr class="memitem:a75f7fa26a657bd2a5640cf369c639d17"><td class="memTemplItemLeft" align="right" valign="top">F&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#a75f7fa26a657bd2a5640cf369c639d17">decode_floating_point</a> (U input) noexcept</td></tr>
<tr class="memdesc:a75f7fa26a657bd2a5640cf369c639d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert lexicographic sort key to original floating-point value.  <br /></td></tr>
<tr class="separator:a75f7fa26a657bd2a5640cf369c639d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09737ff3b123b65375a00570dbd62502" id="r_a09737ff3b123b65375a00570dbd62502"><td class="memTemplParams" colspan="2"><a id="a09737ff3b123b65375a00570dbd62502" name="a09737ff3b123b65375a00570dbd62502"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a09737ff3b123b65375a00570dbd62502"><td class="memTemplItemLeft" align="right" valign="top">consteval auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>alignment_for_new</b> () noexcept</td></tr>
<tr class="memdesc:a09737ff3b123b65375a00570dbd62502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get minimum alignment to use when allocating objects of type <em>T</em>. <br /></td></tr>
<tr class="separator:a09737ff3b123b65375a00570dbd62502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67151fe8291fd24bff04038739700b1f" id="r_a67151fe8291fd24bff04038739700b1f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#a67151fe8291fd24bff04038739700b1f">allocate_aligned</a> (std::size_t size, std::size_t alignment=__STDCPP_DEFAULT_NEW_ALIGNMENT__)</td></tr>
<tr class="memdesc:a67151fe8291fd24bff04038739700b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate aligned heap memory.  <br /></td></tr>
<tr class="separator:a67151fe8291fd24bff04038739700b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857e30bf5bbe06e321300ee868010df9" id="r_a857e30bf5bbe06e321300ee868010df9"><td class="memItemLeft" align="right" valign="top"><a id="a857e30bf5bbe06e321300ee868010df9" name="a857e30bf5bbe06e321300ee868010df9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>free_aligned</b> (void *ptr) noexcept</td></tr>
<tr class="memdesc:a857e30bf5bbe06e321300ee868010df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free heap memory allocated with <a class="el" href="namespaceunodb_1_1detail.html#a67151fe8291fd24bff04038739700b1f" title="Allocate aligned heap memory.">allocate_aligned()</a>. <br /></td></tr>
<tr class="separator:a857e30bf5bbe06e321300ee868010df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3da3568c516e9447ccaa528462a136e" id="r_aa3da3568c516e9447ccaa528462a136e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3">node_type</a> NodeType&gt; </td></tr>
<tr class="memitem:aa3da3568c516e9447ccaa528462a136e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#aa3da3568c516e9447ccaa528462a136e">is_internal_static_assert</a> () noexcept</td></tr>
<tr class="memdesc:aa3da3568c516e9447ccaa528462a136e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically assert that <em>NodeType</em> is one of the internal node types.  <br /></td></tr>
<tr class="separator:aa3da3568c516e9447ccaa528462a136e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace283ba3cda1f0e8f2ddc1d3e5105110" id="r_ace283ba3cda1f0e8f2ddc1d3e5105110"><td class="memTemplParams" colspan="2"><a id="ace283ba3cda1f0e8f2ddc1d3e5105110" name="ace283ba3cda1f0e8f2ddc1d3e5105110"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ace283ba3cda1f0e8f2ddc1d3e5105110"><td class="memTemplItemLeft" align="right" valign="top">non_atomic_array&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_atomic_to_nonatomic</b> (T &amp;atomic_array) noexcept</td></tr>
<tr class="separator:ace283ba3cda1f0e8f2ddc1d3e5105110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e33b5b391273d168ee6a79489f32ce" id="r_ab6e33b5b391273d168ee6a79489f32ce"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#ab6e33b5b391273d168ee6a79489f32ce">node_ptr_lock</a> (const <a class="el" href="classunodb_1_1detail_1_1basic__node__ptr.html">unodb::detail::olc_node_ptr</a> &amp;node <a class="el" href="group__internal.html#ga5e11cdd5f7dc641ab4d60165ddb5297d">UNODB_DETAIL_LIFETIMEBOUND</a>) noexcept</td></tr>
<tr class="memdesc:ab6e33b5b391273d168ee6a79489f32ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the <a class="el" href="classunodb_1_1optimistic__lock.html" title="Version-based optimistic lock that supports single-writer/multiple-readers concurrency without shared...">unodb::optimistic_lock</a> from the node header associated with the unodb::detail::olc_node_ptr.  <br /></td></tr>
<tr class="separator:ab6e33b5b391273d168ee6a79489f32ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6bcb2412c6ec27e7169762403b99958" id="r_af6bcb2412c6ec27e7169762403b99958"><td class="memTemplParams" colspan="2"><a id="af6bcb2412c6ec27e7169762403b99958" name="af6bcb2412c6ec27e7169762403b99958"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:af6bcb2412c6ec27e7169762403b99958"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>node_ptr_lock</b> (const unodb::detail::olc_leaf_type&lt; Key, Value &gt; *const node <a class="el" href="group__internal.html#ga5e11cdd5f7dc641ab4d60165ddb5297d">UNODB_DETAIL_LIFETIMEBOUND</a>) noexcept</td></tr>
<tr class="separator:af6bcb2412c6ec27e7169762403b99958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c402cc37e0311690f771148e5892cb6" id="r_a0c402cc37e0311690f771148e5892cb6"><td class="memTemplParams" colspan="2"><a id="a0c402cc37e0311690f771148e5892cb6" name="a0c402cc37e0311690f771148e5892cb6"></a>
template&lt;class INode &gt; </td></tr>
<tr class="memitem:a0c402cc37e0311690f771148e5892cb6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lock</b> (const INode &amp;<a class="el" href="classunodb_1_1detail_1_1inode.html">inode</a> <a class="el" href="group__internal.html#ga5e11cdd5f7dc641ab4d60165ddb5297d">UNODB_DETAIL_LIFETIMEBOUND</a>) noexcept</td></tr>
<tr class="separator:a0c402cc37e0311690f771148e5892cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040d359316e5b47838c0ae6f58d90520" id="r_a040d359316e5b47838c0ae6f58d90520"><td class="memTemplParams" colspan="2"><a id="a040d359316e5b47838c0ae6f58d90520" name="a040d359316e5b47838c0ae6f58d90520"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a040d359316e5b47838c0ae6f58d90520"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>obsolete</b> (T &amp;t <a class="el" href="group__internal.html#ga5e11cdd5f7dc641ab4d60165ddb5297d">UNODB_DETAIL_LIFETIMEBOUND</a>, <a class="el" href="classunodb_1_1optimistic__lock_1_1write__guard.html">unodb::optimistic_lock::write_guard</a> &amp;guard) noexcept</td></tr>
<tr class="separator:a040d359316e5b47838c0ae6f58d90520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af186317de2640a732da4eaf767a15f89" id="r_af186317de2640a732da4eaf767a15f89"><td class="memItemLeft" align="right" valign="top"><a id="af186317de2640a732da4eaf767a15f89" name="af186317de2640a732da4eaf767a15f89"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>obsolete_child_by_index</b> (std::uint8_t child <a class="el" href="group__internal.html#ga5e11cdd5f7dc641ab4d60165ddb5297d">UNODB_DETAIL_LIFETIMEBOUND</a>, <a class="el" href="classunodb_1_1optimistic__lock_1_1write__guard.html">unodb::optimistic_lock::write_guard</a> &amp;guard) noexcept</td></tr>
<tr class="separator:af186317de2640a732da4eaf767a15f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1748db6157f77efb62fa8097966b1a" id="r_a5e1748db6157f77efb62fa8097966b1a"><td class="memTemplParams" colspan="2"><a id="a5e1748db6157f77efb62fa8097966b1a" name="a5e1748db6157f77efb62fa8097966b1a"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a5e1748db6157f77efb62fa8097966b1a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_leaf_if_needed</b> (olc_db_leaf_unique_ptr&lt; Key, Value &gt; &amp;cached_leaf, <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">basic_art_key</a>&lt; Key &gt; k, <a class="el" href="namespaceunodb.html#ae25127f715f2aac269da8a3616284c0b">unodb::value_view</a> v, <a class="el" href="classunodb_1_1olc__db.html">unodb::olc_db</a>&lt; Key, Value &gt; &amp;db_instance)</td></tr>
<tr class="separator:a5e1748db6157f77efb62fa8097966b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da3355dc2b016836da8179235257ad4" id="r_a6da3355dc2b016836da8179235257ad4"><td class="memTemplParams" colspan="2"><a id="a6da3355dc2b016836da8179235257ad4" name="a6da3355dc2b016836da8179235257ad4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6da3355dc2b016836da8179235257ad4"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bswap</b> (T x) noexcept</td></tr>
<tr class="memdesc:a6da3355dc2b016836da8179235257ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the order of bytes in <em>x</em>. <br /></td></tr>
<tr class="separator:a6da3355dc2b016836da8179235257ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5572532b0d5ba02cbbfb5e876bd59925" id="r_a5572532b0d5ba02cbbfb5e876bd59925"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5572532b0d5ba02cbbfb5e876bd59925"><td class="memTemplItemLeft" align="right" valign="top">std::uint8_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#a5572532b0d5ba02cbbfb5e876bd59925">ctz</a> (T x) noexcept</td></tr>
<tr class="memdesc:a5572532b0d5ba02cbbfb5e876bd59925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of trailing zero bits in <em>x</em>.  <br /></td></tr>
<tr class="separator:a5572532b0d5ba02cbbfb5e876bd59925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60cd68db0acc4264f225af504457f974" id="r_a60cd68db0acc4264f225af504457f974"><td class="memItemLeft" align="right" valign="top"><a id="a60cd68db0acc4264f225af504457f974" name="a60cd68db0acc4264f225af504457f974"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>popcount</b> (unsigned x) noexcept</td></tr>
<tr class="memdesc:a60cd68db0acc4264f225af504457f974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of one bits in <em>x</em>. <br /></td></tr>
<tr class="separator:a60cd68db0acc4264f225af504457f974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1bd0a219522dc54b6e2726f277e9677" id="r_ae1bd0a219522dc54b6e2726f277e9677"><td class="memTemplParams" colspan="2"><a id="ae1bd0a219522dc54b6e2726f277e9677" name="ae1bd0a219522dc54b6e2726f277e9677"></a>
template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:ae1bd0a219522dc54b6e2726f277e9677"><td class="memTemplItemLeft" align="right" valign="top">constexpr To&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bit_cast</b> (From input) noexcept</td></tr>
<tr class="separator:ae1bd0a219522dc54b6e2726f277e9677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9aa17872190ea6f43fde638f1129514" id="r_aa9aa17872190ea6f43fde638f1129514"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#aa9aa17872190ea6f43fde638f1129514">operator&lt;&lt;</a> (std::ostream &amp;os <a class="el" href="group__internal.html#ga5e11cdd5f7dc641ab4d60165ddb5297d">UNODB_DETAIL_LIFETIMEBOUND</a>, <a class="el" href="classunodb_1_1detail_1_1qsbr__epoch.html">qsbr_epoch</a> value)</td></tr>
<tr class="memdesc:aa9aa17872190ea6f43fde638f1129514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the epoch <em>value</em> to the output stream <em>os</em>.  <br /></td></tr>
<tr class="separator:aa9aa17872190ea6f43fde638f1129514"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aba258d6d1df5e71714ec57d8b041b129" id="r_aba258d6d1df5e71714ec57d8b041b129"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#aba258d6d1df5e71714ec57d8b041b129">INITIAL_BUFFER_CAPACITY</a> = 256</td></tr>
<tr class="memdesc:aba258d6d1df5e71714ec57d8b041b129"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant determining the initial capacity for the <a class="el" href="classunodb_1_1key__encoder.html" title="A utility class to generate binary comparable keys from a sequence of key components.">unodb::key_encoder</a> and other similar internal buffers.  <br /></td></tr>
<tr class="separator:aba258d6d1df5e71714ec57d8b041b129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6affb48b09460b87dbcb8ab404f26263" id="r_a6affb48b09460b87dbcb8ab404f26263"><td class="memItemLeft" align="right" valign="top"><a id="a6affb48b09460b87dbcb8ab404f26263" name="a6affb48b09460b87dbcb8ab404f26263"></a>
static constexpr key_prefix_size&#160;</td><td class="memItemRight" valign="bottom"><b>key_prefix_capacity</b> = 7</td></tr>
<tr class="separator:a6affb48b09460b87dbcb8ab404f26263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81082c8f2c103492eb9f6917f0483bc" id="r_ad81082c8f2c103492eb9f6917f0483bc"><td class="memItemLeft" align="right" valign="top"><a id="ad81082c8f2c103492eb9f6917f0483bc" name="ad81082c8f2c103492eb9f6917f0483bc"></a>
constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>node_type_count</b> {5}</td></tr>
<tr class="memdesc:ad81082c8f2c103492eb9f6917f0483bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of different node types. <br /></td></tr>
<tr class="separator:ad81082c8f2c103492eb9f6917f0483bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11fc0dc02ee0b061504cd50856ea7dd" id="r_aa11fc0dc02ee0b061504cd50856ea7dd"><td class="memItemLeft" align="right" valign="top"><a id="aa11fc0dc02ee0b061504cd50856ea7dd" name="aa11fc0dc02ee0b061504cd50856ea7dd"></a>
constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>inode_type_count</b> {4}</td></tr>
<tr class="memdesc:aa11fc0dc02ee0b061504cd50856ea7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of different internal node types. <br /></td></tr>
<tr class="separator:aa11fc0dc02ee0b061504cd50856ea7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab520671507d4d7d913c5d2655fad89" id="r_a3ab520671507d4d7d913c5d2655fad89"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#a3ab520671507d4d7d913c5d2655fad89">hardware_constructive_interference_size</a></td></tr>
<tr class="memdesc:a3ab520671507d4d7d913c5d2655fad89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size in bytes where multiple variables will be guaranteed to be shared for the purposes of true sharing.  <br /></td></tr>
<tr class="separator:a3ab520671507d4d7d913c5d2655fad89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6387d4046bddd4f1d87150a2e6b94c" id="r_a4c6387d4046bddd4f1d87150a2e6b94c"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#a4c6387d4046bddd4f1d87150a2e6b94c">hardware_destructive_interference_size</a></td></tr>
<tr class="memdesc:a4c6387d4046bddd4f1d87150a2e6b94c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum size in bytes where multiple variables will be guaranteed to be separated for the purposes of false sharing.  <br /></td></tr>
<tr class="separator:a4c6387d4046bddd4f1d87150a2e6b94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7fc26e8bd3beb685ef91e9cc7e6672d" id="r_ac7fc26e8bd3beb685ef91e9cc7e6672d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceunodb_1_1detail.html#a78bbb5caf501cb09276604dab64723bf">qsbr_thread_count_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#ac7fc26e8bd3beb685ef91e9cc7e6672d">max_qsbr_threads</a> = (2UL &lt;&lt; 29U) - 1U</td></tr>
<tr class="memdesc:ac7fc26e8bd3beb685ef91e9cc7e6672d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of threads that can participate in QSBR simultaneously.  <br /></td></tr>
<tr class="separator:ac7fc26e8bd3beb685ef91e9cc7e6672d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a041b47bebde8ed0f3bd97327e450c" id="r_a04a041b47bebde8ed0f3bd97327e450c"><td class="memItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="classunodb_1_1detail_1_1thread__sync.html">thread_sync</a>, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#a04a041b47bebde8ed0f3bd97327e450c">thread_syncs</a></td></tr>
<tr class="memdesc:a04a041b47bebde8ed0f3bd97327e450c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global array of thread synchronization objects.  <br /></td></tr>
<tr class="separator:a04a041b47bebde8ed0f3bd97327e450c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for the UnoDB internal implementation details. </p>
<p>It is not part of the public API, and it may change at any time. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a67151fe8291fd24bff04038739700b1f" name="a67151fe8291fd24bff04038739700b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67151fe8291fd24bff04038739700b1f">&#9670;&#160;</a></span>allocate_aligned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * unodb::detail::allocate_aligned </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>alignment</em> = <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate aligned heap memory. </p>
<p>The allocated block should be freed with <a class="el" href="namespaceunodb_1_1detail.html#a857e30bf5bbe06e321300ee868010df9" title="Free heap memory allocated with allocate_aligned().">free_aligned()</a>. In debug builds, the allocation failure injector is hooked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size of memory to allocate in bytes </td></tr>
    <tr><td class="paramname">alignment</td><td>Memory alignment boundary </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to allocated memory block </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">`std::bad_alloc`</td><td>if the allocation fails </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73ccae20a7fde29e0381b903bbf0c58a" name="a73ccae20a7fde29e0381b903bbf0c58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ccae20a7fde29e0381b903bbf0c58a">&#9670;&#160;</a></span>assert_failure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void unodb::detail::assert_failure </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assert failure implementation for standalone debug build. </p>
<p>Should not be called directly - used UNODB_DETAIL_ASSERT instead. </p>

</div>
</div>
<a id="a84376061f77319109e51399dd10a3135" name="a84376061f77319109e51399dd10a3135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84376061f77319109e51399dd10a3135">&#9670;&#160;</a></span>cannot_happen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void unodb::detail::cannot_happen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation for marking a source code location as unreachable. </p>
<p>Should not be called directly - use UNODB_DETAIL_CANNOT_HAPPEN instead. </p>

</div>
</div>
<a id="a749463245ed07a65e2df960ac1beb847" name="a749463245ed07a65e2df960ac1beb847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a749463245ed07a65e2df960ac1beb847">&#9670;&#160;</a></span>compare() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int unodb::detail::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">unodb::key_view</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">unodb::key_view</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexicographic comparison of key_views. </p>
<dl class="section return"><dt>Returns</dt><dd>-1, 0, or 1 if this key is LT, EQ, or GT the other key. </dd></dl>

</div>
</div>
<a id="a60d6d8602d9590be64fd0031611bbf07" name="a60d6d8602d9590be64fd0031611bbf07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d6d8602d9590be64fd0031611bbf07">&#9670;&#160;</a></span>compare() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int unodb::detail::compare </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>alen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>blen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexicographic comparison of bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>-1, 0, or 1 if this key is LT, EQ, or GT the other key. </dd></dl>

</div>
</div>
<a id="aae5f331d83917453230a096af3197dc2" name="aae5f331d83917453230a096af3197dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae5f331d83917453230a096af3197dc2">&#9670;&#160;</a></span>crash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void unodb::detail::crash </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intentionally crash from a given source location. </p>
<p>Should not be called directly - use UNODB_DETAIL_CRASH instead. </p>

</div>
</div>
<a id="a5572532b0d5ba02cbbfb5e876bd59925" name="a5572532b0d5ba02cbbfb5e876bd59925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5572532b0d5ba02cbbfb5e876bd59925">&#9670;&#160;</a></span>ctz()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint8_t unodb::detail::ctz </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of trailing zero bits in <em>x</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Argument may not be zero </dd></dl>

</div>
</div>
<a id="a75f7fa26a657bd2a5640cf369c639d17" name="a75f7fa26a657bd2a5640cf369c639d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f7fa26a657bd2a5640cf369c639d17">&#9670;&#160;</a></span>decode_floating_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">F unodb::detail::decode_floating_point </td>
          <td>(</td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert lexicographic sort key to original floating-point value. </p>
<p>Reverses the encoding done by <a class="el" href="namespaceunodb_1_1detail.html#a1a84ca13cdff9a7f70720ddb0041d0d1" title="Encode floating-point value to lexicographic sort key.">encode_floating_point()</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The floating-point type to decode to </td></tr>
    <tr><td class="paramname">U</td><td>The unsigned integer type to decode from </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The lexicographic sort key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original floating-point value </dd></dl>

</div>
</div>
<a id="a1a84ca13cdff9a7f70720ddb0041d0d1" name="a1a84ca13cdff9a7f70720ddb0041d0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a84ca13cdff9a7f70720ddb0041d0d1">&#9670;&#160;</a></span>encode_floating_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U unodb::detail::encode_floating_point </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode floating-point value to lexicographic sort key. </p>
<p>This encoding preserves the relative order of values - if a &lt; b for floating-point values, then encode(a) &lt; encode(b) for the integer encoded values.</p>
<p>The returned sort key can be converted back to the original value with <a class="el" href="namespaceunodb_1_1detail.html#a75f7fa26a657bd2a5640cf369c639d17" title="Convert lexicographic sort key to original floating-point value.">decode_floating_point()</a>.</p>
<p>Special values like NaN and infinity are handled specially:</p><ul>
<li>NaN is encoded as the maximum possible integer value</li>
<li>Positive infinity is encoded as maximum possible integer value minus 1</li>
<li>Negative infinity is encoded as 0</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The unsigned integer type to encode to </td></tr>
    <tr><td class="paramname">F</td><td>The floating-point type to encode from </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The floating-point value to encode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lexicographic sort key </dd></dl>

</div>
</div>
<a id="ae50fbbc0bfcabb917d60da68dd6ea193" name="ae50fbbc0bfcabb917d60da68dd6ea193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50fbbc0bfcabb917d60da68dd6ea193">&#9670;&#160;</a></span>ensure_capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void unodb::detail::ensure_capacity </td>
          <td>(</td>
          <td class="paramtype">std::byte *&amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>cap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility method for power of two expansion of buffers (internal API, forward declaration). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to resize.</td></tr>
    <tr><td class="paramname">cap</td><td>The current buffer capacity.</td></tr>
    <tr><td class="paramname">off</td><td>The current number of used bytes.</td></tr>
    <tr><td class="paramname">min_capacity</td><td>The desired new minimum capacity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d9586a5c7fc84c4bbc05b716fd1ce03" name="a7d9586a5c7fc84c4bbc05b716fd1ce03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d9586a5c7fc84c4bbc05b716fd1ce03">&#9670;&#160;</a></span>get_u64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t unodb::detail::get_u64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">key_view</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the first 64-bits of the encoded key. </p>
<p>This is used by the prefix compression logic to identify some number of bytes that are in common between the art_key and an inode having some <a class="el" href="unionunodb_1_1detail_1_1key__prefix.html" title="The unodb::detail::key_prefix is a sequence of zero or more bytes for a given node that are a common ...">key_prefix</a>. </p>

</div>
</div>
<a id="aa3da3568c516e9447ccaa528462a136e" name="aa3da3568c516e9447ccaa528462a136e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3da3568c516e9447ccaa528462a136e">&#9670;&#160;</a></span>is_internal_static_assert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3">node_type</a> NodeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void unodb::detail::is_internal_static_assert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Statically assert that <em>NodeType</em> is one of the internal node types. </p>
<p>This function may not be executed, and only holds the static assert, because it is not an expression and thus cannot appear in expression contexts by itself. </p>

</div>
</div>
<a id="a0944ca4972aeaf1a2ec41f0c9d74fd37" name="a0944ca4972aeaf1a2ec41f0c9d74fd37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0944ca4972aeaf1a2ec41f0c9d74fd37">&#9670;&#160;</a></span>lexicographic_successor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T unodb::detail::lexicographic_successor </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the lexicographically next bit permutation. </p>
<p>This method gets used when you want to form an exclusive upper bound for some key range. You take the upper bound and form the bitwise successor of that value to turn it into an exclusive upper bound. This has to be done for each component of the composite key, working backwards from the end of the key, until a component is found which does not overflow (is not already <code>~0</code>).</p>
<p>Suppose we have a pattern of <code>N</code> bits set to <code>1</code> in an unsigned integer and we want the next permutation of <code>N</code> <code>1</code> bits in a lexicographical sense. For example, if <code>N</code> is <code>3</code> and the bit pattern is <code>00010011</code>, the next patterns would be <code>00010101</code>, <code>00010110</code>, <code>00011001</code>, <code>00011010</code>, <code>00011100</code>, <code>00100011</code>, and so forth. The following is a fast way to compute the next permutation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Some unsigned value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://graphics.stanford.edu/~seander/bithacks.html#NextBitPermutation">https://graphics.stanford.edu/~seander/bithacks.html#NextBitPermutation</a> </dd></dl>

</div>
</div>
<a id="accbae124e22c790ab242b390af59f80b" name="accbae124e22c790ab242b390af59f80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accbae124e22c790ab242b390af59f80b">&#9670;&#160;</a></span>next_power_of_two()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt; std::is_integral&lt; T &gt;::value &amp;&amp;sizeof(T)==4, T &gt;::type unodb::detail::next_power_of_two </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the next power of <code>2</code> for a 32-bit or 64-bit value. </p>
<dl class="section note"><dt>Note</dt><dd>it will overflow if the there is no higher power of <code>2</code> for a given type <code>T</code>. </dd></dl>

</div>
</div>
<a id="ab6e33b5b391273d168ee6a79489f32ce" name="ab6e33b5b391273d168ee6a79489f32ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e33b5b391273d168ee6a79489f32ce">&#9670;&#160;</a></span>node_ptr_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; unodb::detail::node_ptr_lock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classunodb_1_1detail_1_1basic__node__ptr.html">unodb::detail::olc_node_ptr</a> &amp;node&#160;</td>
          <td class="paramname"><em>UNODB_DETAIL_LIFETIMEBOUND</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the <a class="el" href="classunodb_1_1optimistic__lock.html" title="Version-based optimistic lock that supports single-writer/multiple-readers concurrency without shared...">unodb::optimistic_lock</a> from the node header associated with the unodb::detail::olc_node_ptr. </p>
<dl class="section note"><dt>Note</dt><dd>This returns the lock rather than trying to acquire the lock. </dd></dl>

</div>
</div>
<a id="aa9aa17872190ea6f43fde638f1129514" name="aa9aa17872190ea6f43fde638f1129514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9aa17872190ea6f43fde638f1129514">&#9670;&#160;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; unodb::detail::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;os&#160;</td>
          <td class="paramname"><em>UNODB_DETAIL_LIFETIMEBOUND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunodb_1_1detail_1_1qsbr__epoch.html">qsbr_epoch</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the epoch <em>value</em> to the output stream <em>os</em>. </p>
<p>For debug purposes only. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a3ab520671507d4d7d913c5d2655fad89" name="a3ab520671507d4d7d913c5d2655fad89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab520671507d4d7d913c5d2655fad89">&#9670;&#160;</a></span>hardware_constructive_interference_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unodb::detail::hardware_constructive_interference_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum size in bytes where multiple variables will be guaranteed to be shared for the purposes of true sharing. </p>
<p>Use this instead of <code>std::hardware_constructive_interference_size</code> even if the latter is available, because it is used in public headers and its value may vary, for example, by GCC 12 or later <code>--param</code> or <code>-mtune</code> flag. </p>

</div>
</div>
<a id="a4c6387d4046bddd4f1d87150a2e6b94c" name="a4c6387d4046bddd4f1d87150a2e6b94c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6387d4046bddd4f1d87150a2e6b94c">&#9670;&#160;</a></span>hardware_destructive_interference_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unodb::detail::hardware_destructive_interference_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum size in bytes where multiple variables will be guaranteed to be separated for the purposes of false sharing. </p>
<p>Use this instead of <code>std::hardware_destructive_interference_size</code> even if the latter is available, because it is used in public headers and its value may vary, for example, by GCC 12 or later <code>--param</code> or <code>-mtune</code> flag. </p>

</div>
</div>
<a id="aba258d6d1df5e71714ec57d8b041b129" name="aba258d6d1df5e71714ec57d8b041b129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba258d6d1df5e71714ec57d8b041b129">&#9670;&#160;</a></span>INITIAL_BUFFER_CAPACITY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t unodb::detail::INITIAL_BUFFER_CAPACITY = 256</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A constant determining the initial capacity for the <a class="el" href="classunodb_1_1key__encoder.html" title="A utility class to generate binary comparable keys from a sequence of key components.">unodb::key_encoder</a> and other similar internal buffers. </p>
<p>This should be set high enough that such objects DO NOT allocate for commonly used key lengths. These objects use an internal buffer of this capacity and then switch over to an explicitly allocated buffer if the capacity would be exceeded.</p>
<dl class="section note"><dt>Note</dt><dd>: If you are only using fixed width keys, then this can be sizeof(T). In typical scenarios these objects are on the stack and there is little if any penalty to having a larger initial capacity for these buffers. </dd></dl>

</div>
</div>
<a id="ac7fc26e8bd3beb685ef91e9cc7e6672d" name="ac7fc26e8bd3beb685ef91e9cc7e6672d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7fc26e8bd3beb685ef91e9cc7e6672d">&#9670;&#160;</a></span>max_qsbr_threads</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceunodb_1_1detail.html#a78bbb5caf501cb09276604dab64723bf">qsbr_thread_count_type</a> unodb::detail::max_qsbr_threads = (2UL &lt;&lt; 29U) - 1U</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum number of threads that can participate in QSBR simultaneously. </p>
<p>Set to 2^29-1, chosen to allow two thread count fields and an epoch counter to fit in a single machine word. It should be enough for everybody, and its overflow is not checked even in Release builds. </p>

</div>
</div>
<a id="a04a041b47bebde8ed0f3bd97327e450c" name="a04a041b47bebde8ed0f3bd97327e450c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04a041b47bebde8ed0f3bd97327e450c">&#9670;&#160;</a></span>thread_syncs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;<a class="el" href="classunodb_1_1detail_1_1thread__sync.html">thread_sync</a>, 6&gt; unodb::detail::thread_syncs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Global array of thread synchronization objects. </p>
<p>The array size is determined by test needs. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceunodb.html">unodb</a></li><li class="navelem"><a class="el" href="namespaceunodb_1_1detail.html">detail</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
