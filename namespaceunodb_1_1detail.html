<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UnoDB: unodb::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">UnoDB
   </div>
   <div id="projectbrief">Adaptive Radix Tree in C++, optionally with Optimistic Lock Coupling</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceunodb_1_1detail.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">unodb::detail Namespace Reference<div class="ingroups"><a class="el" href="group__internal.html">Internals</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Namespace for the UnoDB internal implementation details.  
<a href="namespaceunodb_1_1detail.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">basic_art_key</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal ART key in lexicographically ordered binary-comparable format.  <a href="structunodb_1_1detail_1_1basic__art__key.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">basic_art_policy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1basic__db__inode__deleter.html">basic_db_inode_deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor to delete internal nodes through database.  <a href="classunodb_1_1detail_1_1basic__db__inode__deleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1basic__db__leaf__deleter.html">basic_db_leaf_deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor to delete leaf nodes through database.  <a href="classunodb_1_1detail_1_1basic__db__leaf__deleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1basic__inode.html">basic_inode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The last common ancestor (both for templates and inheritance) for all inode types for both OLC and regular.  <a href="classunodb_1_1detail_1_1basic__inode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1basic__inode__16.html">basic_inode_16</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1basic__inode__256.html">basic_inode_256</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1basic__inode__4.html">basic_inode_4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An internal node with up to 4 children.  <a href="classunodb_1_1detail_1_1basic__inode__4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1basic__inode__48.html">basic_inode_48</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1basic__inode__def.html">basic_inode_def</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1basic__inode__impl.html">basic_inode_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template class extending the common header and defining some methods common to all internal node types.  <a href="classunodb_1_1detail_1_1basic__inode__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1basic__leaf.html">basic_leaf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classunodb_1_1detail_1_1basic__leaf.html" title="The basic_leaf handles most of the behavior of a leaf in the index.">basic_leaf</a> handles most of the behavior of a leaf in the index.  <a href="classunodb_1_1detail_1_1basic__leaf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1basic__node__ptr.html">basic_node_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tagged pointer with node type stored in low bits.  <a href="classunodb_1_1detail_1_1basic__node__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1db__inode__qsbr__deleter.html">db_inode_qsbr_deleter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1db__leaf__qsbr__deleter.html">db_leaf_qsbr_deleter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1dealloc__vector__list__node.html">dealloc_vector_list_node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node in a linked list for orphaned (issued by threads that have quit since) deallocation requests.  <a href="structunodb_1_1detail_1_1dealloc__vector__list__node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1deallocation__request.html">deallocation_request</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pending deallocation request for QSBR-managed memory.  <a href="classunodb_1_1detail_1_1deallocation__request.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1deferred__requests.html">deferred_requests</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A scope guard that executes deallocation requests upon destruction.  <a href="classunodb_1_1detail_1_1deferred__requests.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1fake__inode.html">fake_inode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class used as a sentinel for <a class="el" href="classunodb_1_1detail_1_1basic__inode.html" title="The last common ancestor (both for templates and inheritance) for all inode types for both OLC and re...">unodb::detail::basic_inode</a> template args: the larger node type for the largest node type and the smaller node type for the smallest node type.  <a href="classunodb_1_1detail_1_1fake__inode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1impl__helpers.html">impl_helpers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1inode.html">inode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1inode__16.html">inode_16</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1inode__256.html">inode_256</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1inode__4.html">inode_4</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1inode__48.html">inode_48</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1iter__result.html">iter_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct that is returned by the iterator visitation pattern which represents a path in the tree for an internal node.  <a href="structunodb_1_1detail_1_1iter__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1key__buffer.html">key_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expandable buffer for binary comparable keys.  <a href="classunodb_1_1detail_1_1key__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionunodb_1_1detail_1_1key__prefix.html">key_prefix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="unionunodb_1_1detail_1_1key__prefix.html" title="The unodb::detail::key_prefix is a sequence of zero or more bytes for a given node that are a common ...">unodb::detail::key_prefix</a> is a sequence of zero or more bytes for a given node that are a common prefix shared by all children of that node and supports prefix compression in the index.  <a href="unionunodb_1_1detail_1_1key__prefix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionunodb_1_1detail_1_1key__prefix__snapshot.html">key_prefix_snapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class used to expose a consistent snapshot of the <a class="el" href="unionunodb_1_1detail_1_1key__prefix.html" title="The unodb::detail::key_prefix is a sequence of zero or more bytes for a given node that are a common ...">unodb::detail::key_prefix</a> to the iterator for use in tracking the data on the iterator's stack.  <a href="unionunodb_1_1detail_1_1key__prefix__snapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1node__header.html">node_header</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1olc__impl__helpers.html">olc_impl_helpers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1olc__inode.html">olc_inode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1olc__inode__16.html">olc_inode_16</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1olc__inode__256.html">olc_inode_256</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1olc__inode__4.html">olc_inode_4</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1olc__inode__48.html">olc_inode_48</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1olc__node__header.html">olc_node_header</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">OLC ART node header contains an <a class="el" href="classunodb_1_1optimistic__lock.html" title="Version-based optimistic lock that supports single-writer/multiple-readers concurrency without shared...">unodb::optimistic_lock</a> object for this node.  <a href="structunodb_1_1detail_1_1olc__node__header.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1qsbr__ptr__base.html">qsbr_ptr_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for QSBR pointers that provides per-thread active pointer registration functionality in debug builds.  <a href="classunodb_1_1detail_1_1qsbr__ptr__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1set__qsbr__per__thread__in__main__thread.html">set_qsbr_per_thread_in_main_thread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for registering the main thread with QSBR.  <a href="structunodb_1_1detail_1_1set__qsbr__per__thread__in__main__thread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1thread__sync.html">thread_sync</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple one-way synchronization mechanism to make one thread wait until another one signals it.  <a href="classunodb_1_1detail_1_1thread__sync.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1detail_1_1tree__depth.html">tree_depth</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of key bytes consumed along some path in the tree.  <a href="classunodb_1_1detail_1_1tree__depth.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aaa98550b35b9c4011a17dd6d7f96f25a" id="r_aaa98550b35b9c4011a17dd6d7f96f25a"><td class="memItemLeft" align="right" valign="top"><a id="aaa98550b35b9c4011a17dd6d7f96f25a" name="aaa98550b35b9c4011a17dd6d7f96f25a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>node_ptr</b> = <a class="el" href="classunodb_1_1detail_1_1basic__node__ptr.html">basic_node_ptr</a>&lt; <a class="el" href="structunodb_1_1detail_1_1node__header.html">node_header</a> &gt;</td></tr>
<tr class="separator:aaa98550b35b9c4011a17dd6d7f96f25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0155f4cc9c31cf3cc24939b69c13d0" id="r_a6e0155f4cc9c31cf3cc24939b69c13d0"><td class="memTemplParams" colspan="2"><a id="a6e0155f4cc9c31cf3cc24939b69c13d0" name="a6e0155f4cc9c31cf3cc24939b69c13d0"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a6e0155f4cc9c31cf3cc24939b69c13d0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inode_defs</b> = <a class="el" href="structunodb_1_1detail_1_1basic__inode__def.html">basic_inode_def</a>&lt; <a class="el" href="classunodb_1_1detail_1_1inode.html">inode</a>&lt; Key, Value &gt;, <a class="el" href="classunodb_1_1detail_1_1inode__4.html">inode_4</a>&lt; Key, Value &gt;, <a class="el" href="classunodb_1_1detail_1_1inode__16.html">inode_16</a>&lt; Key, Value &gt;, <a class="el" href="classunodb_1_1detail_1_1inode__48.html">inode_48</a>&lt; Key, Value &gt;, <a class="el" href="classunodb_1_1detail_1_1inode__256.html">inode_256</a>&lt; Key, Value &gt; &gt;</td></tr>
<tr class="separator:a6e0155f4cc9c31cf3cc24939b69c13d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753ebc8c67b98f4101febd827ccb76a4" id="r_a753ebc8c67b98f4101febd827ccb76a4"><td class="memTemplParams" colspan="2"><a id="a753ebc8c67b98f4101febd827ccb76a4" name="a753ebc8c67b98f4101febd827ccb76a4"></a>
template&lt;typename Key , typename Value , class INode &gt; </td></tr>
<tr class="memitem:a753ebc8c67b98f4101febd827ccb76a4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>db_inode_deleter</b> = <a class="el" href="classunodb_1_1detail_1_1basic__db__inode__deleter.html">basic_db_inode_deleter</a>&lt; INode, <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt; &gt;</td></tr>
<tr class="separator:a753ebc8c67b98f4101febd827ccb76a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf36d7f939b56845e7334c790d07195" id="r_aedf36d7f939b56845e7334c790d07195"><td class="memTemplParams" colspan="2"><a id="aedf36d7f939b56845e7334c790d07195" name="aedf36d7f939b56845e7334c790d07195"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:aedf36d7f939b56845e7334c790d07195"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>art_policy</b> = <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">basic_art_policy</a>&lt; Key, Value, <a class="el" href="classunodb_1_1db.html">unodb::db</a>, <a class="el" href="classunodb_1_1in__fake__critical__section.html">unodb::in_fake_critical_section</a>, <a class="el" href="classunodb_1_1fake__lock.html">unodb::fake_lock</a>, <a class="el" href="classunodb_1_1fake__read__critical__section.html">unodb::fake_read_critical_section</a>, <a class="el" href="classunodb_1_1detail_1_1basic__node__ptr.html">node_ptr</a>, <a class="el" href="structunodb_1_1detail_1_1basic__inode__def.html">inode_defs</a>, <a class="el" href="classunodb_1_1detail_1_1basic__db__inode__deleter.html">db_inode_deleter</a>, <a class="el" href="classunodb_1_1detail_1_1basic__db__leaf__deleter.html">basic_db_leaf_deleter</a> &gt;</td></tr>
<tr class="separator:aedf36d7f939b56845e7334c790d07195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af486b3ba28a2f7e238e2db1946e3b8fb" id="r_af486b3ba28a2f7e238e2db1946e3b8fb"><td class="memTemplParams" colspan="2"><a id="af486b3ba28a2f7e238e2db1946e3b8fb" name="af486b3ba28a2f7e238e2db1946e3b8fb"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:af486b3ba28a2f7e238e2db1946e3b8fb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inode_base</b> = <a class="el" href="classunodb_1_1detail_1_1basic__inode__impl.html">basic_inode_impl</a>&lt; <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">art_policy</a>&lt; Key, Value &gt; &gt;</td></tr>
<tr class="separator:af486b3ba28a2f7e238e2db1946e3b8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab561be018ef4d04aa8a144bb388b721" id="r_aab561be018ef4d04aa8a144bb388b721"><td class="memTemplParams" colspan="2"><a id="aab561be018ef4d04aa8a144bb388b721" name="aab561be018ef4d04aa8a144bb388b721"></a>
template&lt;typename Key &gt; </td></tr>
<tr class="memitem:aab561be018ef4d04aa8a144bb388b721"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>leaf_type</b> = <a class="el" href="classunodb_1_1detail_1_1basic__leaf.html">basic_leaf</a>&lt; Key, <a class="el" href="structunodb_1_1detail_1_1node__header.html">node_header</a> &gt;</td></tr>
<tr class="separator:aab561be018ef4d04aa8a144bb388b721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459acb52e40ddfb61e83d1fd213c49b1" id="r_a459acb52e40ddfb61e83d1fd213c49b1"><td class="memTemplParams" colspan="2"><a id="a459acb52e40ddfb61e83d1fd213c49b1" name="a459acb52e40ddfb61e83d1fd213c49b1"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a459acb52e40ddfb61e83d1fd213c49b1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inode_4_parent</b> = <a class="el" href="classunodb_1_1detail_1_1basic__inode__4.html">basic_inode_4</a>&lt; <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">art_policy</a>&lt; Key, Value &gt; &gt;</td></tr>
<tr class="separator:a459acb52e40ddfb61e83d1fd213c49b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968066c430fa50f96fb3d07081ec4248" id="r_a968066c430fa50f96fb3d07081ec4248"><td class="memItemLeft" align="right" valign="top"><a id="a968066c430fa50f96fb3d07081ec4248" name="a968066c430fa50f96fb3d07081ec4248"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>inode_4_test_type</b> = <a class="el" href="classunodb_1_1detail_1_1inode__4.html">inode_4</a>&lt; std::uint64_t, <a class="el" href="namespaceunodb.html#ae25127f715f2aac269da8a3616284c0b">unodb::value_view</a> &gt;</td></tr>
<tr class="separator:a968066c430fa50f96fb3d07081ec4248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6444efb5500aedbc0fa283f4a4792b" id="r_a9a6444efb5500aedbc0fa283f4a4792b"><td class="memTemplParams" colspan="2"><a id="a9a6444efb5500aedbc0fa283f4a4792b" name="a9a6444efb5500aedbc0fa283f4a4792b"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a9a6444efb5500aedbc0fa283f4a4792b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inode_16_parent</b> = <a class="el" href="classunodb_1_1detail_1_1basic__inode__16.html">basic_inode_16</a>&lt; <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">art_policy</a>&lt; Key, Value &gt; &gt;</td></tr>
<tr class="separator:a9a6444efb5500aedbc0fa283f4a4792b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332b76e662f000a6ffd8e4d94c370e7d" id="r_a332b76e662f000a6ffd8e4d94c370e7d"><td class="memTemplParams" colspan="2"><a id="a332b76e662f000a6ffd8e4d94c370e7d" name="a332b76e662f000a6ffd8e4d94c370e7d"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a332b76e662f000a6ffd8e4d94c370e7d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inode_48_parent</b> = <a class="el" href="classunodb_1_1detail_1_1basic__inode__48.html">basic_inode_48</a>&lt; <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">art_policy</a>&lt; Key, Value &gt; &gt;</td></tr>
<tr class="separator:a332b76e662f000a6ffd8e4d94c370e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa12022c4d1f89180ab68508598ba7b3" id="r_aaa12022c4d1f89180ab68508598ba7b3"><td class="memItemLeft" align="right" valign="top"><a id="aaa12022c4d1f89180ab68508598ba7b3" name="aaa12022c4d1f89180ab68508598ba7b3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>inode_48_test_type</b> = <a class="el" href="classunodb_1_1detail_1_1inode__48.html">inode_48</a>&lt; std::uint64_t, <a class="el" href="namespaceunodb.html#ae25127f715f2aac269da8a3616284c0b">unodb::value_view</a> &gt;</td></tr>
<tr class="separator:aaa12022c4d1f89180ab68508598ba7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1290fecb62dd3c992776fb4ea5793e2" id="r_af1290fecb62dd3c992776fb4ea5793e2"><td class="memTemplParams" colspan="2"><a id="af1290fecb62dd3c992776fb4ea5793e2" name="af1290fecb62dd3c992776fb4ea5793e2"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:af1290fecb62dd3c992776fb4ea5793e2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inode_256_parent</b> = <a class="el" href="classunodb_1_1detail_1_1basic__inode__256.html">basic_inode_256</a>&lt; <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">art_policy</a>&lt; Key, Value &gt; &gt;</td></tr>
<tr class="separator:af1290fecb62dd3c992776fb4ea5793e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b1873633c46b13271dcf06ac743666" id="r_a85b1873633c46b13271dcf06ac743666"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Value , class Header , template&lt; typename, typename &gt; class Db&gt; </td></tr>
<tr class="memitem:a85b1873633c46b13271dcf06ac743666"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#a85b1873633c46b13271dcf06ac743666">basic_db_leaf_unique_ptr</a> = std::unique_ptr&lt; <a class="el" href="classunodb_1_1detail_1_1basic__leaf.html">basic_leaf</a>&lt; Key, Header &gt;, <a class="el" href="classunodb_1_1detail_1_1basic__db__leaf__deleter.html">basic_db_leaf_deleter</a>&lt; Db&lt; Key, Value &gt; &gt; &gt;</td></tr>
<tr class="memdesc:a85b1873633c46b13271dcf06ac743666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique pointer to leaf with database-aware deleter.  <br /></td></tr>
<tr class="separator:a85b1873633c46b13271dcf06ac743666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a48856979c828fe6f91a83b8b43e0be" id="r_a2a48856979c828fe6f91a83b8b43e0be"><td class="memItemLeft" align="right" valign="top"><a id="a2a48856979c828fe6f91a83b8b43e0be" name="a2a48856979c828fe6f91a83b8b43e0be"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_prefix_size</b> = std::uint8_t</td></tr>
<tr class="separator:a2a48856979c828fe6f91a83b8b43e0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52168a8b4ef78db5b5cdc3f60a97eb38" id="r_a52168a8b4ef78db5b5cdc3f60a97eb38"><td class="memTemplParams" colspan="2"><a id="a52168a8b4ef78db5b5cdc3f60a97eb38" name="a52168a8b4ef78db5b5cdc3f60a97eb38"></a>
template&lt;class NodeHeader &gt; </td></tr>
<tr class="memitem:a52168a8b4ef78db5b5cdc3f60a97eb38"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>iter_result_opt</b> = std::optional&lt; <a class="el" href="structunodb_1_1detail_1_1iter__result.html">iter_result</a>&lt; NodeHeader &gt; &gt;</td></tr>
<tr class="separator:a52168a8b4ef78db5b5cdc3f60a97eb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037f39940ab0ed860b951257770afe9b" id="r_a037f39940ab0ed860b951257770afe9b"><td class="memTemplParams" colspan="2"><a id="a037f39940ab0ed860b951257770afe9b" name="a037f39940ab0ed860b951257770afe9b"></a>
template&lt;class ArtPolicy &gt; </td></tr>
<tr class="memitem:a037f39940ab0ed860b951257770afe9b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>basic_inode_4_parent</b> = <a class="el" href="classunodb_1_1detail_1_1basic__inode.html">basic_inode</a>&lt; ArtPolicy, 2, 4, <a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3a3542ac61a301c83960ca9c44a79260e9">node_type::I4</a>, <a class="el" href="classunodb_1_1detail_1_1fake__inode.html">fake_inode</a>, typename ArtPolicy::inode16_type, typename ArtPolicy::inode4_type &gt;</td></tr>
<tr class="separator:a037f39940ab0ed860b951257770afe9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39f8ebe46749af5895e69f8b49ef1b0" id="r_ad39f8ebe46749af5895e69f8b49ef1b0"><td class="memTemplParams" colspan="2"><a id="ad39f8ebe46749af5895e69f8b49ef1b0" name="ad39f8ebe46749af5895e69f8b49ef1b0"></a>
template&lt;class ArtPolicy &gt; </td></tr>
<tr class="memitem:ad39f8ebe46749af5895e69f8b49ef1b0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>basic_inode_16_parent</b> = <a class="el" href="classunodb_1_1detail_1_1basic__inode.html">basic_inode</a>&lt; ArtPolicy, 5, 16, <a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3abcd774f891b5f9df7099f3ea75dadf8d">node_type::I16</a>, typename ArtPolicy::inode4_type, typename ArtPolicy::inode48_type, typename ArtPolicy::inode16_type &gt;</td></tr>
<tr class="separator:ad39f8ebe46749af5895e69f8b49ef1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf738b8ea5a62ab94eb490521f021d4" id="r_a4bf738b8ea5a62ab94eb490521f021d4"><td class="memTemplParams" colspan="2"><a id="a4bf738b8ea5a62ab94eb490521f021d4" name="a4bf738b8ea5a62ab94eb490521f021d4"></a>
template&lt;class ArtPolicy &gt; </td></tr>
<tr class="memitem:a4bf738b8ea5a62ab94eb490521f021d4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>basic_inode_48_parent</b> = <a class="el" href="classunodb_1_1detail_1_1basic__inode.html">basic_inode</a>&lt; ArtPolicy, 17, 48, <a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3a62e917add11d7e69f1356f76800cd084">node_type::I48</a>, typename ArtPolicy::inode16_type, typename ArtPolicy::inode256_type, typename ArtPolicy::inode48_type &gt;</td></tr>
<tr class="separator:a4bf738b8ea5a62ab94eb490521f021d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9ec247e08423b7456c02d0234e41ab" id="r_a7a9ec247e08423b7456c02d0234e41ab"><td class="memTemplParams" colspan="2"><a id="a7a9ec247e08423b7456c02d0234e41ab" name="a7a9ec247e08423b7456c02d0234e41ab"></a>
template&lt;class ArtPolicy &gt; </td></tr>
<tr class="memitem:a7a9ec247e08423b7456c02d0234e41ab"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>basic_inode_256_parent</b> = <a class="el" href="classunodb_1_1detail_1_1basic__inode.html">basic_inode</a>&lt; ArtPolicy, 49, 256, <a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3a4db1a4fc0ba7faa34813bde8556fccda">node_type::I256</a>, typename ArtPolicy::inode48_type, <a class="el" href="classunodb_1_1detail_1_1fake__inode.html">fake_inode</a>, typename ArtPolicy::inode256_type &gt;</td></tr>
<tr class="separator:a7a9ec247e08423b7456c02d0234e41ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af9f878124c38ae4be2fc686e0cbdec" id="r_a6af9f878124c38ae4be2fc686e0cbdec"><td class="memTemplParams" colspan="2"><a id="a6af9f878124c38ae4be2fc686e0cbdec" name="a6af9f878124c38ae4be2fc686e0cbdec"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a6af9f878124c38ae4be2fc686e0cbdec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>olc_inode_defs</b> = <a class="el" href="structunodb_1_1detail_1_1basic__inode__def.html">basic_inode_def</a>&lt; <a class="el" href="classunodb_1_1detail_1_1olc__inode.html">olc_inode</a>&lt; Key, Value &gt;, <a class="el" href="classunodb_1_1detail_1_1olc__inode__4.html">olc_inode_4</a>&lt; Key, Value &gt;, <a class="el" href="classunodb_1_1detail_1_1olc__inode__16.html">olc_inode_16</a>&lt; Key, Value &gt;, <a class="el" href="classunodb_1_1detail_1_1olc__inode__48.html">olc_inode_48</a>&lt; Key, Value &gt;, <a class="el" href="classunodb_1_1detail_1_1olc__inode__256.html">olc_inode_256</a>&lt; Key, Value &gt; &gt;</td></tr>
<tr class="separator:a6af9f878124c38ae4be2fc686e0cbdec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803cfe31d9bfd152cfff50359a30d70f" id="r_a803cfe31d9bfd152cfff50359a30d70f"><td class="memItemLeft" align="right" valign="top"><a id="a803cfe31d9bfd152cfff50359a30d70f" name="a803cfe31d9bfd152cfff50359a30d70f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>olc_node_ptr</b> = <a class="el" href="classunodb_1_1detail_1_1basic__node__ptr.html">basic_node_ptr</a>&lt; <a class="el" href="structunodb_1_1detail_1_1olc__node__header.html">olc_node_header</a> &gt;</td></tr>
<tr class="separator:a803cfe31d9bfd152cfff50359a30d70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7eaaa6ba010012faff7b7fb4b84704" id="r_afc7eaaa6ba010012faff7b7fb4b84704"><td class="memTemplParams" colspan="2"><a id="afc7eaaa6ba010012faff7b7fb4b84704" name="afc7eaaa6ba010012faff7b7fb4b84704"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:afc7eaaa6ba010012faff7b7fb4b84704"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>olc_art_policy</b> = <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">basic_art_policy</a>&lt; Key, Value, <a class="el" href="classunodb_1_1olc__db.html">unodb::olc_db</a>, <a class="el" href="classunodb_1_1in__critical__section.html">unodb::in_critical_section</a>, <a class="el" href="classunodb_1_1optimistic__lock.html">unodb::optimistic_lock</a>, <a class="el" href="classunodb_1_1optimistic__lock_1_1read__critical__section.html">unodb::optimistic_lock::read_critical_section</a>, <a class="el" href="classunodb_1_1detail_1_1basic__node__ptr.html">olc_node_ptr</a>, <a class="el" href="structunodb_1_1detail_1_1basic__inode__def.html">olc_inode_defs</a>, <a class="el" href="classunodb_1_1detail_1_1db__inode__qsbr__deleter.html">db_inode_qsbr_deleter</a>, <a class="el" href="classunodb_1_1detail_1_1db__leaf__qsbr__deleter.html">db_leaf_qsbr_deleter</a> &gt;</td></tr>
<tr class="separator:afc7eaaa6ba010012faff7b7fb4b84704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5911d77bb943df9b6f17776f1b7d1bb7" id="r_a5911d77bb943df9b6f17776f1b7d1bb7"><td class="memTemplParams" colspan="2"><a id="a5911d77bb943df9b6f17776f1b7d1bb7" name="a5911d77bb943df9b6f17776f1b7d1bb7"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a5911d77bb943df9b6f17776f1b7d1bb7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>olc_db_leaf_unique_ptr</b> = typename <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">olc_art_policy</a>&lt; Key, Value &gt;::db_leaf_unique_ptr</td></tr>
<tr class="separator:a5911d77bb943df9b6f17776f1b7d1bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a61a6808c8e6f7ad169a8f13488bc1" id="r_aa9a61a6808c8e6f7ad169a8f13488bc1"><td class="memTemplParams" colspan="2"><a id="aa9a61a6808c8e6f7ad169a8f13488bc1" name="aa9a61a6808c8e6f7ad169a8f13488bc1"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:aa9a61a6808c8e6f7ad169a8f13488bc1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>olc_inode_base</b> = <a class="el" href="classunodb_1_1detail_1_1basic__inode__impl.html">basic_inode_impl</a>&lt; <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">olc_art_policy</a>&lt; Key, Value &gt; &gt;</td></tr>
<tr class="separator:aa9a61a6808c8e6f7ad169a8f13488bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976629fcee449564c59c652e462d38a0" id="r_a976629fcee449564c59c652e462d38a0"><td class="memTemplParams" colspan="2"><a id="a976629fcee449564c59c652e462d38a0" name="a976629fcee449564c59c652e462d38a0"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a976629fcee449564c59c652e462d38a0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>olc_leaf_type</b> = typename <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">olc_art_policy</a>&lt; Key, Value &gt;::leaf_type</td></tr>
<tr class="separator:a976629fcee449564c59c652e462d38a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6accd1ac0f833ad2a37a7f63e1bb9ad3" id="r_a6accd1ac0f833ad2a37a7f63e1bb9ad3"><td class="memTemplParams" colspan="2"><a id="a6accd1ac0f833ad2a37a7f63e1bb9ad3" name="a6accd1ac0f833ad2a37a7f63e1bb9ad3"></a>
template&lt;class AtomicArray &gt; </td></tr>
<tr class="memitem:a6accd1ac0f833ad2a37a7f63e1bb9ad3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>non_atomic_array</b> = std::array&lt; typename AtomicArray::value_type::value_type, std::tuple_size&lt; AtomicArray &gt;::value &gt;</td></tr>
<tr class="separator:a6accd1ac0f833ad2a37a7f63e1bb9ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9e8892527b0164dc1b8b2b177cc28e" id="r_adc9e8892527b0164dc1b8b2b177cc28e"><td class="memTemplParams" colspan="2"><a id="adc9e8892527b0164dc1b8b2b177cc28e" name="adc9e8892527b0164dc1b8b2b177cc28e"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:adc9e8892527b0164dc1b8b2b177cc28e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>olc_leaf_unique_ptr</b> = <a class="el" href="namespaceunodb_1_1detail.html#a85b1873633c46b13271dcf06ac743666">basic_db_leaf_unique_ptr</a>&lt; Key, Value, <a class="el" href="structunodb_1_1detail_1_1olc__node__header.html">olc_node_header</a>, <a class="el" href="classunodb_1_1olc__db.html">olc_db</a> &gt;</td></tr>
<tr class="separator:adc9e8892527b0164dc1b8b2b177cc28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a5507008263301357281c328968601" id="r_a32a5507008263301357281c328968601"><td class="memTemplParams" colspan="2"><a id="a32a5507008263301357281c328968601" name="a32a5507008263301357281c328968601"></a>
template&lt;typename Key , typename Value , class INode &gt; </td></tr>
<tr class="memitem:a32a5507008263301357281c328968601"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>db_inode_qsbr_deleter_parent</b> = <a class="el" href="classunodb_1_1detail_1_1basic__db__inode__deleter.html">unodb::detail::basic_db_inode_deleter</a>&lt; INode, <a class="el" href="classunodb_1_1olc__db.html">unodb::olc_db</a>&lt; Key, Value &gt; &gt;</td></tr>
<tr class="separator:a32a5507008263301357281c328968601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2daa87032220b0bbd414ed7e91c0a3ec" id="r_a2daa87032220b0bbd414ed7e91c0a3ec"><td class="memTemplParams" colspan="2"><a id="a2daa87032220b0bbd414ed7e91c0a3ec" name="a2daa87032220b0bbd414ed7e91c0a3ec"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a2daa87032220b0bbd414ed7e91c0a3ec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>olc_inode_4_parent</b> = <a class="el" href="classunodb_1_1detail_1_1basic__inode__4.html">basic_inode_4</a>&lt; <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">olc_art_policy</a>&lt; Key, Value &gt; &gt;</td></tr>
<tr class="separator:a2daa87032220b0bbd414ed7e91c0a3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd1f1cc605b5de4a4b662f2982bf64e" id="r_a5cd1f1cc605b5de4a4b662f2982bf64e"><td class="memItemLeft" align="right" valign="top"><a id="a5cd1f1cc605b5de4a4b662f2982bf64e" name="a5cd1f1cc605b5de4a4b662f2982bf64e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>olc_inode_4_test_type</b> = <a class="el" href="classunodb_1_1detail_1_1olc__inode__4.html">olc_inode_4</a>&lt; std::uint64_t, <a class="el" href="namespaceunodb.html#ae25127f715f2aac269da8a3616284c0b">unodb::value_view</a> &gt;</td></tr>
<tr class="separator:a5cd1f1cc605b5de4a4b662f2982bf64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3221164cddf47d6ecc6a42dfa1dcbbda" id="r_a3221164cddf47d6ecc6a42dfa1dcbbda"><td class="memTemplParams" colspan="2"><a id="a3221164cddf47d6ecc6a42dfa1dcbbda" name="a3221164cddf47d6ecc6a42dfa1dcbbda"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a3221164cddf47d6ecc6a42dfa1dcbbda"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>olc_inode_16_parent</b> = <a class="el" href="classunodb_1_1detail_1_1basic__inode__16.html">basic_inode_16</a>&lt; <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">olc_art_policy</a>&lt; Key, Value &gt; &gt;</td></tr>
<tr class="separator:a3221164cddf47d6ecc6a42dfa1dcbbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af986db1bf730fa049317b3b1ee19b6fd" id="r_af986db1bf730fa049317b3b1ee19b6fd"><td class="memItemLeft" align="right" valign="top"><a id="af986db1bf730fa049317b3b1ee19b6fd" name="af986db1bf730fa049317b3b1ee19b6fd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>olc_inode_16_test_type</b> = <a class="el" href="classunodb_1_1detail_1_1olc__inode__16.html">olc_inode_16</a>&lt; std::uint64_t, <a class="el" href="namespaceunodb.html#ae25127f715f2aac269da8a3616284c0b">unodb::value_view</a> &gt;</td></tr>
<tr class="separator:af986db1bf730fa049317b3b1ee19b6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cd0b497d4ddebc9ac2b9bbf9235ed6" id="r_a07cd0b497d4ddebc9ac2b9bbf9235ed6"><td class="memTemplParams" colspan="2"><a id="a07cd0b497d4ddebc9ac2b9bbf9235ed6" name="a07cd0b497d4ddebc9ac2b9bbf9235ed6"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a07cd0b497d4ddebc9ac2b9bbf9235ed6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>olc_inode_48_parent</b> = <a class="el" href="classunodb_1_1detail_1_1basic__inode__48.html">basic_inode_48</a>&lt; <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">olc_art_policy</a>&lt; Key, Value &gt; &gt;</td></tr>
<tr class="separator:a07cd0b497d4ddebc9ac2b9bbf9235ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46066ca6db85223001a2a12d2892b8f6" id="r_a46066ca6db85223001a2a12d2892b8f6"><td class="memItemLeft" align="right" valign="top"><a id="a46066ca6db85223001a2a12d2892b8f6" name="a46066ca6db85223001a2a12d2892b8f6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>olc_inode_48_test_type</b> = <a class="el" href="classunodb_1_1detail_1_1olc__inode__48.html">olc_inode_48</a>&lt; std::uint64_t, <a class="el" href="namespaceunodb.html#ae25127f715f2aac269da8a3616284c0b">unodb::value_view</a> &gt;</td></tr>
<tr class="separator:a46066ca6db85223001a2a12d2892b8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe36625ac20f7ced77f37054bda2a11" id="r_a3fe36625ac20f7ced77f37054bda2a11"><td class="memTemplParams" colspan="2"><a id="a3fe36625ac20f7ced77f37054bda2a11" name="a3fe36625ac20f7ced77f37054bda2a11"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a3fe36625ac20f7ced77f37054bda2a11"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>olc_inode_256_parent</b> = <a class="el" href="classunodb_1_1detail_1_1basic__inode__256.html">basic_inode_256</a>&lt; <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html">olc_art_policy</a>&lt; Key, Value &gt; &gt;</td></tr>
<tr class="separator:a3fe36625ac20f7ced77f37054bda2a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef6e7104112ec675df54cac9eeece1c" id="r_a2ef6e7104112ec675df54cac9eeece1c"><td class="memItemLeft" align="right" valign="top"><a id="a2ef6e7104112ec675df54cac9eeece1c" name="a2ef6e7104112ec675df54cac9eeece1c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>olc_inode_256_test_type</b> = <a class="el" href="classunodb_1_1detail_1_1olc__inode__256.html">olc_inode_256</a>&lt; std::uint64_t, <a class="el" href="namespaceunodb.html#ae25127f715f2aac269da8a3616284c0b">unodb::value_view</a> &gt;</td></tr>
<tr class="separator:a2ef6e7104112ec675df54cac9eeece1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c98952bb0651c3bd50ab5de879cfeff" id="r_a3c98952bb0651c3bd50ab5de879cfeff"><td class="memItemLeft" align="right" valign="top"><a id="a3c98952bb0651c3bd50ab5de879cfeff" name="a3c98952bb0651c3bd50ab5de879cfeff"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>dealloc_request_vector</b> = std::vector&lt; <a class="el" href="classunodb_1_1detail_1_1deallocation__request.html">deallocation_request</a> &gt;</td></tr>
<tr class="memdesc:a3c98952bb0651c3bd50ab5de879cfeff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of deallocation requests. <br /></td></tr>
<tr class="separator:a3c98952bb0651c3bd50ab5de879cfeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a315446f662ab93a69546e61c3c72a492" id="r_a315446f662ab93a69546e61c3c72a492"><td class="memItemLeft" align="right" valign="top"><a id="a315446f662ab93a69546e61c3c72a492" name="a315446f662ab93a69546e61c3c72a492"></a>
auto *&#160;</td><td class="memItemRight" valign="bottom"><b>unwrap_fake_critical_section</b> (<a class="el" href="classunodb_1_1in__fake__critical__section.html">unodb::in_fake_critical_section</a>&lt; <a class="el" href="classunodb_1_1detail_1_1basic__node__ptr.html">unodb::detail::node_ptr</a> &gt; *ptr) noexcept</td></tr>
<tr class="separator:a315446f662ab93a69546e61c3c72a492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea0a7a9ae7c67e2636bae1ca01e11fe" id="r_a0ea0a7a9ae7c67e2636bae1ca01e11fe"><td class="memItemLeft" align="right" valign="top"><a id="a0ea0a7a9ae7c67e2636bae1ca01e11fe" name="a0ea0a7a9ae7c67e2636bae1ca01e11fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump_byte</b> (std::ostream &amp;os, std::byte byte)</td></tr>
<tr class="memdesc:a0ea0a7a9ae7c67e2636bae1ca01e11fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump <em>byte</em> to <em>os</em> stream as a hexadecimal number. <br /></td></tr>
<tr class="separator:a0ea0a7a9ae7c67e2636bae1ca01e11fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815292cf4ea423f309805739554301b5" id="r_a815292cf4ea423f309805739554301b5"><td class="memItemLeft" align="right" valign="top"><a id="a815292cf4ea423f309805739554301b5" name="a815292cf4ea423f309805739554301b5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump_val</b> (std::ostream &amp;os, <a class="el" href="namespaceunodb.html#ae25127f715f2aac269da8a3616284c0b">unodb::value_view</a> v)</td></tr>
<tr class="memdesc:a815292cf4ea423f309805739554301b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump <em>v</em> to <em>os</em> as a sequence of bytes. <br /></td></tr>
<tr class="separator:a815292cf4ea423f309805739554301b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef7220cb1655f8cd8f759659bf99ab7" id="r_a0ef7220cb1655f8cd8f759659bf99ab7"><td class="memItemLeft" align="right" valign="top"><a id="a0ef7220cb1655f8cd8f759659bf99ab7" name="a0ef7220cb1655f8cd8f759659bf99ab7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump_key</b> (std::ostream &amp;os, <a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">key_view</a> key)</td></tr>
<tr class="memdesc:a0ef7220cb1655f8cd8f759659bf99ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump variable-length <em>key</em> to <em>os</em> as a sequence of bytes. <br /></td></tr>
<tr class="separator:a0ef7220cb1655f8cd8f759659bf99ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f442e3027e04156cef43a9b865a0c16" id="r_a3f442e3027e04156cef43a9b865a0c16"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3f442e3027e04156cef43a9b865a0c16"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#a3f442e3027e04156cef43a9b865a0c16">dump_key</a> (std::ostream &amp;os, T key)</td></tr>
<tr class="memdesc:a3f442e3027e04156cef43a9b865a0c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump <em>key</em> to <em>os</em> as a sequence of bytes.  <br /></td></tr>
<tr class="separator:a3f442e3027e04156cef43a9b865a0c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50fbbc0bfcabb917d60da68dd6ea193" id="r_ae50fbbc0bfcabb917d60da68dd6ea193"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#ae50fbbc0bfcabb917d60da68dd6ea193">ensure_capacity</a> (std::byte *&amp;buf, size_t &amp;cap, size_t off, size_t min_capacity)</td></tr>
<tr class="memdesc:ae50fbbc0bfcabb917d60da68dd6ea193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method for power of two expansion of buffers.  <br /></td></tr>
<tr class="separator:ae50fbbc0bfcabb917d60da68dd6ea193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d6d8602d9590be64fd0031611bbf07" id="r_a60d6d8602d9590be64fd0031611bbf07"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#a60d6d8602d9590be64fd0031611bbf07">compare</a> (const void *a, const size_t alen, const void *b, const size_t blen) noexcept</td></tr>
<tr class="memdesc:a60d6d8602d9590be64fd0031611bbf07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare byte spans lexicographically.  <br /></td></tr>
<tr class="separator:a60d6d8602d9590be64fd0031611bbf07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749463245ed07a65e2df960ac1beb847" id="r_a749463245ed07a65e2df960ac1beb847"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#a749463245ed07a65e2df960ac1beb847">compare</a> (const <a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">unodb::key_view</a> a, const <a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">unodb::key_view</a> b) noexcept</td></tr>
<tr class="memdesc:a749463245ed07a65e2df960ac1beb847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare key views lexicographically.  <br /></td></tr>
<tr class="separator:a749463245ed07a65e2df960ac1beb847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9586a5c7fc84c4bbc05b716fd1ce03" id="r_a7d9586a5c7fc84c4bbc05b716fd1ce03"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#a7d9586a5c7fc84c4bbc05b716fd1ce03">get_u64</a> (<a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">key_view</a> key) noexcept</td></tr>
<tr class="memdesc:a7d9586a5c7fc84c4bbc05b716fd1ce03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return first 64 bits of encoded <em>key</em> view.  <br /></td></tr>
<tr class="separator:a7d9586a5c7fc84c4bbc05b716fd1ce03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25eb4ea7710810f49fcc23353dad6c8f" id="r_a25eb4ea7710810f49fcc23353dad6c8f"><td class="memItemLeft" align="right" valign="top"><a id="a25eb4ea7710810f49fcc23353dad6c8f" name="a25eb4ea7710810f49fcc23353dad6c8f"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>_mm_cmple_epu8</b> (__m128i x, __m128i y) noexcept</td></tr>
<tr class="separator:a25eb4ea7710810f49fcc23353dad6c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c36ae56cc3f27abfb2624d79ff4be78" id="r_a4c36ae56cc3f27abfb2624d79ff4be78"><td class="memTemplParams" colspan="2"><a id="a4c36ae56cc3f27abfb2624d79ff4be78" name="a4c36ae56cc3f27abfb2624d79ff4be78"></a>
template&lt;typename Key , typename Value , template&lt; typename, typename &gt; class Db&gt; </td></tr>
<tr class="memitem:a4c36ae56cc3f27abfb2624d79ff4be78"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_db_leaf_ptr</b> (<a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">basic_art_key</a>&lt; Key &gt; k, <a class="el" href="namespaceunodb.html#ae25127f715f2aac269da8a3616284c0b">value_view</a> v, Db&lt; Key, Value &gt; &amp;<a class="el" href="classunodb_1_1db.html">db</a>)</td></tr>
<tr class="memdesc:a4c36ae56cc3f27abfb2624d79ff4be78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a unique pointer for a new leaf initialized with the caller's key and value. <br /></td></tr>
<tr class="separator:a4c36ae56cc3f27abfb2624d79ff4be78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70778153d340954b6f2718fd7f018a2" id="r_aa70778153d340954b6f2718fd7f018a2"><td class="memItemLeft" align="right" valign="top"><a id="aa70778153d340954b6f2718fd7f018a2" name="aa70778153d340954b6f2718fd7f018a2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>msg_stacktrace_abort</b> (std::string_view msg) noexcept</td></tr>
<tr class="memdesc:aa70778153d340954b6f2718fd7f018a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a message and a stacktrace to std::cerr, then abort. <br /></td></tr>
<tr class="separator:aa70778153d340954b6f2718fd7f018a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84376061f77319109e51399dd10a3135" id="r_a84376061f77319109e51399dd10a3135"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#a84376061f77319109e51399dd10a3135">cannot_happen</a> (const char *file, int line, const char *func) noexcept</td></tr>
<tr class="memdesc:a84376061f77319109e51399dd10a3135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for marking a source code location as unreachable.  <br /></td></tr>
<tr class="separator:a84376061f77319109e51399dd10a3135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5f331d83917453230a096af3197dc2" id="r_aae5f331d83917453230a096af3197dc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#aae5f331d83917453230a096af3197dc2">crash</a> (const char *file, int line, const char *func) noexcept</td></tr>
<tr class="memdesc:aae5f331d83917453230a096af3197dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intentionally crash from a given source location.  <br /></td></tr>
<tr class="separator:aae5f331d83917453230a096af3197dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ccae20a7fde29e0381b903bbf0c58a" id="r_a73ccae20a7fde29e0381b903bbf0c58a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#a73ccae20a7fde29e0381b903bbf0c58a">assert_failure</a> (const char *file, int line, const char *func, const char *condition) noexcept</td></tr>
<tr class="memdesc:a73ccae20a7fde29e0381b903bbf0c58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert failure implementation for standalone debug build.  <br /></td></tr>
<tr class="separator:a73ccae20a7fde29e0381b903bbf0c58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11dfd956f06126308971d516d631d85" id="r_aa11dfd956f06126308971d516d631d85"><td class="memTemplParams" colspan="2"><a id="aa11dfd956f06126308971d516d631d85" name="aa11dfd956f06126308971d516d631d85"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa11dfd956f06126308971d516d631d85"><td class="memTemplItemLeft" align="right" valign="top">consteval T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>msb</b> () noexcept</td></tr>
<tr class="memdesc:aa11dfd956f06126308971d516d631d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return value with most significant bit set for the indicated type <em>T</em>. <br /></td></tr>
<tr class="separator:aa11dfd956f06126308971d516d631d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a84ca13cdff9a7f70720ddb0041d0d1" id="r_a1a84ca13cdff9a7f70720ddb0041d0d1"><td class="memTemplParams" colspan="2">template&lt;typename U , typename F &gt; </td></tr>
<tr class="memitem:a1a84ca13cdff9a7f70720ddb0041d0d1"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#a1a84ca13cdff9a7f70720ddb0041d0d1">encode_floating_point</a> (F x) noexcept</td></tr>
<tr class="memdesc:a1a84ca13cdff9a7f70720ddb0041d0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode floating-point value to lexicographic sort key.  <br /></td></tr>
<tr class="separator:a1a84ca13cdff9a7f70720ddb0041d0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f7fa26a657bd2a5640cf369c639d17" id="r_a75f7fa26a657bd2a5640cf369c639d17"><td class="memTemplParams" colspan="2">template&lt;typename F , typename U &gt; </td></tr>
<tr class="memitem:a75f7fa26a657bd2a5640cf369c639d17"><td class="memTemplItemLeft" align="right" valign="top">F&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#a75f7fa26a657bd2a5640cf369c639d17">decode_floating_point</a> (U input) noexcept</td></tr>
<tr class="memdesc:a75f7fa26a657bd2a5640cf369c639d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert lexicographic sort key to original floating-point value.  <br /></td></tr>
<tr class="separator:a75f7fa26a657bd2a5640cf369c639d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942ec905f356c797a53d6a9bee4b168c" id="r_a942ec905f356c797a53d6a9bee4b168c"><td class="memTemplParams" colspan="2"><a id="a942ec905f356c797a53d6a9bee4b168c" name="a942ec905f356c797a53d6a9bee4b168c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a942ec905f356c797a53d6a9bee4b168c"><td class="memTemplItemLeft" align="right" valign="top">consteval std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>alignment_for_new</b> () noexcept</td></tr>
<tr class="memdesc:a942ec905f356c797a53d6a9bee4b168c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get minimum alignment to use when allocating objects of type <em>T</em>. <br /></td></tr>
<tr class="separator:a942ec905f356c797a53d6a9bee4b168c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67151fe8291fd24bff04038739700b1f" id="r_a67151fe8291fd24bff04038739700b1f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#a67151fe8291fd24bff04038739700b1f">allocate_aligned</a> (std::size_t size, std::size_t alignment=__STDCPP_DEFAULT_NEW_ALIGNMENT__)</td></tr>
<tr class="memdesc:a67151fe8291fd24bff04038739700b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate aligned heap memory.  <br /></td></tr>
<tr class="separator:a67151fe8291fd24bff04038739700b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857e30bf5bbe06e321300ee868010df9" id="r_a857e30bf5bbe06e321300ee868010df9"><td class="memItemLeft" align="right" valign="top"><a id="a857e30bf5bbe06e321300ee868010df9" name="a857e30bf5bbe06e321300ee868010df9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>free_aligned</b> (void *ptr) noexcept</td></tr>
<tr class="memdesc:a857e30bf5bbe06e321300ee868010df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free heap memory allocated with <a class="el" href="namespaceunodb_1_1detail.html#a67151fe8291fd24bff04038739700b1f" title="Allocate aligned heap memory.">allocate_aligned()</a>. <br /></td></tr>
<tr class="separator:a857e30bf5bbe06e321300ee868010df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3da3568c516e9447ccaa528462a136e" id="r_aa3da3568c516e9447ccaa528462a136e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3">node_type</a> NodeType&gt; </td></tr>
<tr class="memitem:aa3da3568c516e9447ccaa528462a136e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#aa3da3568c516e9447ccaa528462a136e">is_internal_static_assert</a> () noexcept</td></tr>
<tr class="memdesc:aa3da3568c516e9447ccaa528462a136e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically assert that <em>NodeType</em> is one of the internal node types.  <br /></td></tr>
<tr class="separator:aa3da3568c516e9447ccaa528462a136e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace283ba3cda1f0e8f2ddc1d3e5105110" id="r_ace283ba3cda1f0e8f2ddc1d3e5105110"><td class="memTemplParams" colspan="2"><a id="ace283ba3cda1f0e8f2ddc1d3e5105110" name="ace283ba3cda1f0e8f2ddc1d3e5105110"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ace283ba3cda1f0e8f2ddc1d3e5105110"><td class="memTemplItemLeft" align="right" valign="top">non_atomic_array&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_atomic_to_nonatomic</b> (T &amp;atomic_array) noexcept</td></tr>
<tr class="separator:ace283ba3cda1f0e8f2ddc1d3e5105110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ca7f940a88b617002ae98db439ff94" id="r_a13ca7f940a88b617002ae98db439ff94"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#a13ca7f940a88b617002ae98db439ff94">node_ptr_lock</a> (const <a class="el" href="classunodb_1_1detail_1_1basic__node__ptr.html">unodb::detail::olc_node_ptr</a> &amp;node) noexcept</td></tr>
<tr class="memdesc:a13ca7f940a88b617002ae98db439ff94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the <a class="el" href="classunodb_1_1optimistic__lock.html" title="Version-based optimistic lock that supports single-writer/multiple-readers concurrency without shared...">unodb::optimistic_lock</a> from the node header associated with the unodb::detail::olc_node_ptr.  <br /></td></tr>
<tr class="separator:a13ca7f940a88b617002ae98db439ff94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132d2b726bb9323596452c40eb48302b" id="r_a132d2b726bb9323596452c40eb48302b"><td class="memTemplParams" colspan="2"><a id="a132d2b726bb9323596452c40eb48302b" name="a132d2b726bb9323596452c40eb48302b"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a132d2b726bb9323596452c40eb48302b"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>node_ptr_lock</b> (const unodb::detail::olc_leaf_type&lt; Key, Value &gt; *const node) noexcept</td></tr>
<tr class="separator:a132d2b726bb9323596452c40eb48302b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71bff8be2258858c813735195423d216" id="r_a71bff8be2258858c813735195423d216"><td class="memTemplParams" colspan="2"><a id="a71bff8be2258858c813735195423d216" name="a71bff8be2258858c813735195423d216"></a>
template&lt;class INode &gt; </td></tr>
<tr class="memitem:a71bff8be2258858c813735195423d216"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lock</b> (const INode &amp;<a class="el" href="classunodb_1_1detail_1_1inode.html">inode</a>) noexcept</td></tr>
<tr class="separator:a71bff8be2258858c813735195423d216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edfb68fb566e194dae77eac5d0558ee" id="r_a0edfb68fb566e194dae77eac5d0558ee"><td class="memTemplParams" colspan="2"><a id="a0edfb68fb566e194dae77eac5d0558ee" name="a0edfb68fb566e194dae77eac5d0558ee"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a0edfb68fb566e194dae77eac5d0558ee"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>obsolete</b> (T &amp;t, <a class="el" href="classunodb_1_1optimistic__lock_1_1write__guard.html">unodb::optimistic_lock::write_guard</a> &amp;guard) noexcept</td></tr>
<tr class="separator:a0edfb68fb566e194dae77eac5d0558ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2f21cfd995a020eb66f0d5c6dac59f" id="r_a9c2f21cfd995a020eb66f0d5c6dac59f"><td class="memItemLeft" align="right" valign="top"><a id="a9c2f21cfd995a020eb66f0d5c6dac59f" name="a9c2f21cfd995a020eb66f0d5c6dac59f"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>obsolete_child_by_index</b> (std::uint8_t child, <a class="el" href="classunodb_1_1optimistic__lock_1_1write__guard.html">unodb::optimistic_lock::write_guard</a> &amp;guard) noexcept</td></tr>
<tr class="separator:a9c2f21cfd995a020eb66f0d5c6dac59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1748db6157f77efb62fa8097966b1a" id="r_a5e1748db6157f77efb62fa8097966b1a"><td class="memTemplParams" colspan="2"><a id="a5e1748db6157f77efb62fa8097966b1a" name="a5e1748db6157f77efb62fa8097966b1a"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a5e1748db6157f77efb62fa8097966b1a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_leaf_if_needed</b> (olc_db_leaf_unique_ptr&lt; Key, Value &gt; &amp;cached_leaf, <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">basic_art_key</a>&lt; Key &gt; k, <a class="el" href="namespaceunodb.html#ae25127f715f2aac269da8a3616284c0b">unodb::value_view</a> v, <a class="el" href="classunodb_1_1olc__db.html">unodb::olc_db</a>&lt; Key, Value &gt; &amp;db_instance)</td></tr>
<tr class="separator:a5e1748db6157f77efb62fa8097966b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac205dcfa11427da52c49ee216f264824" id="r_ac205dcfa11427da52c49ee216f264824"><td class="memTemplParams" colspan="2"><a id="ac205dcfa11427da52c49ee216f264824" name="ac205dcfa11427da52c49ee216f264824"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac205dcfa11427da52c49ee216f264824"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bswap</b> (T x) noexcept</td></tr>
<tr class="memdesc:ac205dcfa11427da52c49ee216f264824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the order of bytes in <em>x</em>. <br /></td></tr>
<tr class="separator:ac205dcfa11427da52c49ee216f264824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1bd0a219522dc54b6e2726f277e9677" id="r_ae1bd0a219522dc54b6e2726f277e9677"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:ae1bd0a219522dc54b6e2726f277e9677"><td class="memTemplItemLeft" align="right" valign="top">constexpr To&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#ae1bd0a219522dc54b6e2726f277e9677">bit_cast</a> (From input) noexcept</td></tr>
<tr class="memdesc:ae1bd0a219522dc54b6e2726f277e9677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinterpret object representation as a different type.  <br /></td></tr>
<tr class="separator:ae1bd0a219522dc54b6e2726f277e9677"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aba258d6d1df5e71714ec57d8b041b129" id="r_aba258d6d1df5e71714ec57d8b041b129"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#aba258d6d1df5e71714ec57d8b041b129">INITIAL_BUFFER_CAPACITY</a> = 256</td></tr>
<tr class="memdesc:aba258d6d1df5e71714ec57d8b041b129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial capacity for the <a class="el" href="classunodb_1_1key__encoder.html" title="A utility class to generate binary comparable keys from a sequence of key components.">unodb::key_encoder</a> and other similar internal buffers.  <br /></td></tr>
<tr class="separator:aba258d6d1df5e71714ec57d8b041b129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6affb48b09460b87dbcb8ab404f26263" id="r_a6affb48b09460b87dbcb8ab404f26263"><td class="memItemLeft" align="right" valign="top"><a id="a6affb48b09460b87dbcb8ab404f26263" name="a6affb48b09460b87dbcb8ab404f26263"></a>
static constexpr key_prefix_size&#160;</td><td class="memItemRight" valign="bottom"><b>key_prefix_capacity</b> = 7</td></tr>
<tr class="separator:a6affb48b09460b87dbcb8ab404f26263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81082c8f2c103492eb9f6917f0483bc" id="r_ad81082c8f2c103492eb9f6917f0483bc"><td class="memItemLeft" align="right" valign="top"><a id="ad81082c8f2c103492eb9f6917f0483bc" name="ad81082c8f2c103492eb9f6917f0483bc"></a>
constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>node_type_count</b> {5}</td></tr>
<tr class="memdesc:ad81082c8f2c103492eb9f6917f0483bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of different node types. <br /></td></tr>
<tr class="separator:ad81082c8f2c103492eb9f6917f0483bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11fc0dc02ee0b061504cd50856ea7dd" id="r_aa11fc0dc02ee0b061504cd50856ea7dd"><td class="memItemLeft" align="right" valign="top"><a id="aa11fc0dc02ee0b061504cd50856ea7dd" name="aa11fc0dc02ee0b061504cd50856ea7dd"></a>
constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>inode_type_count</b> {4}</td></tr>
<tr class="memdesc:aa11fc0dc02ee0b061504cd50856ea7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of different internal node types. <br /></td></tr>
<tr class="separator:aa11fc0dc02ee0b061504cd50856ea7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab520671507d4d7d913c5d2655fad89" id="r_a3ab520671507d4d7d913c5d2655fad89"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#a3ab520671507d4d7d913c5d2655fad89">hardware_constructive_interference_size</a></td></tr>
<tr class="memdesc:a3ab520671507d4d7d913c5d2655fad89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size in bytes where multiple variables will be guaranteed to be shared for the purposes of true sharing.  <br /></td></tr>
<tr class="separator:a3ab520671507d4d7d913c5d2655fad89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6387d4046bddd4f1d87150a2e6b94c" id="r_a4c6387d4046bddd4f1d87150a2e6b94c"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#a4c6387d4046bddd4f1d87150a2e6b94c">hardware_destructive_interference_size</a></td></tr>
<tr class="memdesc:a4c6387d4046bddd4f1d87150a2e6b94c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum size in bytes where multiple variables will be guaranteed to be separated for the purposes of false sharing.  <br /></td></tr>
<tr class="separator:a4c6387d4046bddd4f1d87150a2e6b94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a041b47bebde8ed0f3bd97327e450c" id="r_a04a041b47bebde8ed0f3bd97327e450c"><td class="memItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="classunodb_1_1detail_1_1thread__sync.html">thread_sync</a>, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunodb_1_1detail.html#a04a041b47bebde8ed0f3bd97327e450c">thread_syncs</a></td></tr>
<tr class="memdesc:a04a041b47bebde8ed0f3bd97327e450c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global array of thread synchronization objects.  <br /></td></tr>
<tr class="separator:a04a041b47bebde8ed0f3bd97327e450c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for the UnoDB internal implementation details. </p>
<p>It is not part of the public API, and it may change at any time. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a85b1873633c46b13271dcf06ac743666" name="a85b1873633c46b13271dcf06ac743666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b1873633c46b13271dcf06ac743666">&#9670;&#160;</a></span>basic_db_leaf_unique_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , class Header , template&lt; typename, typename &gt; class Db&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceunodb_1_1detail.html#a85b1873633c46b13271dcf06ac743666">unodb::detail::basic_db_leaf_unique_ptr</a> = typedef std::unique_ptr&lt;<a class="el" href="classunodb_1_1detail_1_1basic__leaf.html">basic_leaf</a>&lt;Key, Header&gt;, <a class="el" href="classunodb_1_1detail_1_1basic__db__leaf__deleter.html">basic_db_leaf_deleter</a>&lt;Db&lt;Key, Value&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unique pointer to leaf with database-aware deleter. </p>
<p>Not taken from Db to break a template dependency cycle.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>Key type </td></tr>
    <tr><td class="paramname">Value</td><td>Value type </td></tr>
    <tr><td class="paramname">Header</td><td>Node header type </td></tr>
    <tr><td class="paramname">Db</td><td>Database template </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a67151fe8291fd24bff04038739700b1f" name="a67151fe8291fd24bff04038739700b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67151fe8291fd24bff04038739700b1f">&#9670;&#160;</a></span>allocate_aligned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * unodb::detail::allocate_aligned </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>alignment</em> = <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate aligned heap memory. </p>
<p>The allocated block should be freed with <a class="el" href="namespaceunodb_1_1detail.html#a857e30bf5bbe06e321300ee868010df9" title="Free heap memory allocated with allocate_aligned().">free_aligned()</a>. In debug builds, the allocation failure injector is hooked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size of memory to allocate in bytes </td></tr>
    <tr><td class="paramname">alignment</td><td>Memory alignment boundary </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to allocated memory block </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">`std::bad_alloc`</td><td>if the allocation fails </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73ccae20a7fde29e0381b903bbf0c58a" name="a73ccae20a7fde29e0381b903bbf0c58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ccae20a7fde29e0381b903bbf0c58a">&#9670;&#160;</a></span>assert_failure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void unodb::detail::assert_failure </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assert failure implementation for standalone debug build. </p>
<p>Should not be called directly - used UNODB_DETAIL_ASSERT instead. </p>

</div>
</div>
<a id="ae1bd0a219522dc54b6e2726f277e9677" name="ae1bd0a219522dc54b6e2726f277e9677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1bd0a219522dc54b6e2726f277e9677">&#9670;&#160;</a></span>bit_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr To unodb::detail::bit_cast </td>
          <td>(</td>
          <td class="paramtype">From&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reinterpret object representation as a different type. </p>
<p>A replacement for <code>std::bit_cast</code> until it is provided by all supported compilers.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>Destination type for the conversion </td></tr>
    <tr><td class="paramname">From</td><td>Source type of the input value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Object to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object of type <em>To</em> with the same bit pattern as <em>input</em>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>sizeof(To) == sizeof(From)</code> </dd></dl>

</div>
</div>
<a id="a84376061f77319109e51399dd10a3135" name="a84376061f77319109e51399dd10a3135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84376061f77319109e51399dd10a3135">&#9670;&#160;</a></span>cannot_happen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void unodb::detail::cannot_happen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation for marking a source code location as unreachable. </p>
<p>Should not be called directly - use UNODB_DETAIL_CANNOT_HAPPEN instead. </p>

</div>
</div>
<a id="a749463245ed07a65e2df960ac1beb847" name="a749463245ed07a65e2df960ac1beb847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a749463245ed07a65e2df960ac1beb847">&#9670;&#160;</a></span>compare() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int unodb::detail::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">unodb::key_view</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">unodb::key_view</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare key views lexicographically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First key view </td></tr>
    <tr><td class="paramname">b</td><td>Second key view </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1, 0, or 1 if first key is LT, EQ, or GT second key </dd></dl>

</div>
</div>
<a id="a60d6d8602d9590be64fd0031611bbf07" name="a60d6d8602d9590be64fd0031611bbf07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d6d8602d9590be64fd0031611bbf07">&#9670;&#160;</a></span>compare() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int unodb::detail::compare </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>alen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>blen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare byte spans lexicographically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First byte sequence </td></tr>
    <tr><td class="paramname">alen</td><td>Length of first sequence </td></tr>
    <tr><td class="paramname">b</td><td>Second byte sequence </td></tr>
    <tr><td class="paramname">blen</td><td>Length of second sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1, 0, or 1 if first key is LT, EQ, or GT second key </dd></dl>

</div>
</div>
<a id="aae5f331d83917453230a096af3197dc2" name="aae5f331d83917453230a096af3197dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae5f331d83917453230a096af3197dc2">&#9670;&#160;</a></span>crash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void unodb::detail::crash </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intentionally crash from a given source location. </p>
<p>Should not be called directly - use UNODB_DETAIL_CRASH instead. </p>

</div>
</div>
<a id="a75f7fa26a657bd2a5640cf369c639d17" name="a75f7fa26a657bd2a5640cf369c639d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f7fa26a657bd2a5640cf369c639d17">&#9670;&#160;</a></span>decode_floating_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">F unodb::detail::decode_floating_point </td>
          <td>(</td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert lexicographic sort key to original floating-point value. </p>
<p>Reverses the encoding done by <a class="el" href="namespaceunodb_1_1detail.html#a1a84ca13cdff9a7f70720ddb0041d0d1" title="Encode floating-point value to lexicographic sort key.">encode_floating_point()</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The floating-point type to decode to </td></tr>
    <tr><td class="paramname">U</td><td>The unsigned integer type to decode from </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The lexicographic sort key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original floating-point value </dd></dl>

</div>
</div>
<a id="a3f442e3027e04156cef43a9b865a0c16" name="a3f442e3027e04156cef43a9b865a0c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f442e3027e04156cef43a9b865a0c16">&#9670;&#160;</a></span>dump_key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void unodb::detail::dump_key </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dump <em>key</em> to <em>os</em> as a sequence of bytes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>key type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a84ca13cdff9a7f70720ddb0041d0d1" name="a1a84ca13cdff9a7f70720ddb0041d0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a84ca13cdff9a7f70720ddb0041d0d1">&#9670;&#160;</a></span>encode_floating_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U unodb::detail::encode_floating_point </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode floating-point value to lexicographic sort key. </p>
<p>This encoding preserves the relative order of values - if a &lt; b for floating-point values, then encode(a) &lt; encode(b) for the integer encoded values.</p>
<p>The returned sort key can be converted back to the original value with <a class="el" href="namespaceunodb_1_1detail.html#a75f7fa26a657bd2a5640cf369c639d17" title="Convert lexicographic sort key to original floating-point value.">decode_floating_point()</a>.</p>
<p>Special values like NaN and infinity are handled specially:</p><ul>
<li>NaN is encoded as the maximum possible integer value</li>
<li>Positive infinity is encoded as maximum possible integer value minus 1</li>
<li>Negative infinity is encoded as 0</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The unsigned integer type to encode to </td></tr>
    <tr><td class="paramname">F</td><td>The floating-point type to encode from </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The floating-point value to encode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lexicographic sort key </dd></dl>

</div>
</div>
<a id="ae50fbbc0bfcabb917d60da68dd6ea193" name="ae50fbbc0bfcabb917d60da68dd6ea193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50fbbc0bfcabb917d60da68dd6ea193">&#9670;&#160;</a></span>ensure_capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void unodb::detail::ensure_capacity </td>
          <td>(</td>
          <td class="paramtype">std::byte *&amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>cap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility method for power of two expansion of buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to resize. </td></tr>
    <tr><td class="paramname">cap</td><td>The current buffer capacity. </td></tr>
    <tr><td class="paramname">off</td><td>The current number of used bytes. </td></tr>
    <tr><td class="paramname">min_capacity</td><td>The desired new minimum capacity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d9586a5c7fc84c4bbc05b716fd1ce03" name="a7d9586a5c7fc84c4bbc05b716fd1ce03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d9586a5c7fc84c4bbc05b716fd1ce03">&#9670;&#160;</a></span>get_u64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t unodb::detail::get_u64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">key_view</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return first 64 bits of encoded <em>key</em> view. </p>
<p>Used by prefix compression logic to identify bytes in common between an art_key and an inode having some <a class="el" href="unionunodb_1_1detail_1_1key__prefix.html" title="The unodb::detail::key_prefix is a sequence of zero or more bytes for a given node that are a common ...">key_prefix</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>First 64 bits of key, zero-padded if key is shorter </dd></dl>

</div>
</div>
<a id="aa3da3568c516e9447ccaa528462a136e" name="aa3da3568c516e9447ccaa528462a136e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3da3568c516e9447ccaa528462a136e">&#9670;&#160;</a></span>is_internal_static_assert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3">node_type</a> NodeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void unodb::detail::is_internal_static_assert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Statically assert that <em>NodeType</em> is one of the internal node types. </p>
<p>This function may not be executed, and only holds the static assert, because it is not an expression and thus cannot appear in expression contexts by itself. </p>

</div>
</div>
<a id="a13ca7f940a88b617002ae98db439ff94" name="a13ca7f940a88b617002ae98db439ff94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ca7f940a88b617002ae98db439ff94">&#9670;&#160;</a></span>node_ptr_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; unodb::detail::node_ptr_lock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classunodb_1_1detail_1_1basic__node__ptr.html">unodb::detail::olc_node_ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the <a class="el" href="classunodb_1_1optimistic__lock.html" title="Version-based optimistic lock that supports single-writer/multiple-readers concurrency without shared...">unodb::optimistic_lock</a> from the node header associated with the unodb::detail::olc_node_ptr. </p>
<dl class="section note"><dt>Note</dt><dd>This returns the lock rather than trying to acquire the lock. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a3ab520671507d4d7d913c5d2655fad89" name="a3ab520671507d4d7d913c5d2655fad89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab520671507d4d7d913c5d2655fad89">&#9670;&#160;</a></span>hardware_constructive_interference_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unodb::detail::hardware_constructive_interference_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum size in bytes where multiple variables will be guaranteed to be shared for the purposes of true sharing. </p>
<p>Use this instead of <code>std::hardware_constructive_interference_size</code> even if the latter is available, because it is used in public headers and its value may vary, for example, by GCC 12 or later <code>--param</code> or <code>-mtune</code> flag. </p>

</div>
</div>
<a id="a4c6387d4046bddd4f1d87150a2e6b94c" name="a4c6387d4046bddd4f1d87150a2e6b94c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6387d4046bddd4f1d87150a2e6b94c">&#9670;&#160;</a></span>hardware_destructive_interference_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unodb::detail::hardware_destructive_interference_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum size in bytes where multiple variables will be guaranteed to be separated for the purposes of false sharing. </p>
<p>Use this instead of <code>std::hardware_destructive_interference_size</code> even if the latter is available, because it is used in public headers and its value may vary, for example, by GCC 12 or later <code>--param</code> or <code>-mtune</code> flag. </p>

</div>
</div>
<a id="aba258d6d1df5e71714ec57d8b041b129" name="aba258d6d1df5e71714ec57d8b041b129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba258d6d1df5e71714ec57d8b041b129">&#9670;&#160;</a></span>INITIAL_BUFFER_CAPACITY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t unodb::detail::INITIAL_BUFFER_CAPACITY = 256</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initial capacity for the <a class="el" href="classunodb_1_1key__encoder.html" title="A utility class to generate binary comparable keys from a sequence of key components.">unodb::key_encoder</a> and other similar internal buffers. </p>
<p>It should be high enough that such objects DO NOT allocate for commonly used key lengths. These objects use an internal buffer of this capacity and then switch over to an explicitly allocated buffer if the capacity would be exceeded.</p>
<dl class="section note"><dt>Note</dt><dd>: If you are only using fixed width keys, then this can be sizeof(T). In typical scenarios these objects are on the stack and there is little if any penalty to having a larger initial capacity for these buffers. </dd></dl>

</div>
</div>
<a id="a04a041b47bebde8ed0f3bd97327e450c" name="a04a041b47bebde8ed0f3bd97327e450c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04a041b47bebde8ed0f3bd97327e450c">&#9670;&#160;</a></span>thread_syncs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;<a class="el" href="classunodb_1_1detail_1_1thread__sync.html">thread_sync</a>, 6&gt; unodb::detail::thread_syncs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Global array of thread synchronization objects. </p>
<p>The array size is determined by test needs. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceunodb.html">unodb</a></li><li class="navelem"><a class="el" href="namespaceunodb_1_1detail.html">detail</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
