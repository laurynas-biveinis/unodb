<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UnoDB: unodb::detail::basic_art_key&lt; KeyType &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">UnoDB
   </div>
   <div id="projectbrief">Adaptive Radix Tree in C++, optionally with Optimistic Lock Coupling</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structunodb_1_1detail_1_1basic__art__key.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="structunodb_1_1detail_1_1basic__art__key-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">unodb::detail::basic_art_key&lt; KeyType &gt; Struct Template Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Internal ART key in binary-comparable format.  
 <a href="structunodb_1_1detail_1_1basic__art__key.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="art__internal_8hpp_source.html">art_internal.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af0ee37f5a4106ac58fd5cecf5b22be4c" id="r_af0ee37f5a4106ac58fd5cecf5b22be4c"><td class="memTemplParams" colspan="2">template&lt;typename U  = KeyType, typename std::enable_if&lt; std::is_integral&lt; U &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:af0ee37f5a4106ac58fd5cecf5b22be4c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html#af0ee37f5a4106ac58fd5cecf5b22be4c">basic_art_key</a> (KeyType key_) noexcept</td></tr>
<tr class="memdesc:af0ee37f5a4106ac58fd5cecf5b22be4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct converts a fixed width primitive type into a lexicographically ordered key.  <br /></td></tr>
<tr class="separator:af0ee37f5a4106ac58fd5cecf5b22be4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd136279afad971b15c30847e2da1a6" id="r_adcd136279afad971b15c30847e2da1a6"><td class="memItemLeft" align="right" valign="top"><a id="adcd136279afad971b15c30847e2da1a6" name="adcd136279afad971b15c30847e2da1a6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>basic_art_key</b> (<a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">key_view</a> key_) noexcept</td></tr>
<tr class="memdesc:adcd136279afad971b15c30847e2da1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct converts a key_view which must already be lexicographically ordered. <br /></td></tr>
<tr class="separator:adcd136279afad971b15c30847e2da1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb7df8faa6c346f5b974a50dc1331b3" id="r_aaeb7df8faa6c346f5b974a50dc1331b3"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html#aaeb7df8faa6c346f5b974a50dc1331b3">cmp</a> (<a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">basic_art_key</a>&lt; KeyType &gt; key2) const noexcept</td></tr>
<tr class="separator:aaeb7df8faa6c346f5b974a50dc1331b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0b18ff7b89651418db68d8eb236519" id="r_a4c0b18ff7b89651418db68d8eb236519"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html#a4c0b18ff7b89651418db68d8eb236519">cmp</a> (<a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">key_view</a> key2) const noexcept</td></tr>
<tr class="separator:a4c0b18ff7b89651418db68d8eb236519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5234b1c24ea8029f6ca8a4ce3c4231f" id="r_aa5234b1c24ea8029f6ca8a4ce3c4231f"><td class="memItemLeft" align="right" valign="top"><a id="aa5234b1c24ea8029f6ca8a4ce3c4231f" name="aa5234b1c24ea8029f6ca8a4ce3c4231f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (std::size_t index) const noexcept</td></tr>
<tr class="memdesc:aa5234b1c24ea8029f6ca8a4ce3c4231f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the byte at the specified index position in the binary comparable key. <br /></td></tr>
<tr class="separator:aa5234b1c24ea8029f6ca8a4ce3c4231f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20e5187f7869ad48ab185a6fc09a61d" id="r_af20e5187f7869ad48ab185a6fc09a61d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">key_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html#af20e5187f7869ad48ab185a6fc09a61d">get_key_view</a> () const noexcept</td></tr>
<tr class="memdesc:af20e5187f7869ad48ab185a6fc09a61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the backing key_view.  <br /></td></tr>
<tr class="separator:af20e5187f7869ad48ab185a6fc09a61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54cec3bcc93c7e935445b0f8273942f" id="r_ac54cec3bcc93c7e935445b0f8273942f"><td class="memItemLeft" align="right" valign="top">constexpr std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html#ac54cec3bcc93c7e935445b0f8273942f">get_u64</a> () const noexcept</td></tr>
<tr class="memdesc:ac54cec3bcc93c7e935445b0f8273942f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first 64-bits (max) of the encoded key.  <br /></td></tr>
<tr class="separator:ac54cec3bcc93c7e935445b0f8273942f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883f9d04af426ae51af3b3f8b6c0026d" id="r_a883f9d04af426ae51af3b3f8b6c0026d"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html#a883f9d04af426ae51af3b3f8b6c0026d">shift_right</a> (const std::size_t num_bytes) noexcept</td></tr>
<tr class="memdesc:a883f9d04af426ae51af3b3f8b6c0026d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the internal key some number of bytes to the right (the leading bytes are discarded), causing the key to be shorter by that many bytes.  <br /></td></tr>
<tr class="separator:a883f9d04af426ae51af3b3f8b6c0026d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e070387a8d6335076f3d14bad7e7b25" id="r_a1e070387a8d6335076f3d14bad7e7b25"><td class="memItemLeft" align="right" valign="top"><a id="a1e070387a8d6335076f3d14bad7e7b25" name="a1e070387a8d6335076f3d14bad7e7b25"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const noexcept</td></tr>
<tr class="memdesc:a1e070387a8d6335076f3d14bad7e7b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of bytes required to represent the key. <br /></td></tr>
<tr class="separator:a1e070387a8d6335076f3d14bad7e7b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5a6bb536028d38b08447c64cd91cf1" id="r_a0a5a6bb536028d38b08447c64cd91cf1"><td class="memItemLeft" align="right" valign="top"><a id="a0a5a6bb536028d38b08447c64cd91cf1" name="a0a5a6bb536028d38b08447c64cd91cf1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump</b> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:a0a5a6bb536028d38b08447c64cd91cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">dump the key in lexicographic byte-wise order. <br /></td></tr>
<tr class="separator:a0a5a6bb536028d38b08447c64cd91cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cb5d0c123c5ff8fc83f2e724b0e4b6" id="r_aa8cb5d0c123c5ff8fc83f2e724b0e4b6"><td class="memItemLeft" align="right" valign="top"><a id="aa8cb5d0c123c5ff8fc83f2e724b0e4b6" name="aa8cb5d0c123c5ff8fc83f2e724b0e4b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump</b> () const</td></tr>
<tr class="memdesc:aa8cb5d0c123c5ff8fc83f2e724b0e4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for debugging, writes on std::cerr. <br /></td></tr>
<tr class="separator:aa8cb5d0c123c5ff8fc83f2e724b0e4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490eb34a936dde9580a0bee6096c8596" id="r_a490eb34a936dde9580a0bee6096c8596"><td class="memItemLeft" align="right" valign="top"><a id="a490eb34a936dde9580a0bee6096c8596" name="a490eb34a936dde9580a0bee6096c8596"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump</b> () const</td></tr>
<tr class="separator:a490eb34a936dde9580a0bee6096c8596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1eeceb64f9b2e4a61c3bfb7190defe" id="r_aff1eeceb64f9b2e4a61c3bfb7190defe"><td class="memItemLeft" align="right" valign="top"><a id="aff1eeceb64f9b2e4a61c3bfb7190defe" name="aff1eeceb64f9b2e4a61c3bfb7190defe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump</b> () const</td></tr>
<tr class="separator:aff1eeceb64f9b2e4a61c3bfb7190defe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7f533761914d776e97107316f117db14" id="r_a7f533761914d776e97107316f117db14"><td class="memItemLeft" align="right" valign="top"><a id="a7f533761914d776e97107316f117db14" name="a7f533761914d776e97107316f117db14"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>static_asserts</b> ()</td></tr>
<tr class="separator:a7f533761914d776e97107316f117db14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a783451041f4dab2a36a526115df72ace" id="r_a783451041f4dab2a36a526115df72ace"><td class="memItemLeft" ><a id="a783451041f4dab2a36a526115df72ace" name="a783451041f4dab2a36a526115df72ace"></a>
union {&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdd04bac3868f72a2e21db67efc2d8a" id="r_a7cdd04bac3868f72a2e21db67efc2d8a"><td class="memItemLeft" >&#160;&#160;&#160;KeyType&#160;&#160;&#160;<a class="el" href="structunodb_1_1detail_1_1basic__art__key.html#abc8d474caa99eac94a1b49eee7a9df07">key</a>&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="memdesc:a7cdd04bac3868f72a2e21db67efc2d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lexicographic byte-wise comparable binary key.  <a href="structunodb_1_1detail_1_1basic__art__key.html#abc8d474caa99eac94a1b49eee7a9df07">More...</a><br /></td></tr>
<tr class="separator:a7cdd04bac3868f72a2e21db67efc2d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f29b29e1ec9e9dc0d696fbdd26cc10" id="r_a77f29b29e1ec9e9dc0d696fbdd26cc10"><td class="memItemLeft" >&#160;&#160;&#160;std::array&lt; std::byte, sizeof(KeyType)&gt;&#160;&#160;&#160;<a class="el" href="structunodb_1_1detail_1_1basic__art__key.html#aa1c673bbd12a302556a7880df52aa9b8">key_bytes</a>&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="memdesc:a77f29b29e1ec9e9dc0d696fbdd26cc10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used iff the key is not a key_view.  <a href="structunodb_1_1detail_1_1basic__art__key.html#aa1c673bbd12a302556a7880df52aa9b8">More...</a><br /></td></tr>
<tr class="separator:a77f29b29e1ec9e9dc0d696fbdd26cc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783451041f4dab2a36a526115df72ace" id="r_a783451041f4dab2a36a526115df72ace"><td class="memItemLeft" valign="top">};&#160;</td><td class="memItemRight" valign="bottom">&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:a783451041f4dab2a36a526115df72ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a2424f684fcd0eb8c9af138caaf4befe5" id="r_a2424f684fcd0eb8c9af138caaf4befe5"><td class="memItemLeft" align="right" valign="top"><a id="a2424f684fcd0eb8c9af138caaf4befe5" name="a2424f684fcd0eb8c9af138caaf4befe5"></a>
static KeyType&#160;</td><td class="memItemRight" valign="bottom"><b>make_binary_comparable</b> (KeyType k) noexcept</td></tr>
<tr class="memdesc:a2424f684fcd0eb8c9af138caaf4befe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">ctor helper converts a simple external key into an internal key supporting lexicographic comparison. <br /></td></tr>
<tr class="separator:a2424f684fcd0eb8c9af138caaf4befe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a50cfab6fa641b1ea7a59abf19486e7a3" id="r_a50cfab6fa641b1ea7a59abf19486e7a3"><td class="memItemLeft" align="right" valign="top"><a id="a50cfab6fa641b1ea7a59abf19486e7a3" name="a50cfab6fa641b1ea7a59abf19486e7a3"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std ::ostream &amp;os, const <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">basic_art_key</a> &amp;k)</td></tr>
<tr class="separator:a50cfab6fa641b1ea7a59abf19486e7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename KeyType&gt;<br />
struct unodb::detail::basic_art_key&lt; KeyType &gt;</div><p>Internal ART key in binary-comparable format. </p>
<p>Application keys may be simple fixed width types (such as std::uint64_t) or variable length keys. For the former, there are convenience methods on db, <a class="el" href="classunodb_1_1olc__db.html" title="A thread-safe Adaptive Radix Tree that is synchronized using optimistic lock coupling.">olc_db</a>, etc. to convert external keys into the binary compariable format. For the latter, the application is responsible for converting the data (e.g., certain columns in some ordering for a row of some relation) into the internal binary comparable key format. A convenience class (<a class="el" href="classunodb_1_1key__encoder.html" title="A utility class to generate binary comparable keys from a sequence of key components.">unodb::key_encoder</a>) is offered to encode data. The encoding is always well defined and decoding (<a class="el" href="classunodb_1_1key__decoder.html" title="A utility class that can decode binary comparable keys as long as those keys (except for Unicode sort...">unodb::key_decoder</a>) exists for all simple fixed width data types. Unicode encoding is complex and out of scope - use a quality library such as ICU to produce appropriate Unicode sort keys for your application. Unicode decoding is NOT well defined. Applications involving database records and Unicode data will typically store the record identifier in a secondary index (ART) as the value associated with the key. Using the record identifier, the original tuple can be discovered and the original Unicode data recovered from that tuple. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af0ee37f5a4106ac58fd5cecf5b22be4c" name="af0ee37f5a4106ac58fd5cecf5b22be4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ee37f5a4106ac58fd5cecf5b22be4c">&#9670;&#160;</a></span>basic_art_key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
<div class="memtemplate">
template&lt;typename U  = KeyType, typename std::enable_if&lt; std::is_integral&lt; U &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">unodb::detail::basic_art_key</a>&lt; KeyType &gt;::basic_art_key </td>
          <td>(</td>
          <td class="paramtype">KeyType&#160;</td>
          <td class="paramname"><em>key_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct converts a fixed width primitive type into a lexicographically ordered key. </p>
<p>Note: Use a <a class="el" href="classunodb_1_1key__encoder.html" title="A utility class to generate binary comparable keys from a sequence of key components.">key_encoder</a> for complex keys, including multiple key components or Unicode data. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aaeb7df8faa6c346f5b974a50dc1331b3" name="aaeb7df8faa6c346f5b974a50dc1331b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb7df8faa6c346f5b974a50dc1331b3">&#9670;&#160;</a></span>cmp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">unodb::detail::basic_art_key</a>&lt; KeyType &gt;::cmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">basic_art_key</a>&lt; KeyType &gt;&#160;</td>
          <td class="paramname"><em>key2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>-1, 0, or 1 if this key is LT, EQ, or GT the other key. </dd></dl>

</div>
</div>
<a id="a4c0b18ff7b89651418db68d8eb236519" name="a4c0b18ff7b89651418db68d8eb236519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0b18ff7b89651418db68d8eb236519">&#9670;&#160;</a></span>cmp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">unodb::detail::basic_art_key</a>&lt; KeyType &gt;::cmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">key_view</a>&#160;</td>
          <td class="paramname"><em>key2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>-1, 0, or 1 if this key is LT, EQ, or GT the other key. </dd></dl>

</div>
</div>
<a id="af20e5187f7869ad48ab185a6fc09a61d" name="af20e5187f7869ad48ab185a6fc09a61d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af20e5187f7869ad48ab185a6fc09a61d">&#9670;&#160;</a></span>get_key_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">key_view</a> <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">unodb::detail::basic_art_key</a>&lt; KeyType &gt;::get_key_view </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the backing key_view. </p>
<p>Note: For integral keys, this is a non-owned view of the data in the <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html" title="Internal ART key in binary-comparable format.">basic_art_key</a> and will be invalid if that object goes out of scope.</p>
<p>Note: For key_view keys, this is the key_view backing this art_key and its validity depends on the scope of the backing byte array. </p>

</div>
</div>
<a id="ac54cec3bcc93c7e935445b0f8273942f" name="ac54cec3bcc93c7e935445b0f8273942f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54cec3bcc93c7e935445b0f8273942f">&#9670;&#160;</a></span>get_u64()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint64_t <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">unodb::detail::basic_art_key</a>&lt; KeyType &gt;::get_u64 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the first 64-bits (max) of the encoded key. </p>
<p>This is used by the prefix compression logic to identify some number of bytes that are in common between the art_key and an inode having some <a class="el" href="unionunodb_1_1detail_1_1key__prefix.html" title="The unodb::detail::key_prefix is a sequence of zero or more bytes for a given node that are a common ...">key_prefix</a>. </p>

</div>
</div>
<a id="a883f9d04af426ae51af3b3f8b6c0026d" name="a883f9d04af426ae51af3b3f8b6c0026d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883f9d04af426ae51af3b3f8b6c0026d">&#9670;&#160;</a></span>shift_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">unodb::detail::basic_art_key</a>&lt; KeyType &gt;::shift_right </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>num_bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift the internal key some number of bytes to the right (the leading bytes are discarded), causing the key to be shorter by that many bytes. </p>
<p>It is a lexicographic key. The first byte is the most significant. The last byte is the least significant.</p>
<p>When backed by a u64, we get trailing bytes which are zeros. Thus, for a fixed width type, this causes the key to be logically zero filled as it becomes shorter. E.g.</p>
<p><code>0x0011223344556677 shift_right(2) =&gt; 0x2233445566770000</code> </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="abc8d474caa99eac94a1b49eee7a9df07" name="abc8d474caa99eac94a1b49eee7a9df07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8d474caa99eac94a1b49eee7a9df07">&#9670;&#160;</a></span>key</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KeyType <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">unodb::detail::basic_art_key</a>&lt; KeyType &gt;::key</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The lexicographic byte-wise comparable binary key. </p>
<p>Note: When KeyType == key_view, this is all you need. </p>

</div>
</div>
<a id="aa1c673bbd12a302556a7880df52aa9b8" name="aa1c673bbd12a302556a7880df52aa9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c673bbd12a302556a7880df52aa9b8">&#9670;&#160;</a></span>key_bytes</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::byte, sizeof(KeyType)&gt; <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">unodb::detail::basic_art_key</a>&lt; KeyType &gt;::key_bytes</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used iff the key is not a key_view. </p>
<p>This provides a mechanism to index into the bytes in the key for operator[]. This is ignored if KeyType==key_view as the key_view provides a byte-wise index operator already. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="art__internal_8hpp_source.html">art_internal.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceunodb.html">unodb</a></li><li class="navelem"><a class="el" href="namespaceunodb_1_1detail.html">detail</a></li><li class="navelem"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">basic_art_key</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
