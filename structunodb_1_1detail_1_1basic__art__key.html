<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UnoDB: unodb::detail::basic_art_key&lt; KeyType &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">UnoDB
   </div>
   <div id="projectbrief">Adaptive Radix Tree in C++, optionally with Optimistic Lock Coupling</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structunodb_1_1detail_1_1basic__art__key.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="structunodb_1_1detail_1_1basic__art__key-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">unodb::detail::basic_art_key&lt; KeyType &gt; Struct Template Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Internal ART key in binary-comparable format.  
 <a href="structunodb_1_1detail_1_1basic__art__key.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="art__internal_8hpp_source.html">art_internal.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af0ee37f5a4106ac58fd5cecf5b22be4c" id="r_af0ee37f5a4106ac58fd5cecf5b22be4c"><td class="memTemplParams" colspan="2">template&lt;typename U  = KeyType, typename std::enable_if&lt; std::is_integral&lt; U &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:af0ee37f5a4106ac58fd5cecf5b22be4c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html#af0ee37f5a4106ac58fd5cecf5b22be4c">basic_art_key</a> (KeyType key_) noexcept</td></tr>
<tr class="memdesc:af0ee37f5a4106ac58fd5cecf5b22be4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct converts a fixed width primitive type into a lexicographically ordered key.  <br /></td></tr>
<tr class="separator:af0ee37f5a4106ac58fd5cecf5b22be4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd136279afad971b15c30847e2da1a6" id="r_adcd136279afad971b15c30847e2da1a6"><td class="memItemLeft" align="right" valign="top"><a id="adcd136279afad971b15c30847e2da1a6" name="adcd136279afad971b15c30847e2da1a6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>basic_art_key</b> (<a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">key_view</a> key_) noexcept</td></tr>
<tr class="memdesc:adcd136279afad971b15c30847e2da1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct converts a key_view which must already be lexicographically ordered. <br /></td></tr>
<tr class="separator:adcd136279afad971b15c30847e2da1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb7df8faa6c346f5b974a50dc1331b3" id="r_aaeb7df8faa6c346f5b974a50dc1331b3"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html#aaeb7df8faa6c346f5b974a50dc1331b3">cmp</a> (<a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">basic_art_key</a>&lt; KeyType &gt; key2) const noexcept</td></tr>
<tr class="separator:aaeb7df8faa6c346f5b974a50dc1331b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0b18ff7b89651418db68d8eb236519" id="r_a4c0b18ff7b89651418db68d8eb236519"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html#a4c0b18ff7b89651418db68d8eb236519">cmp</a> (<a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">key_view</a> key2) const noexcept</td></tr>
<tr class="separator:a4c0b18ff7b89651418db68d8eb236519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5234b1c24ea8029f6ca8a4ce3c4231f" id="r_aa5234b1c24ea8029f6ca8a4ce3c4231f"><td class="memItemLeft" align="right" valign="top"><a id="aa5234b1c24ea8029f6ca8a4ce3c4231f" name="aa5234b1c24ea8029f6ca8a4ce3c4231f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (std::size_t index) const noexcept</td></tr>
<tr class="memdesc:aa5234b1c24ea8029f6ca8a4ce3c4231f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the byte at the specified index position in the binary comparable key. <br /></td></tr>
<tr class="separator:aa5234b1c24ea8029f6ca8a4ce3c4231f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20e5187f7869ad48ab185a6fc09a61d" id="r_af20e5187f7869ad48ab185a6fc09a61d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">key_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html#af20e5187f7869ad48ab185a6fc09a61d">get_key_view</a> () const noexcept</td></tr>
<tr class="memdesc:af20e5187f7869ad48ab185a6fc09a61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the backing key_view.  <br /></td></tr>
<tr class="separator:af20e5187f7869ad48ab185a6fc09a61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54cec3bcc93c7e935445b0f8273942f" id="r_ac54cec3bcc93c7e935445b0f8273942f"><td class="memItemLeft" align="right" valign="top">constexpr std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html#ac54cec3bcc93c7e935445b0f8273942f">get_u64</a> () const noexcept</td></tr>
<tr class="memdesc:ac54cec3bcc93c7e935445b0f8273942f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first 64-bits (max) of the encoded key.  <br /></td></tr>
<tr class="separator:ac54cec3bcc93c7e935445b0f8273942f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490eb34a936dde9580a0bee6096c8596" id="r_a490eb34a936dde9580a0bee6096c8596"><td class="memItemLeft" align="right" valign="top"><a id="a490eb34a936dde9580a0bee6096c8596" name="a490eb34a936dde9580a0bee6096c8596"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump</b> () const</td></tr>
<tr class="separator:a490eb34a936dde9580a0bee6096c8596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1eeceb64f9b2e4a61c3bfb7190defe" id="r_aff1eeceb64f9b2e4a61c3bfb7190defe"><td class="memItemLeft" align="right" valign="top"><a id="aff1eeceb64f9b2e4a61c3bfb7190defe" name="aff1eeceb64f9b2e4a61c3bfb7190defe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump</b> () const</td></tr>
<tr class="separator:aff1eeceb64f9b2e4a61c3bfb7190defe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a2424f684fcd0eb8c9af138caaf4befe5" id="r_a2424f684fcd0eb8c9af138caaf4befe5"><td class="memItemLeft" align="right" valign="top"><a id="a2424f684fcd0eb8c9af138caaf4befe5" name="a2424f684fcd0eb8c9af138caaf4befe5"></a>
static KeyType&#160;</td><td class="memItemRight" valign="bottom"><b>make_binary_comparable</b> (KeyType k) noexcept</td></tr>
<tr class="memdesc:a2424f684fcd0eb8c9af138caaf4befe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">ctor helper converts a simple external key into an internal key supporting lexicographic comparison. <br /></td></tr>
<tr class="separator:a2424f684fcd0eb8c9af138caaf4befe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename KeyType&gt;<br />
struct unodb::detail::basic_art_key&lt; KeyType &gt;</div><p>Internal ART key in binary-comparable format. </p>
<p>Application keys may be simple fixed width types (such as std::uint64_t) or variable length keys. For the former, there are convenience methods on db, <a class="el" href="classunodb_1_1olc__db.html" title="A thread-safe Adaptive Radix Tree that is synchronized using optimistic lock coupling.">olc_db</a>, etc. to convert external keys into the binary compariable format. For the latter, the application is responsible for converting the data (e.g., certain columns in some ordering for a row of some relation) into the internal binary comparable key format. A convenience class (<a class="el" href="classunodb_1_1key__encoder.html" title="Key encodes and key decoder.">unodb::key_encoder</a>) is offered to encode data. The encoding is always well defined and decoding (<a class="el" href="classunodb_1_1key__decoder.html" title="A utility class that can decode binary comparable keys as long as those keys (except for Unicode sort...">unodb::key_decoder</a>) exists for all simple fixed width data types. Unicode encoding is complex and out of scope - use a quality library such as ICU to produce appropriate Unicode sort keys for your application. Unicode decoding is NOT well defined. Applications involving database records and Unicode data will typically store the record identifier in a secondary index (ART) as the value associated with the key. Using the record identifier, the original tuple can be discovered and the original Unicode data recovered from that tuple. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af0ee37f5a4106ac58fd5cecf5b22be4c" name="af0ee37f5a4106ac58fd5cecf5b22be4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ee37f5a4106ac58fd5cecf5b22be4c">&#9670;&#160;</a></span>basic_art_key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
<div class="memtemplate">
template&lt;typename U  = KeyType, typename std::enable_if&lt; std::is_integral&lt; U &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">unodb::detail::basic_art_key</a>&lt; KeyType &gt;::basic_art_key </td>
          <td>(</td>
          <td class="paramtype">KeyType&#160;</td>
          <td class="paramname"><em>key_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct converts a fixed width primitive type into a lexicographically ordered key. </p>
<p>Note: Use a <a class="el" href="classunodb_1_1key__encoder.html" title="Key encodes and key decoder.">key_encoder</a> for complex keys, including multiple key components or Unicode data. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aaeb7df8faa6c346f5b974a50dc1331b3" name="aaeb7df8faa6c346f5b974a50dc1331b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb7df8faa6c346f5b974a50dc1331b3">&#9670;&#160;</a></span>cmp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">unodb::detail::basic_art_key</a>&lt; KeyType &gt;::cmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">basic_art_key</a>&lt; KeyType &gt;&#160;</td>
          <td class="paramname"><em>key2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>-1, 0, or 1 if this key is LT, EQ, or GT the other key. </dd></dl>

</div>
</div>
<a id="a4c0b18ff7b89651418db68d8eb236519" name="a4c0b18ff7b89651418db68d8eb236519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0b18ff7b89651418db68d8eb236519">&#9670;&#160;</a></span>cmp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">unodb::detail::basic_art_key</a>&lt; KeyType &gt;::cmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">key_view</a>&#160;</td>
          <td class="paramname"><em>key2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>-1, 0, or 1 if this key is LT, EQ, or GT the other key. </dd></dl>

</div>
</div>
<a id="af20e5187f7869ad48ab185a6fc09a61d" name="af20e5187f7869ad48ab185a6fc09a61d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af20e5187f7869ad48ab185a6fc09a61d">&#9670;&#160;</a></span>get_key_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">key_view</a> <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">unodb::detail::basic_art_key</a>&lt; KeyType &gt;::get_key_view </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the backing key_view. </p>
<p>Note: For integral keys, this is a non-owned view of the data in the <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html" title="Internal ART key in binary-comparable format.">basic_art_key</a> and will be invalid if that object goes out of scope.</p>
<p>Note: For key_view keys, this is the key_view backing this art_key and its validity depends on the scope of the backing byte array. </p>

</div>
</div>
<a id="ac54cec3bcc93c7e935445b0f8273942f" name="ac54cec3bcc93c7e935445b0f8273942f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54cec3bcc93c7e935445b0f8273942f">&#9670;&#160;</a></span>get_u64()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint64_t <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">unodb::detail::basic_art_key</a>&lt; KeyType &gt;::get_u64 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the first 64-bits (max) of the encoded key. </p>
<p>This is used by the prefix compression logic to identify some number of bytes that are in common between the art_key and an inode having some <a class="el" href="unionunodb_1_1detail_1_1key__prefix.html" title="The key_prefix is a sequence of zero or more bytes for a given node that are a common prefix shared b...">key_prefix</a>. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="art__internal_8hpp_source.html">art_internal.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceunodb.html">unodb</a></li><li class="navelem"><a class="el" href="namespaceunodb_1_1detail.html">detail</a></li><li class="navelem"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">basic_art_key</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
