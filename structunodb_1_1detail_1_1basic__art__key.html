<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UnoDB: unodb::detail::basic_art_key&lt; KeyType &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">UnoDB
   </div>
   <div id="projectbrief">Adaptive Radix Tree in C++, optionally with Optimistic Lock Coupling</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structunodb_1_1detail_1_1basic__art__key.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="structunodb_1_1detail_1_1basic__art__key-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">unodb::detail::basic_art_key&lt; KeyType &gt; Struct Template Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Internal ART key in lexicographically ordered binary-comparable format.  
 <a href="structunodb_1_1detail_1_1basic__art__key.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="art__internal_8hpp_source.html">art_internal.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7f769f160a22d930903da7c9f53605c7" id="r_a7f769f160a22d930903da7c9f53605c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html#a7f769f160a22d930903da7c9f53605c7">basic_art_key</a> (KeyType key_) noexcept</td></tr>
<tr class="memdesc:a7f769f160a22d930903da7c9f53605c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from fixed width primitive type <em>key_</em>.  <br /></td></tr>
<tr class="separator:a7f769f160a22d930903da7c9f53605c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd136279afad971b15c30847e2da1a6" id="r_adcd136279afad971b15c30847e2da1a6"><td class="memItemLeft" align="right" valign="top"><a id="adcd136279afad971b15c30847e2da1a6" name="adcd136279afad971b15c30847e2da1a6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>basic_art_key</b> (<a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">key_view</a> key_) noexcept</td></tr>
<tr class="memdesc:adcd136279afad971b15c30847e2da1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from <em>key_</em> view which must already be lexicographically ordered. <br /></td></tr>
<tr class="separator:adcd136279afad971b15c30847e2da1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb7df8faa6c346f5b974a50dc1331b3" id="r_aaeb7df8faa6c346f5b974a50dc1331b3"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html#aaeb7df8faa6c346f5b974a50dc1331b3">cmp</a> (<a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">basic_art_key</a>&lt; KeyType &gt; key2) const noexcept</td></tr>
<tr class="memdesc:aaeb7df8faa6c346f5b974a50dc1331b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare with another <em>key2</em>.  <br /></td></tr>
<tr class="separator:aaeb7df8faa6c346f5b974a50dc1331b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0b18ff7b89651418db68d8eb236519" id="r_a4c0b18ff7b89651418db68d8eb236519"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html#a4c0b18ff7b89651418db68d8eb236519">cmp</a> (<a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">key_view</a> key2) const noexcept</td></tr>
<tr class="memdesc:a4c0b18ff7b89651418db68d8eb236519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare with a <em>key2</em> view.  <br /></td></tr>
<tr class="separator:a4c0b18ff7b89651418db68d8eb236519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5234b1c24ea8029f6ca8a4ce3c4231f" id="r_aa5234b1c24ea8029f6ca8a4ce3c4231f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html#aa5234b1c24ea8029f6ca8a4ce3c4231f">operator[]</a> (std::size_t index) const noexcept</td></tr>
<tr class="memdesc:aa5234b1c24ea8029f6ca8a4ce3c4231f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return byte at specified <em>index</em> position in binary comparable key.  <br /></td></tr>
<tr class="separator:aa5234b1c24ea8029f6ca8a4ce3c4231f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20e5187f7869ad48ab185a6fc09a61d" id="r_af20e5187f7869ad48ab185a6fc09a61d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">key_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html#af20e5187f7869ad48ab185a6fc09a61d">get_key_view</a> () const noexcept</td></tr>
<tr class="memdesc:af20e5187f7869ad48ab185a6fc09a61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return backing key_view.  <br /></td></tr>
<tr class="separator:af20e5187f7869ad48ab185a6fc09a61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54cec3bcc93c7e935445b0f8273942f" id="r_ac54cec3bcc93c7e935445b0f8273942f"><td class="memItemLeft" align="right" valign="top">constexpr std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html#ac54cec3bcc93c7e935445b0f8273942f">get_u64</a> () const noexcept</td></tr>
<tr class="memdesc:ac54cec3bcc93c7e935445b0f8273942f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return first 64 bits (max) of encoded key.  <br /></td></tr>
<tr class="separator:ac54cec3bcc93c7e935445b0f8273942f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883f9d04af426ae51af3b3f8b6c0026d" id="r_a883f9d04af426ae51af3b3f8b6c0026d"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html#a883f9d04af426ae51af3b3f8b6c0026d">shift_right</a> (const std::size_t num_bytes) noexcept</td></tr>
<tr class="memdesc:a883f9d04af426ae51af3b3f8b6c0026d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift internal key by <em>num_bytes</em> number of bytes to the right.  <br /></td></tr>
<tr class="separator:a883f9d04af426ae51af3b3f8b6c0026d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e070387a8d6335076f3d14bad7e7b25" id="r_a1e070387a8d6335076f3d14bad7e7b25"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html#a1e070387a8d6335076f3d14bad7e7b25">size</a> () const noexcept</td></tr>
<tr class="memdesc:a1e070387a8d6335076f3d14bad7e7b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of bytes required to represent key.  <br /></td></tr>
<tr class="separator:a1e070387a8d6335076f3d14bad7e7b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5a6bb536028d38b08447c64cd91cf1" id="r_a0a5a6bb536028d38b08447c64cd91cf1"><td class="memItemLeft" align="right" valign="top"><a id="a0a5a6bb536028d38b08447c64cd91cf1" name="a0a5a6bb536028d38b08447c64cd91cf1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump</b> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:a0a5a6bb536028d38b08447c64cd91cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump key in lexicographic byte-wise order to stream <em>os</em>. <br /></td></tr>
<tr class="separator:a0a5a6bb536028d38b08447c64cd91cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cb5d0c123c5ff8fc83f2e724b0e4b6" id="r_aa8cb5d0c123c5ff8fc83f2e724b0e4b6"><td class="memItemLeft" align="right" valign="top"><a id="aa8cb5d0c123c5ff8fc83f2e724b0e4b6" name="aa8cb5d0c123c5ff8fc83f2e724b0e4b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump</b> () const</td></tr>
<tr class="memdesc:aa8cb5d0c123c5ff8fc83f2e724b0e4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump key to <code>std::cerr</code> for debugging. <br /></td></tr>
<tr class="separator:aa8cb5d0c123c5ff8fc83f2e724b0e4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490eb34a936dde9580a0bee6096c8596" id="r_a490eb34a936dde9580a0bee6096c8596"><td class="memItemLeft" align="right" valign="top"><a id="a490eb34a936dde9580a0bee6096c8596" name="a490eb34a936dde9580a0bee6096c8596"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump</b> () const</td></tr>
<tr class="separator:a490eb34a936dde9580a0bee6096c8596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1eeceb64f9b2e4a61c3bfb7190defe" id="r_aff1eeceb64f9b2e4a61c3bfb7190defe"><td class="memItemLeft" align="right" valign="top"><a id="aff1eeceb64f9b2e4a61c3bfb7190defe" name="aff1eeceb64f9b2e4a61c3bfb7190defe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump</b> () const</td></tr>
<tr class="separator:aff1eeceb64f9b2e4a61c3bfb7190defe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7f533761914d776e97107316f117db14" id="r_a7f533761914d776e97107316f117db14"><td class="memItemLeft" align="right" valign="top"><a id="a7f533761914d776e97107316f117db14" name="a7f533761914d776e97107316f117db14"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>static_asserts</b> ()</td></tr>
<tr class="memdesc:a7f533761914d776e97107316f117db14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time assertions for type invariants. <br /></td></tr>
<tr class="separator:a7f533761914d776e97107316f117db14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a783451041f4dab2a36a526115df72ace" id="r_a783451041f4dab2a36a526115df72ace"><td class="memItemLeft" ><a id="a783451041f4dab2a36a526115df72ace" name="a783451041f4dab2a36a526115df72ace"></a>
union {&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdd04bac3868f72a2e21db67efc2d8a" id="r_a7cdd04bac3868f72a2e21db67efc2d8a"><td class="memItemLeft" >&#160;&#160;&#160;KeyType&#160;&#160;&#160;<a class="el" href="structunodb_1_1detail_1_1basic__art__key.html#abc8d474caa99eac94a1b49eee7a9df07">key</a>&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="memdesc:a7cdd04bac3868f72a2e21db67efc2d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographic byte-wise comparable binary key.  <a href="structunodb_1_1detail_1_1basic__art__key.html#abc8d474caa99eac94a1b49eee7a9df07">More...</a><br /></td></tr>
<tr class="separator:a7cdd04bac3868f72a2e21db67efc2d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f29b29e1ec9e9dc0d696fbdd26cc10" id="r_a77f29b29e1ec9e9dc0d696fbdd26cc10"><td class="memItemLeft" >&#160;&#160;&#160;std::array&lt; std::byte, sizeof(KeyType)&gt;&#160;&#160;&#160;<a class="el" href="structunodb_1_1detail_1_1basic__art__key.html#aa1c673bbd12a302556a7880df52aa9b8">key_bytes</a>&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="memdesc:a77f29b29e1ec9e9dc0d696fbdd26cc10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte array overlay for indexing into fixed-width keys.  <a href="structunodb_1_1detail_1_1basic__art__key.html#aa1c673bbd12a302556a7880df52aa9b8">More...</a><br /></td></tr>
<tr class="separator:a77f29b29e1ec9e9dc0d696fbdd26cc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783451041f4dab2a36a526115df72ace" id="r_a783451041f4dab2a36a526115df72ace"><td class="memItemLeft" valign="top">};&#160;</td><td class="memItemRight" valign="bottom">&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:a783451041f4dab2a36a526115df72ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a2424f684fcd0eb8c9af138caaf4befe5" id="r_a2424f684fcd0eb8c9af138caaf4befe5"><td class="memItemLeft" align="right" valign="top">static KeyType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html#a2424f684fcd0eb8c9af138caaf4befe5">make_binary_comparable</a> (KeyType k) noexcept</td></tr>
<tr class="memdesc:a2424f684fcd0eb8c9af138caaf4befe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert simple external key into internal key for lexicographic comparison.  <br /></td></tr>
<tr class="separator:a2424f684fcd0eb8c9af138caaf4befe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a9df8f2c9dc5f0b843d97ce6b35f16407" id="r_a9df8f2c9dc5f0b843d97ce6b35f16407"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html#a9df8f2c9dc5f0b843d97ce6b35f16407">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">basic_art_key</a> &amp;k)</td></tr>
<tr class="memdesc:a9df8f2c9dc5f0b843d97ce6b35f16407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump key <em>k</em> to stream <em>os</em>.  <br /></td></tr>
<tr class="separator:a9df8f2c9dc5f0b843d97ce6b35f16407"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename KeyType&gt;<br />
struct unodb::detail::basic_art_key&lt; KeyType &gt;</div><p>Internal ART key in lexicographically ordered binary-comparable format. </p>
<p>Application keys may be simple fixed width types (such as <code>std::uint64_t</code>) or variable length keys. For the former, there are convenience methods on <a class="el" href="classunodb_1_1db.html" title="A non-thread-safe implementation of the Adaptive Radix Tree (ART).">unodb::db</a>, <a class="el" href="classunodb_1_1olc__db.html" title="A thread-safe Adaptive Radix Tree that is synchronized using optimistic lock coupling.">unodb::olc_db</a>, etc. to convert external keys into the binary comparable format. For the latter, the application is responsible for converting the data (e.g., certain columns in some ordering for a row of some relation) into the internal binary comparable key format.</p>
<p>A convenience class (<a class="el" href="classunodb_1_1key__encoder.html" title="A utility class to generate binary comparable keys from a sequence of key components.">unodb::key_encoder</a>) is offered to encode data. The encoding is always well defined and decoding (<a class="el" href="classunodb_1_1key__decoder.html" title="A utility class for decoding binary comparable keys produced by unodb::key_encoder,...">unodb::key_decoder</a>) exists for all simple fixed width data types.</p>
<p>Unicode encoding is complex and out of scope - use a quality library such as ICU to produce appropriate Unicode sort keys for your application. Unicode decoding is NOT well defined. Applications involving database records and Unicode data will typically store the record identifier in a secondary index (ART) as the value associated with the key. Using the record identifier, the original tuple can be discovered and the original Unicode data recovered from that tuple.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>Fixed-width integral type or <code>key_view</code> for variable length </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7f769f160a22d930903da7c9f53605c7" name="a7f769f160a22d930903da7c9f53605c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f769f160a22d930903da7c9f53605c7">&#9670;&#160;</a></span>basic_art_key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">unodb::detail::basic_art_key</a>&lt; KeyType &gt;::basic_art_key </td>
          <td>(</td>
          <td class="paramtype">KeyType&#160;</td>
          <td class="paramname"><em>key_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from fixed width primitive type <em>key_</em>. </p>
<dl class="section note"><dt>Note</dt><dd>Use a <a class="el" href="classunodb_1_1key__encoder.html" title="A utility class to generate binary comparable keys from a sequence of key components.">unodb::key_encoder</a> for complex keys, including multiple key components or Unicode data. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aaeb7df8faa6c346f5b974a50dc1331b3" name="aaeb7df8faa6c346f5b974a50dc1331b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb7df8faa6c346f5b974a50dc1331b3">&#9670;&#160;</a></span>cmp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">unodb::detail::basic_art_key</a>&lt; KeyType &gt;::cmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">basic_art_key</a>&lt; KeyType &gt;&#160;</td>
          <td class="paramname"><em>key2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare with another <em>key2</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>-1, 0, or 1 if this key is LT, EQ, or GT the other key </dd></dl>

</div>
</div>
<a id="a4c0b18ff7b89651418db68d8eb236519" name="a4c0b18ff7b89651418db68d8eb236519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0b18ff7b89651418db68d8eb236519">&#9670;&#160;</a></span>cmp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">unodb::detail::basic_art_key</a>&lt; KeyType &gt;::cmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">key_view</a>&#160;</td>
          <td class="paramname"><em>key2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare with a <em>key2</em> view. </p>
<dl class="section return"><dt>Returns</dt><dd>-1, 0, or 1 if this key is LT, EQ, or GT the other key </dd></dl>

</div>
</div>
<a id="af20e5187f7869ad48ab185a6fc09a61d" name="af20e5187f7869ad48ab185a6fc09a61d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af20e5187f7869ad48ab185a6fc09a61d">&#9670;&#160;</a></span>get_key_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90">key_view</a> <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">unodb::detail::basic_art_key</a>&lt; KeyType &gt;::get_key_view </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return backing key_view. </p>
<dl class="section return"><dt>Returns</dt><dd>Key view of this key's bytes</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For integral keys, this is a non-owned view of the data in the <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html" title="Internal ART key in lexicographically ordered binary-comparable format.">basic_art_key</a> and will be invalid if that object goes out of scope.</dd>
<dd>
For key_view keys, this is the key_view backing this art_key and its validity depends on the scope of the backing byte array. </dd></dl>

</div>
</div>
<a id="ac54cec3bcc93c7e935445b0f8273942f" name="ac54cec3bcc93c7e935445b0f8273942f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54cec3bcc93c7e935445b0f8273942f">&#9670;&#160;</a></span>get_u64()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint64_t <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">unodb::detail::basic_art_key</a>&lt; KeyType &gt;::get_u64 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return first 64 bits (max) of encoded key. </p>
<p>Used by prefix compression logic to identify bytes in common between an art_key and an inode having some <a class="el" href="unionunodb_1_1detail_1_1key__prefix.html" title="The unodb::detail::key_prefix is a sequence of zero or more bytes for a given node that are a common ...">key_prefix</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>First 64 bits of key </dd></dl>

</div>
</div>
<a id="a2424f684fcd0eb8c9af138caaf4befe5" name="a2424f684fcd0eb8c9af138caaf4befe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2424f684fcd0eb8c9af138caaf4befe5">&#9670;&#160;</a></span>make_binary_comparable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static KeyType <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">unodb::detail::basic_art_key</a>&lt; KeyType &gt;::make_binary_comparable </td>
          <td>(</td>
          <td class="paramtype">KeyType&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert simple external key into internal key for lexicographic comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>External key to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Binary comparable key </dd></dl>

</div>
</div>
<a id="aa5234b1c24ea8029f6ca8a4ce3c4231f" name="aa5234b1c24ea8029f6ca8a4ce3c4231f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5234b1c24ea8029f6ca8a4ce3c4231f">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">unodb::detail::basic_art_key</a>&lt; KeyType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return byte at specified <em>index</em> position in binary comparable key. </p>
<dl class="section return"><dt>Returns</dt><dd>Byte at position </dd></dl>

</div>
</div>
<a id="a883f9d04af426ae51af3b3f8b6c0026d" name="a883f9d04af426ae51af3b3f8b6c0026d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883f9d04af426ae51af3b3f8b6c0026d">&#9670;&#160;</a></span>shift_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">unodb::detail::basic_art_key</a>&lt; KeyType &gt;::shift_right </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>num_bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift internal key by <em>num_bytes</em> number of bytes to the right. </p>
<p>Leading bytes are discarded, causing key to be shorter by that many bytes. It is a lexicographic key. The first byte is the most significant. The last byte is the least significant.</p>
<p>When backed by a u64, we get trailing bytes which are zeros. Thus, for a fixed width type, this causes the key to be logically zero filled as it becomes shorter. E.g.</p>
<p><code>0x0011223344556677 shift_right(2) =&gt; 0x2233445566770000</code> </p>

</div>
</div>
<a id="a1e070387a8d6335076f3d14bad7e7b25" name="a1e070387a8d6335076f3d14bad7e7b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e070387a8d6335076f3d14bad7e7b25">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">unodb::detail::basic_art_key</a>&lt; KeyType &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return number of bytes required to represent key. </p>
<dl class="section return"><dt>Returns</dt><dd>Key size in bytes </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a9df8f2c9dc5f0b843d97ce6b35f16407" name="a9df8f2c9dc5f0b843d97ce6b35f16407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df8f2c9dc5f0b843d97ce6b35f16407">&#9670;&#160;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">basic_art_key</a>&lt; KeyType &gt; &amp;&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dump key <em>k</em> to stream <em>os</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to stream </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="abc8d474caa99eac94a1b49eee7a9df07" name="abc8d474caa99eac94a1b49eee7a9df07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8d474caa99eac94a1b49eee7a9df07">&#9670;&#160;</a></span>key</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KeyType <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">unodb::detail::basic_art_key</a>&lt; KeyType &gt;::key</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lexicographic byte-wise comparable binary key. </p>
<dl class="section note"><dt>Note</dt><dd>When <code>KeyType == key_view</code>, this is all you need. </dd></dl>

</div>
</div>
<a id="aa1c673bbd12a302556a7880df52aa9b8" name="aa1c673bbd12a302556a7880df52aa9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c673bbd12a302556a7880df52aa9b8">&#9670;&#160;</a></span>key_bytes</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::byte, sizeof(KeyType)&gt; <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">unodb::detail::basic_art_key</a>&lt; KeyType &gt;::key_bytes</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Byte array overlay for indexing into fixed-width keys. </p>
<p>Provides a mechanism to index into the bytes in the key for operator[]. Ignored if <code>KeyType == key_view</code> as key_view provides a byte-wise index operator already. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="art__internal_8hpp_source.html">art_internal.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceunodb.html">unodb</a></li><li class="navelem"><a class="el" href="namespaceunodb_1_1detail.html">detail</a></li><li class="navelem"><a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">basic_art_key</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
